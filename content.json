[{"title":"【每日更新】算法题","date":"2020-04-21T12:17:21.000Z","path":"2020/04/21/【每日更新】算法题/","text":"20200425 晴题1复杂链表的复制做题前思路首先要注意要求是复制结点，而不是复制引用。 其次要注意random属性。 题2 序列化二叉树思路层序遍历。 在序列化操作的时候，要注意左右子树的空结点也要加入队列。 在反序列化的时候，用一个结点数组保存所有节点（包含左右空节点）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Queue;import java.util.LinkedList;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; String Serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); Queue &lt;TreeNode&gt; queue = new LinkedList &lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode currentNode = queue.poll(); if(currentNode != null)&#123; sb.append(currentNode.val+\",\"); queue.offer(currentNode.left); //不管是否为空都会加入队列 queue.offer(currentNode.right); &#125;else&#123; sb.append(\"#\"+\",\"); &#125; &#125; return sb.toString(); &#125; TreeNode Deserialize(String str) &#123; String [] nodeVals = str.split(\",\"); TreeNode [] nodes = new TreeNode[nodeVals.length]; for(int i = 0; i&lt;nodeVals.length; i++)&#123; if(!nodeVals[i].equals(\"#\"))&#123; nodes[i] = new TreeNode(Integer.valueOf(nodeVals[i])); &#125; &#125; int i=1; for(TreeNode node : nodes)&#123; if(node != null)&#123; node.left=nodes[i++]; node.right=nodes[i++]; &#125; &#125; return nodes[0] ; &#125;&#125; 题3 数组中重复的数字思路HashSet 时间复杂度O(n) 空间复杂度O(n) 参考别人的：重排数组 ：时间复杂度O(n)，空间复杂度O(1)。 12345678910111213141516171819202122232425public class Solution数组中重复的数字 &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers == null)&#123; return false; &#125; HashSet &lt;Integer&gt; set = new HashSet &lt;&gt;(); for (int i = 0; i&lt;numbers.length ; i++)&#123; if(!set.contains(numbers[i]))&#123; set.add(numbers[i]); &#125;else&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false; &#125;&#125; 【待解决】题4 数组中的逆序对思路 暴力求解：从第一个元素开始，判断后面比它小的元素的个数 O(n^2)，不出所料，运行超时，通过50%的用例。 【待学习】提示：归并的改进 20200422题1 二叉搜索树的第k个结点做题前思路给定一棵二叉搜索树，请找出其中的第k小的结点。根据BST中序遍历结果是升序的这一性质，可以中序遍历，直到遍历到第k个结点。 按照此思路的代码：12345678910111213141516171819202122//中序递归，成功ACpublic class Solution &#123; int num; //num表示当前中序遍历已经访问了几个元素 TreeNode node; //node存放结果 TreeNode KthNode(TreeNode pRoot, int k) &#123; inorder(pRoot,k); return this.node; &#125; void inorder(TreeNode node,int k)&#123; if(node==null)&#123; return; &#125; inorder(node.left,k); num++; if(num==k)&#123; this.node=node; return; //结束后续的访问 &#125; inorder(node.right,k); &#125;&#125; 分析：就算找到了Kth结点也会遍历完整个BST。时间复杂度是O(N) 改进：可以考虑非递归实现中序遍历，这样就能在找到Kth结点后结束遍历。 【待解决】题2 字符流中第一个不重复的字符做题前思路hashmap 知识点 LinkedHashMap和HashMap的差别 LinkedHashMap Hashmap遍历方法 题3 统计一个数字在排序数组中出现的次数做题前思路 法1：二分查找定位该数字，再找左边和右边相等的元素个数。 多种方法改进参考文章 最后采用的方法：因为数组中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。 123456789101112131415161718192021222324252627282930313233/** * @Created by hfq on 2020/4/23 * @used to: */public class Solution数字在排序数组中出现的次数 &#123; public int GetNumberOfK(int [] array , int k) &#123; return BinarySearch(array,(float)(k+0.5)) - BinarySearch(array,(float)(k-0.5)); &#125; //返回目标t插入array的位置 public static int BinarySearch(int [] array , float t)&#123; int i = 0; int j = array.length-1; int mid = 0; while(i&lt;=j)&#123; //&lt;= 等号不可遗漏！！ mid = j+(i-j)/2; if(array[mid] &gt; t)&#123; //在左边查找 j = mid-1; &#125;else if(array[mid] &lt; t)&#123; //在右边查找 i = mid+1; &#125;else&#123; //实际上不可能发生，可以和上面的else if合并 &#125; &#125; return i; //array[mid]在array[i]和array[j]中添加 &#125; public static void main(String[] args) &#123;// int [] a = &#123;3,3,3,3&#125;; int [] a = &#123;3,3,3,3&#125;; System.out.println(BinarySearch(a, (float) 2.5)); System.out.println(BinarySearch(a, (float) 3.5)); &#125;&#125; 分析：这种做法在各种情况下效率都比较高。 当数组是：[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]，如果采用法1，效率退化成O(n),而这种方法时间复杂度还是O(lgn)级别的 20200421题1：栈的压入、弹出序列代码：1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA==null||pushA.length==0) return true; int stack [] = new int[pushA.length]; int size = 0; int pushIndex=0; stack[size++] = pushA[pushIndex++]; int current = 0; while(pushIndex&lt;pushA.length) &#123; if(stack[size-1]!=popA[current]) &#123; stack[size++] = pushA[pushIndex++]; &#125;else&#123; size--; current++; &#125; &#125; while (size!=0)&#123; if(stack[size-1]!=popA[current]) &#123; return false; &#125; else &#123; size--; current++; &#125; &#125; if(size==0) return true; return false; &#125;&#125; 解析：以输入{1,2,3,4,5}，{4,5,3,2,1}为例。 借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 我的代码没有用JDK提供的Stack，而是用一个数组+size模拟栈。 题2：二叉树的下一个结点代码1234567891011121314151617181920public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; TreeLinkNode successor = null; //表示后续结点，保存返回结果 //当这个结点有右子树，那么其后续结点必然在其右子树中的最小的元素 if(pNode.right!=null)&#123; successor = pNode.right; while(successor.left!=null)&#123; successor = successor.left; //一直向左走找最小的元素 &#125; &#125;else if(pNode.next != null)&#123; //没有右子树但是有根节点 successor = pNode; while(successor.next != null &amp;&amp; successor == successor.next.right)&#123; successor = successor.next; //当此结点始终是其父节点的右子树的时候，逐级找父节点 &#125; successor = successor.next; &#125; return successor; &#125;&#125; 解析：求二叉树某一结点的后续结点。 image-20200421205013742 根据这个pNode结点的状态，分为三种情况求解: pNode存在右子树，那么其后续结点必然在其右子树中。 这是由中序遍历的定义决定的：若某节点存在右子树，那么访问完这个结点后访问的下一个结点必然是右子树中的某个结点。 返回结果是 pNode.right.left.left.left…. pNode不存在右子树，但存在父节点，那么其后续结点是其祖父结点，或者是null 既不存在右子树，也不存在父节点，返回null 提示： 可以借助二叉树的一种特殊情况——二叉搜索树思考这题，上述代码的注释就是这样做的，表面看我们考虑的是特殊情况，但是实际上这样做对二叉树具有普遍性。 另外提一下，这道题目有点坑的地方是：包含指向父结点的指针的变量名是next，不是parent，注意一下。 【待解决】题3:顺时针打印矩阵被这道题虐了很久。。 一直会忽略某些情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hfq;import java.util.ArrayList;public class Main &#123; public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); addElementToList(matrix,0,matrix.length-1,0,matrix[0].length-1,list); return list; &#125; public static void addElementToList(int [][] matrix,int rowsMin,int rowsMax,int colsMin,int colsMax,ArrayList list) &#123; if(colsMax&lt;0 &amp;&amp; rowsMax&lt;0)&#123; return; &#125; for(int i = colsMin; i&lt;=colsMax ; i++)&#123; //从左往右 list.add(matrix[rowsMin][i]); // System.out.println(matrix[rowsMin][i]); &#125; if(rowsMax&gt;rowsMin)&#123; for(int i = rowsMin+1; i&lt;=rowsMax ; i++)&#123; //从上往下// System.out.println(\"i=\"+i+\",colsMax\"+colsMax); list.add(matrix[i][colsMax]); //System.out.println(matrix[i][colsMax]); &#125; &#125; if(colsMax-1&gt;colsMin)&#123; for(int i = colsMax-1; i&gt;=colsMin ; i--)&#123; //从右往左 list.add(matrix[rowsMax][i]); // System.out.println(matrix[rowsMax][i]); &#125; &#125; if(colsMax-colsMin&gt;=1 &amp;&amp; colsMax &gt; colsMin )&#123; for(int i = rowsMax-1; i&gt;=rowsMin+1 ; i--)&#123; //从下往上 list.add(matrix[i][colsMin]); // System.out.println(matrix[i][colsMin]); &#125; &#125; addElementToList(matrix,rowsMin+1,rowsMax-1,colsMin+1,colsMax-1,list); &#125; public static void main(String[] args) &#123;// int a [][] =&#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;&#125;;// int a [][] =&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;; int a [][] =&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;,&#123;7,8&#125;,&#123;9,10&#125;&#125;; ArrayList&lt;Integer&gt; integers = printMatrix(a); for(Integer integer:integers)&#123; System.out.printf(integer+\",\"); &#125; &#125;&#125; 题4:包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。 思路一开始我的想法很简单，用一个使用一个变量记录当前的最小元素，如果新压入栈的元素更小，就更新它。 但是仔细一想，这种做法有一个问题，假如记录的最小元素出栈了，就没办法以O(1）的时间复杂度获取新的最小元素了，所以在保存最小元素的同时，有必要保存最小元素出栈后次要小的元素，同理，也要保存第三小的元素…. 所以，要用一个辅助栈来保存当前的最小元素以及之前的的最小元素，栈顶就是当前栈的最小元素，栈顶元素的下一个元素就是这个元素出栈后的新的最小元素。 每次压栈时，如果压入的元素小于当前最小元素，则也将其压入辅助栈，否则，则将上一个最小元素压入辅助栈。 每次出栈时，弹出元素的同时也弹出辅助栈的元素。 知识点复习Stack的API peek() size() pop() push() 代码12345678910111213141516171819202122232425262728import java.util.Stack;public class Solution &#123; public Stack &lt;Integer&gt; stack = new Stack&lt;&gt;(); //数据栈 public Stack &lt;Integer&gt; minStack = new Stack&lt;&gt;();; //辅助栈 public void push(int node) &#123; stack.push(node); if(stack.size()==1)&#123; //现在是1，说明压栈前是0。 minStack.push(node); &#125;else&#123; minStack.push(node&lt;minStack.peek() ? node : minStack.peek()); &#125; &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125; 题解关键字 ：最小值辅助栈 题5 把数组排成最小的数没啥思路，借鉴了网上的解法，觉得很妙。 关键字：自定义比较大小的方法。 提示转成字符串，自定义比较器后排序 知识点复习 int类型转成String类型 String.valueOf(i) Integer.toString(i) i+”” 比较字符串大小 拼接字符串 （StringBuilder） sb.append() sb.toString() 代码细节 Arrays.sort() import java.util.Arrays; Comparator import java.util.Comparator; 123456new Comparator&lt;String&gt;() &#123; @Override public int compare(String str1, String str2) &#123; //3 12 312 123 return 0; &#125;&#125; 代码12345678910111213141516171819202122232425262728293031/** * https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993 * @Created by hfq on 2020/4/22 * @used to: * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数， * 打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。 */public class Solution把数组排成最小的数 &#123; public static String PrintMinNumber(int [] numbers) &#123; StringBuilder sb = new StringBuilder(); String numString [] = new String[numbers.length]; for (int i=0; i&lt;numbers.length; i++)&#123; numString[i]=String.valueOf(numbers[i]); //将整数转成字符串 &#125; Arrays.sort(numString, new Comparator&lt;String&gt;() &#123; @Override public int compare(String str1, String str2) &#123; //3 12 312 123 return 0; &#125; &#125;); for (String str : numString)&#123; sb.append(str); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; int[]numbers=&#123;3,32,321&#125;; System.out.println(PrintMinNumber(numbers)); &#125;&#125; 进度：25题/67题。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://hfq123.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"《Head-First-设计模式》读书笔记charpter8","date":"2020-04-21T06:52:00.000Z","path":"2020/04/21/《Head-First-设计模式》读书笔记charpter8/","text":"本篇博客是《Head First 设计模式》第八章的读书笔记。 分享主题是设计模式中的 「模板方法模式(Template Method Pattern)」。 定义模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 具体应用场景从饮品店制作咖啡和茶的制作方法讲起，咖啡和茶的制作流程如下图所示。 咖啡和茶的制作流程 接下来用代码表示咖啡的制作过程： 12345678910111213141516171819202122232425/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的制作流程 */public class Coffee &#123; public void prepareRecipe()&#123; //冲泡咖啡 boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void brewCoffeeGrinds()&#123; System.out.println(\"Dripping Coffee through filter\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addSugarAndMilk()&#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125; 同样的，茶的制作过程代码如下： 123456789101112131415161718192021222324/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea &#123; public void prepareRecipe()&#123; //冲泡茶 boilWater(); steepTeaBag(); pourInCup(); addLemon(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void steepTeaBag()&#123; System.out.println(\"Steeping the tea\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addLemon()&#123; System.out.println(\"Adding lemon\"); &#125;&#125; 可以发现，boilWater()和pourInCup()方法的代码重复了。究其原因，这是因为咖啡和茶的制作流程大致上一样，它们的制作过程都可以用下图的算法表示，1、3步骤是一样的，2、4步骤有差异，所以我们想到用继承的方法重用1、3步骤的代码，将实现1、3步骤的方法抽取到一个父类中，而2、4步骤这两个有差异的步骤在咖啡子类和茶子类中实现。 制作咖啡和制作茶的相同和不同的步骤 基于此想法，我们设置一个咖啡因饮料的父类： 1234567891011121314151617181920212223/** * @Created by hfq on 2020/4/21 * @used to: 咖啡因饮料的父类，是一个抽象类 */abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); addCondiments(); &#125; void boilWater()&#123; //步骤1，共同的操作，由父类实现 System.out.println(\"Bolling water\"); &#125; abstract void brew(); //步骤2，冲泡，由于不同饮料实现有差异，由子类实现 void pourInCup()&#123; //步骤3，共同的操作，由父类实现 System.out.println(\"Pouring into cup\"); &#125; abstract void addCondiments(); //步骤4，添加调料，由于不同饮料实现有差异，由子类实现&#125; 现在咖啡子类和茶子类的代码就变成了： 12345678910111213141516171819202122232425262728293031/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的冲泡流程 */public class Coffee extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Dripping Coffee through filter\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125;/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Steeping the tea\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding Lemon\"); &#125;&#125; 这样，我们就完成了共同代码（prepareRecipe()、boilWater()、pourInCup()三个方法）的重用。其中，prepareRecipe()方法就叫做模板方法。它作为制作咖啡因饮料算法的模板，在这个模板中，每个步骤都被一个方法代表了，其中，制作不同的咖啡因饮料有共同的步骤：就是上文说的步骤1和步骤3，它们可以直接在父类中实现(分别对应于boilWater()和pourInCup()方法)。制作不同的咖啡因饮料也有不同的步骤：步骤2和步骤4，由于子类有不同的实现，所以父类中不实现，设置为抽象方法，由子类实现，这就是模板方法模式中说的“将一些步骤延迟到子类中”。 如果有新的制作流程一致的咖啡因饮料加入，只需要继承父类，并负责实现父类的抽象方法（表示制作步骤中不同的部分）。 UML图模板方法模式的UML建模图如下： 模板方法模式的UML建模图 使用钩子(Hook)在上例中引入一个新的需求：客户可以自行选择是否需要在饮料中加入调料（也就是选择是否执行制作饮料中的步骤4），这时模板方法的钩子就起作用了。 做法很简单：在模板方法中，加入判断，如果判断为真，则执行步骤4，修改后的模板方法类代码如下： 1234567891011121314abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); if(customerWantsCondimentsHook())&#123; addCondiments(); &#125; &#125; ...省略了相同的代码.... boolean customerWantsCondimentsHook()&#123; //这是一个钩子，子类可以选择是否覆盖 return true; &#125;&#125; 这样一来，在子类中可以覆盖customerWantsCondimentsHook()方法来自行选择是否需要执行步骤4，它还可以更灵活地实现钩子：比如接受用户的输入，据此判断是否需要执行该步骤。 在这里，钩子作为条件控制，影响了抽象类的算法流程。 好莱坞原则书中本章引入了一个新的设计原则，称为好莱坞原则： 好莱坞原则（Hollywood Principle）：别打电话给我们，有事我会打电话给你。 好莱坞原则和模板方法之间的连接比较明显，当我们设计模板方法模式时，我们告诉子类，不要调用我们，我们会调用你。让我们再看一下的咖啡因饮料的设计类图： 好莱坞原则和模板方法 Java API中的模板方法书中指出，模板方法模式很常见，因为对于创建框架来说，这个模式简直棒极了。由框架控制如何做事情，而由使用框架的人指定框架算法中的每个步骤的细节。另外，模板方法有多种实现，不一定看起来和上例讲述的设计一致。 书中给出三个java api中的模板方法示例： 类实现comparable接口后可以用Collections.sort Swing Applet 第一个示例归结于模板方法我觉得似乎有些牵强，后两个示例平时开发没使用过，不熟悉。所以讲讲另外一个比较熟悉的示例吧：Servlet类的service()方法就是一个模板方法，定义了算法骨架，doGet()、doPost()方法是这个算法骨架中的具体步骤，子类可以实现自己的doGet()方法和doPost()方法，这样做子类自己的doGet()、doPost()方法就”挂进”了父类service()方法这一模板方法。 与我们上文咖啡因饮料示例不同的是，子类具有不同实现的方法在父类是抽象的，子类必须实现，而Servlet中的doGet()和doPost()有默认实现。 Servlet中的模板方法 Servlet中的模板方法具体实现参考这里。 总结 模板方法模式实际上是封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同实现，从而让固定的流程产生不同的结果。 模板方法封装了有固定结构的算法块，模板类中可以有各个子类具有相同实现的方法，也可以有各个子类具有不同实现的方法，具有相同实现的方法可以直接在父类（模板方法所在的类）中实现，而各个子类具有不同实现的方法由每个子类自行实现，这样做，子类实现的方法就“挂接”进模板方法里。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter7","date":"2020-04-20T14:40:09.000Z","path":"2020/04/20/《Head-First-设计模式》读书笔记charpter7/","text":"本篇博客是《Head First 设计模式》第七章的读书笔记。 分享主题是设计模式中的 「适配器模式(Adapter Pattern)」以及 「外观模式(Facade Pattern)」。 适配器模式由于这两种设计模式都比较好理解，所以先直接从定义讲起。 定义适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 日常生活的类比我们先用日常生活中例子类比来理解适配器模式。如下图，由于接口的差异，美国笔记本电脑插头无法直接插进欧洲插座获电，而使用了中间的接口转换器后，问题就解决了。而值得注意的是，从无法使用到可以使用，我们既没有改变插座，也没有改变插头，唯一的变化就是引入了接口转换器这一适配器。在这里，这个适配器的作用就是将现有的不符合标准的插头接口“转化”成目标接口，这也正是适配器模式做的全部工作。 插头接口转换器的例子 具体应用场景如下图，系统中有两个接口:Duck和Turkey，它们都有fly()方法，这两个接口的差异在于Duck的quack()和Turkey接口的gobble()方法。MallardDuck和WildTurkey分别实现了Duck接口和Turkey接口。 image-20200420231854471 此外，在外部有个testDuck方法，它的参数是一个Duck对象，在方法体内分别调用了这个Duck对象的quack()方法和fly()方法，我们无需关注它的目的是什么，只需要关注要想调用这个方法，需要一个Duck类型的对象作为参数。 1234public static void testDuck(Duck duck)&#123; duck.quack(); duck.fly(); &#125; 接下来看看下面这段代码，testDuck(wildTurkey)这行代码必然会报错，因为wildTurkey 不是 Duck类型的。 123456789public static void main(String[] args) &#123; System.out.println(\"A duck says:\"); Duck mallardDuck =new MallardDuck(); testDuck(mallardDuck); //这行代码可以正常执行 System.out.println(\"A turkey says:\"); Turkey wildTurkey =new WildTurkey(); testDuck(wildTurkey); //这行代码必然会报错，因为wildTurkey 不是 Duck类型的。&#125; 我们用这个例子来类比上文中插头接口转换器的例子，testDuck()这个方法就相当于上例中的插座，它要求一个Duck对象作为参数才可以正常使用（换句话说，它的标准是Duck接口），就相当于欧洲插座要求一个符合欧洲标准的插头才能正常使用，不符合testDuck()标准的wildTurkey对象就相当于上例中的美国插头（类比详见下图）。而如果我们要是想在不改动WildTurkey类代码的基础上，完成testDuck(wildTurkey)这条语句的功能，就要想办法构建一个上例中的适配器。 类比插头接口转换器的例子 构建TurkeyAdapter这个适配器： 123456789101112131415161718192021/** * @Created by hfq on 2020/4/21 * @used to: 为Turkey接口构造适配器，以使得它符合Duck接口这个标准 */public class TurkeyAdapter implements Duck&#123; //适配器要实现目标接口Duck Turkey turkey; //组合了一个Turkey接口的对象 public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; //这里直接调用了turkey的gobble方法，当然，你也可以做点别的 this.turkey.gobble(); &#125; @Override public void fly() &#123; this.turkey.fly(); &#125;&#125; 测试代码： 1234System.out.println(\"A turkey says:\");Turkey wildTurkey =new WildTurkey();TurkeyAdapter wildTurkeyAdapter = new TurkeyAdapter(wildTurkey);testDuck(wildTurkeyAdapter); //完成了接口转化 至此，一个应用适配器模式的demo就写完了。引入了适配器后，在既不修改WildTurkey类代码、又不修改testDuck方法的代码的基础上，我们完成了原本不兼容的工作，看上去就像实现了将一个Turkey接口的对象转化成一个Duck接口的对象。 UML图适配器模式的UML建模图如下，为了便于理解，我结合刚才的例子添加了红字标注出上例中的各个部分分别代表了什么。适配器Adpter实现了目标接口，且其类中组合了一个被适配器Adptee的对象。 p.s 我本篇博客介绍的例子是采用对象组合的方式实现适配器模式，书中还给出了另外一种实现适配器模式的思路——多重继承，简而言之就是Adapter既继承Target，又继承Adaptee，由于java语法不支持多重继承，在此不做过多介绍。 适配器模式的UML图 以上就是适配器模式的全部内容了，是不是很简单！接下来一起来看看更简单的外观模式吧。 外观模式定义外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 具体应用场景书中给出的例子是家庭影院的例子：放映电影需要执行一系列任务，这些任务涉及到了多个对象（以及它们对应的多个方法），这导致了每次需要放映电影都要写上一长串代码。 image-20200421005039865 你需要的正是一个外观：有了外观模式，通过实现一个更合理的接口的外观类，你可以将一个复杂的子系统变的容易使用。所以我们引入一个外观类HomeTheaterFacade，这个类中组合了所有与放映电影相关的对象（爆米花机、投影仪等等），它提供了一些更加友好的方法（每个方法都是一个子系统）以供调用，调用方不用知道方法内部是如何做的，以放映电影为例，调用方只需要提供需要完成放映操作的对象实例化HomeTheaterFacade，再调用它的watchMovie()方法，引入外观模式后的类图如下所示： 家庭影院外观类图 放映电影的内部方法代码和调用放映电影方法的代码见下图： 放映电影方法、调用放映电影方法的代码实现 适配器模式和外观模式总结适配器模式在不修改接口的代码的基础上，提供了将一个接口转成另一个接口的方法，以达到兼容。 外观模式定义了一个高层接口,让子系统更容易使用，接口简单对调用方更友好。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter5","date":"2020-04-18T14:19:15.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter5/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「单件模式(Singleton Pattern)」。 单件模式（也常叫单例模式）可以说是最简单的设计模式了，然而具体实现的还是有些讲究的，本文梳理了四种单例模式的实现方法 。其中前三种是书上给出的，最后一种书上没有提到，以作补充。 单例模式的基本认识 定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。 用来创建只能有一个实例的独一无二对象。 比如说线程池、缓存、对话框、处理偏好设置、注册表、日志对象、打印机等设备的驱动程序的对象。 可以确保只有一个实例会被创建，单件模式给了我们一个全局的访问点，和全局变量一样方便，又没有全局变量的缺点。 单例模式的四种实现方法一、懒汉 实现 私有的构造函数 私有的静态变量表示唯一实例，不初始化 公开的静态方法获取唯一实例 分析 优：延迟实例化(lazy instantiaze) 类加载时不会初始化，用到了才会产生(实例化) 缺：多线程可能引发创建多个实例(在不加synchronized关键字的情况下) 改进：为getInstance()方法加上synchronized关键字 引入了新的问题：降低了性能，为什么？ 因为实际上只有第一次执行此方法时，才真正需要同步，一旦设置了instance变量，就不再需要同步这个方法了。所以说，之后每次调用这个方法，同步都是一种累赘。 1234567891011121314151617/** * @used to: 懒汉实现单例模式，两私有一公开 */public class Singleton &#123; private static Singleton instance; private Singleton()&#123; &#125; public synchronized static Singleton getInstance()&#123; //如果不加synchronized关键字，多线程情况下，此处可能创建多个不同的实例对象 if (instance ==null) instance =new Singleton(); return instance; &#125;&#125; 二、饿汉饿汉单例模式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快。 实现 私有的构造函数 私有的静态变量表示唯一实例，初始化 公开的静态方法获取唯一实例 分析 与懒汉比较：饿汉在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快 优：不会有多线程导致创建了多个实例的问题 缺：即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。 1234567891011121314/** * @used to: 饿汉实现单例模式 */public class Singleton2 &#123; private static Singleton2 instance = new Singleton2(); //类加载时完成初始化 private Singleton2()&#123; &#125; public static Singleton2 getInstance()&#123; return instance; &#125;&#125; 三、双重校验锁DCL【推荐】 目标：是对懒汉中同步性能的优化，实现有更高同步性能的延迟加载。 实现 private static volatile Singleton instance 为什么要volatile？ if (instance == null) 校验1 synchronized (Singleton.class) if (instance == null) 校验2 分析 123456789101112131415161718192021/** * @used to: DCL（双重校验锁）实现单例模式 核心：volatile和两次校验 */public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3()&#123; &#125; public Singleton3 getSingleton()&#123; if (instance == null)&#123; //校验1,仅当singleton为空会进行同步。 synchronized (Singleton3.class)&#123; if(instance == null)&#123; //校验2，防止多线程中，不同线程执行到校验1，然后依次获得多个实例。 instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125;&#125; 四、静态内部类【推荐】 书上没给出这种方法，是从其他博客中学习到的。 1234567891011121314151617/** * @used to:静态内部类实现单例模式 */public class Singleton4 &#123; private static class SingletonHolder&#123; //静态内部类 private static Singleton4 instance = new Singleton4(); &#125; private Singleton4()&#123; &#125; public static Singleton4 getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 分析 它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。 不一样的是，它是在内部类里面去创建对象实例。 这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。 总结评价单例模式的四种实现方法主要从以下两个角度考虑： 是否延迟加载((lazy instantiaze)) ？ 怎么保证线程安全，在保证线程安全的情况下，性能如何 ？","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter4","date":"2020-04-18T08:38:11.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter4/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「工厂模式(Factory Pattern)」。 本读书笔记系列前几篇文章写得比较冗长，耗时也久，大半天才写出一篇博客。从这篇开始，尝试换种风格，尽量写的简洁一点，忽略一些不必要细节，先整体过一遍再来看看有无补充得必要。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter3","date":"2020-04-18T02:12:57.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter3/","text":"本篇博客是《Head First 设计模式》第三章的读书笔记。 分享主题是设计模式中的 「装饰者模式(Decorator Pattern)」。 应用背景——种类繁多的饮料的“类爆炸”背景书中给出的例子是，一家饮品店的饮品种类繁多，且客户可以自行选择在饮品内加入收费的调料（调料当然也有多种）。即使是同一种的饮品，由于加入了不同的调料，价格也会有差异，如何计算饮品的价格就成了一个问题。如下图1，书中给出的第一个尝试是列举所有饮品的可能情况来构成饮品的所有子类，如HouseBlendWithSoy(表示带调料Soy的HouseBlend饮品类)，由于饮品和调料的组合方式很多，这势必会造成”类爆炸”。 图1 但凡有点开发经验的都不会像上面这样做，我们往往都能想到通过继承解决类爆炸的常规思路，而继承解决会带来一些问题，这就需要引出本文的主角装饰者模式了，一起来看看吧。 通过继承解决具体做法是：为饮品父类中添加一些布尔类型的成员变量(如milk、soy等,都是调料名)来表示是否有该调料，和它们对应的成员方法(如hasMilk())。在父类的计算饮品价格方法 cost()中，依次判断是否加入了各调料，也就是判断该调料的变量是否为true，如果是true就在饮品的基础上加上这种调料的价格。如此一来，针对一个带特定调料的饮品对象，只需要设置它的这些成员变量的状态，使用继承自父类的cost()方法就能计算价格了。这种做法很简洁易懂，然而可拓展性不好：如果客户需要在饮品中加入双倍的某种调料，就要修改现有的代码：在饮品的父类中再加入多个成员变量(如milkNum,soyNum)来记录饮品的调料数目，同时，也会修改父类计算饮品价格的cost()方法，因为现在还要乘上调料的数量。 通过装饰者模式解决现在我们还不用着急知道什么是装饰者模式，只需要知道它的基本思路就是：用一种种调料层层“包装”饮品，然后逐级调用cost()方法来获得最终饮品的价格。 下图是用调料层层包装饮品的示例，模拟了加入了两种调料(Mocha和Whip)的DarkRoast饮品。 图2 我们姑且把调料叫做装饰者，把饮品叫做被装饰者。但是，这里有个小细节，调料既可以用来包装饮品（如图上红字标出的调料1对象包装了一个饮品对象），还可以包装其他调料（如图上红字标出的调料2包装了一个调料1对象），也就是说调料1在这里既作为最内层饮品的“装饰者”，又作为外层调料2的“被装饰者”。 为了标记每个装饰者包装的对象是谁，我们有必要在装饰者类（就是调料类）里设置个成员变量warppedObj——一个指向“被装饰者”的引用，那这个成员变量的类型应该是什么呢？这里有点绕，再次强调一下，调料2的“被装饰者”是调料1，其类型是调料，调料1的“被装饰者”是饮品，其类型是饮品，所以说这里怎么设置warppedObj的类型都不对：如果设置成饮品类，那么调料2就无法包装调料1，如果设置成调料类，那么调料1就无法包装饮品。也就是说如果要正确设定warppedObj类型以支持以上情形，就要完成调料类和饮品类的类型统一。书中的做法是让调料类继承饮品类，以达成类型的统一。 搞懂了这个，接下来的事情就好办了，如上图2，我们的目标是：计算有1份Whip、1份Mocha的DarkRoast饮品价格，做法就是先new一个Mocha对象包装DarkRoast对象记作obj1，在new一个Whip对象包装obj1。计算价格的时候调用最外层调料2对象的cost()方法，它的实现是调用其包装了的对象调料1的cost()方法获得调料1对象的价格，再加上自己的价格，而调料1的cost()实现又是调用内层饮品的cost()方法再加上自己的价格，以此类推，计算价格的过程就像上图2标出的6步流程。 如果这个饮品需要加入双倍的Whip调料，只需要再用一层Whip来包装，不用对其他代码改动。 装饰者模式装饰者模式思想在给出装饰者的定义之前，先来谈谈其“主要指导思想”，装饰者模式的指导思想是组合而非继承（在策略模式中也提到过）、开放关闭原则。 组合而非继承 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相关同的行为。然而，如果通过组合的做法扩展对象的行为，就可以在运行时动态地进行拓展。 开放关闭原则 含义：类应该对扩展开放，而对修改关闭。 解读：在不修改任何底层代码的情况下，给你的对象赋予新的职责。 这两条是书中引出装饰者模式的思想，现在理解不了没关系，先通读下文，再来回顾装饰者模式是如何遵循这两条思想的。 装饰者模式定义装饰者模式动态地将责任附加到对象上，若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。 装饰者模式UML图本案例中，使用装饰者模式后，uml图建模如下： 饮品是被装饰者（书中也叫做组件Component），可以被多种调料“包装”，它始终在最内层。 调料是装饰者，用来”包装“饮品，但是需要注意的是，调料同时也可能作为被装饰者，因为它外层可能还有别的调料来包装它。 在uml图中，我们特别需要关注的是饮品类和调料类的关系： 首先，调料子类里组合了饮品的对象。这个其实很好理解，就是记录调料这一装饰者包装了什么饮品（或者是包装了”包装了饮品“的调料）。 其次，调料的父类继承了饮品父类，也就是说调料也是饮品的子类，就像上文说的，它的目的是完成“调料类和饮品类的类型统一”。以我的理解，这里的继承的具体作用有两个:一是让调料类获得饮料类的方法，如cost()方法，二是以便于其它的调料类包装”包装了饮品的调料类“。 实际中的装饰者模式——java.iojava.io包提供的众多输入输出流相关的类，就是应用了装饰者模式。 输入流层层包装，外层流为内层流提供了新的服务。如下图，InputStream是被装饰者类父类,FilterInputStream是一个很多装饰者类的父类，其中有一个InputStream类型的名为in的成员变量。 image-20200418111628569 下面我给出了一个自定义InputStream的装饰类Demo,作用是将输入流字母变成小写。 12345678910111213141516171819202122232425/** * LowerCaseInputStream.class * @Created by hfq on 2020/4/18 * @used to: 编写自己的Java IO装饰者类,负责将输入流字母变成小写 * @return: */public class LowerCaseInputStream extends FilterInputStream &#123; /** * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt; * by assigning the argument &lt;code&gt;in&lt;/code&gt; * to the field &lt;code&gt;this.in&lt;/code&gt; so as * to remember it for later use. * * @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if * this instance is to be created without an underlying stream. */ protected LowerCaseInputStream(InputStream in) &#123; super(in); &#125; public int read() throws IOException &#123; int c = super.read(); return c==-1?c:Character.toLowerCase((char)c); &#125;&#125; 测试代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * JavaIoTest.class * @Created by hfq on 2020/4/18 * @used to: 测试代码 * @return: */public class JavaIoTest &#123; public static void main(String[] args) throws Exception &#123; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(\"designpatternlearning.iml\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"文件不存在！\"); &#125; System.out.println(\"读到的第一个字符是:\"+(char)inputStream.read()); DataInputStream dataInputStream = new DataInputStream(inputStream); //使用DataInputStream包装InputStream System.out.println(\"读到的一行字符是:\"+dataInputStream.readLine()); //使用自定义的DataInputStream包装InputStream LowerCaseInputStream lowerCaseInputStream = new LowerCaseInputStream(dataInputStream); int c = 0; System.out.println(\"剩下的字符【经过自定义IO流过滤大写字母为小写字母处理】：\"); while((c = lowerCaseInputStream.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; inputStream.close(); //长得更像装饰者模式的写法： InputStream in = new LowerCaseInputStream(new DataInputStream(new FileInputStream(\"designpatternlearning.iml\"))); while((c = in.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; in.close(); &#125;&#125; 总结 装饰者模式的UML建模图 如上图所见，装饰者模式的核心就是：装饰者既是一个(is-a)被装饰者，又有一个(has-a)被装饰者。 is-a 装饰者和被装饰者是相同的类型，这样做是为了利用继承达到“类型匹配”而不是为了利用继承“获得行为”。“类型匹配是说”一个装饰类的接口必须与被装饰类的接口保持相同。 has-a 指的是在装饰者的类中组合了一个被装饰者对象。 感悟 首先我觉得，书中这个这个例子其实并不是很好，调料类继承了饮品类，虽然知道它这样做是为了统一类型（使得装饰类既可以包装饮品，也可以包装其他的装饰类），但将调料作为饮品的子类的子类总归很别扭。 另外我觉得理解装饰者模式的核心就是理解”装饰类的接口必须与被装饰类的接口保持相同”，其根本原因是装饰者既要包装被装饰者，也要包装和它同类型的其他装饰者。 装饰者模式通过“层层包装”来装饰内层对象，为最内层的原对象锦上添花，添加新功能，扩展性好。 最后，以书中关于开放关闭原则的描述结尾： 代码应该如同晚霞中的莲花一样关闭（免于改变），如同晨曦中的莲花一样开发（能够扩展）。 这也就是引入装饰者模式的目标吧！","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"二叉搜索树学习笔记","date":"2020-04-10T05:33:29.000Z","path":"2020/04/10/二叉搜索树学习笔记/","text":"此系列是我数据结构的学习笔记，观看视频课程，网上有很详细的笔记了，所以很多地方没有再展开，着重写下自己的感悟以及记录一些细节。 本篇博客分享主题：「二叉搜索树」。 基本认识二叉搜索树(Binary Search Tree),又叫做二叉查找树、二叉排序树。 任意一个节点的值都大于其左子树所有节点的值。 任意一个节点的值都小于其右子树所有节点的值。 它的左右子树也是一颗二叉搜索树。 image-20200410222712471 为什么要引入二叉搜索树，需求是什么？ 在数组中插入元素，搜索操作平均时间复杂度O(n)，插入操作复杂度O(1) 排好序的数组，二分搜索，最坏时间复杂度O(logn),但插入、删除操作平均复杂度是O(n) 使用二叉搜索树，添加、删除、搜索的最坏事件复杂度均可优化至：O(logn) 从二叉搜索树的定义来看，涉及到比较操作，所以二叉搜索树存储的元素必须具备可比较性。 基本操作123456789101112131415161718public class BinarySearchTree&lt;E&gt;&#123; private int size; // 元素的个数 private Node&lt;E&gt; root; // 根节点 private Comparator&lt;E&gt; comparator; // 比较器 // 元素的数量 public int size() // 是否为空 public boolean isEmpty() // 清空所有元素 public void clear() // 添加元素 public void add(E element) // 删除元素 public void remove(E element) // 是否包含某元素 public boolean contains(E element) &#125; 详细实现思路点击这里。 实现接口时的注意细节 comparable和comparator？ add操作如果遇到相等的情况，为什么要覆盖？ 常用方法遍历(适用所有二叉树) image-20200411002614229 前序遍历(Preorder)，访问顺序： 根节点 -&gt; 前序遍历左子树 -&gt; 前序遍历右子树递归实现。非递归实现 ？！！！待解决 中序遍历(Inorder)，访问顺序：中序遍历左子树 -&gt; 根节点 -&gt; 中序遍历右子树 中序遍历的结果是有序的，因为根据BST的定义，左&lt;中&lt;右。 后序遍历(Postorder)，访问顺序：后序遍历左子树 -&gt; 后序遍历右子树 -&gt; 根节点 层序遍历(Level Order)，访问顺序：从上到下，从左到右依次访问节点。 引入新的问题： 我们是打印逻辑写死在遍历的方法体内，但是并不是所有遍历都是做打印操作，如何自定义对遍历的元素操作的方法？ 设计遍历接口。然后以此接口作为遍历方法的参数，在遍历方法内部调用该接口的遍历操作方法。以便动态指定遍历时对元素的操作。 再次引入新的需求: 遍历到指定条件就终止遍历。 陌生知识点Queue接口的 offer/poll。 感受比较器comparable与comparator的使用 详情 策略模式的体现！。 前中后层四种遍历。 非递归写法还没完成！！。。 为什么只给出前序和后序，不能唯一确定一个二叉树","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"cxsj项目-停车位使用情况可视化","date":"2020-04-10T00:53:18.000Z","path":"2020/04/10/cxsj项目-停车位使用情况可视化/","text":"需求分析在智慧停车管理平台(WEB端)项目中，为了清晰地展示当前停车场的车位使用情况，想到把车位的使用状态可视化地展示到室内停车场地图上。效果如下： image-20200410113840534 根据室内地图的车位图标颜色不同，用户可以看到停车场各个车位的使用状态。此外，当用户点击地图内的车位图标时，还能获取当前指定车位的状态（是否占用，如果占用，还会显示车牌号）。 实现技术前端：Jquery (ajax请求数据) 后端：SpringBoot Mybatis (数据库查询数据) 室内地图支持：Esmap （地图展示) 实现方案1. 引入Esmap的室内地图,熟悉其sdk首先，从下载室内地图的示例，以获得示例地图的数据包。我选择的是“基本地图显示”示例。 然后，在html中引入室内地图，这一步Esmap官网的开发文档有详细的流程我就不多介绍了。按照指示引入地图到html后，实现的初始效果如下： image-20200409174547260 示例默认的主题颜色比较单调，可以通过配置参数来修改主题样式（如地图背景颜色等）。 接下来，熟悉Esmap的sdk，本案例中，我们主要关注的就是：如何跟踪点击事件？(用户点击后停车位能够触发操作)，修改图标的颜色（加载车位可视化页面时根据车位的使用状态为车位图标设置不同的颜色），发现这分别对应开发文档中地图事件中的“地图点击返回事件”和常用方法中的“改变房子颜色”的changeModelColor()方法。 接下来我们就研究一下这两个方法。 方法1：地图点击返回事件12345//地图点击返回事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.htmlmap.on('mapClickNode', function(event) &#123; console.log(event); //打印事件&#125; 可以发现，当点击地图的车位图标时，打印的车位对象如下图。 image-20200410095433726 因为点击地图其他图标(比如说楼梯、道路)也会触发地图点击事件，而在本案例中我们只要关注点击车位事件，所以我们可以以地图点击返回事件event中的name属性里是否包含”车位”二字来区分被点击的图标是否为车位，如果判断是车位，才会触发后续的方法changeModelColor()来改变被点击车位的颜色。 方法2：改变房子颜色123456789//改变房子颜色(一定要在地图加载完成事件之后才有效)//id,name二选择一，都可以是数组, fnum可选择，参数color:'#FF0000'//https://www.esmap.cn/escopemap/content/cn/develope/map-fun.htmlmap.changeModelColor(&#123; //id:[1,2], name:'车位1091', //fnum:[1], color:'#FF0000'&#125;) 需要注意开发文档里指出的”一定要在地图加载完成事件之后才有效”。也就是说，changeModelColor()方法要在加载完成事件完成后调用，如下： 12345//地图加载完成事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.html map.on('loadComplete', function () &#123; map.changeModelColor()方法要在此调用！！！&#125;); 至此，我们就完成了地图页面展示，掌握了点击车位图标触发事件的方法和修改车位图标颜色的方法。 2. 创建停车位的数据表和后端api接口在我创建的车位数据表中，有这样几个主要字段： 车位标识id：由于在本案例我们使用的室内地图数据包中，所有车位对象的name属性在“车位1001~车位1102”，为了下一步地图车位对象和数据库记录的绑定，车位id的值也设置在此范围内。 车位所在停车场标识parkinglot_id：由于我的项目涉及到多个停车场，需要此字段，如果只是有一个停车场可以不用此字段。 车位状态标识in_use：若车位是空闲状态，取值0，若占用取1。 车牌号car_id：若车位占用，存车牌号，否则为空。 停车时间park_time：若车位占用，存此车进入车位的时间戳，否则为0。 创建好车位数据表之后，生成一些假数据（我是通过写了一个java类，按照给定格式随机生成记录，然后拼接字符串打印这条记录的insert语句，然后到数据库执行，后来网上了解一下，或许可以尝试使用Python的伪造数据生成器Faker），生成的部分假数据如下图展示。 image-20200410102612112 下一步，写一个Controller，完成车位查询的api接口，响应POST方法，为请求返回json数据，代码如下： 1234567891011121314151617181920212223242526/** * * @param parkinglot_id 停车场ID * @param parking_space_id 车位id * @return * 如果参数parking_space_id 为空，查找所有停车场ID为parkinglot_id的所有车位使用情况 * 如果参数parking_space_id非空，根据停车场id和车位id 查询一条记录。 */ @ResponseBody @PostMapping(\"/parkinglot/&#123;parkinglot_id&#125;/space\") private Object selectAllSpace(@PathVariable(name = \"parkinglot_id\") Integer parkinglot_id, @RequestParam(name = \"parking_space_id\",required = false) Integer parking_space_id )&#123; ParkingSpaceExample example = new ParkingSpaceExample(); if(parking_space_id!=null)&#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id) .andIdEqualTo(parking_space_id); &#125; else &#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id); &#125; List&lt;ParkingSpace&gt; parkingSpaces = parkingSpaceMapper.selectByExample(example); return parkingSpaces; &#125; 如果请求时携带了parking_space_id参数，就只查询车位id等于parking_space_id的那条车位记录，否则，查询该停车场的全部车位记录。请求参数携带车位标识和不携带车位标识这两种请求应用场景分别是：加载页面时，需要查询全部车位的车位状态，而用户点击地图的某个车位图标时，只需要查询这一个车位状态。 当不携带车位标识时，某次请求响应的部分json数据如下图展示。 image-20200410104637275 至此，我们就完成了车位数据表的建立和查询。 3. 将地图显示和数据库“绑定”这一步我们就完成可视化的任务，具体需要完成的功能有两个：功能一是加载车位详情页面的时候，查询车位数据表，根据车位状态为地图的车位图标“上色”（空位占用则红，车位空闲则为绿）；功能二是当用户点击车位图标时，查询数据库该车位的当前状态并显示出来（如果车位占用还会显示出当前的车牌号）。 有了步骤1、2的基础后，这一步就很简单了，简单地说，就是用步骤2的数据填充到步骤1的方法内。具体做法是在javascript脚本中使用ajax请求获取后端的车位数据，然后对这些数据按指定格式处理，作为调用Esmap sdk的配置参数。 以功能一的实现为例： 使用ajax向步骤2中编写好的用于查询车位的api接口发送请求，获得请求后的json数据后，遍历每条数据（对应车位数据表的一条记录），根据数据的inUse属性的取值来标识车位是占用还是空闲状态，然后拼接“车位”二字到数据的id属性的取值，就获得了这条记录对应在地图上车位图标对象的name属性（也就是说，数据库中的车位id为1001的车位记录对应地图上name=”车位1001”的地图对象)。设置js数组inUseNameList和notInUseNameList，它们分别是全部占用车位对应的地图车位图标的name属性数组、全部空闲车位对应的地图车位图标的name属性数组。调用 map.changeModelColor()方法设置地图车位图标的颜色时，指定name参数为inUseNameList，颜色设置成红色，指定name参数为notInUseNameList，颜色设置成绿色。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 完成功能一：当地图加载完成时，设置停车位的颜色 */function loadSpace() &#123; var inUseNameList = new Array(); //全部的占用车位对应的地图车位图标的name属性数组 var notInUseNameList = new Array(); //全部的空闲车位对应的地图车位图标的name属性数组 var pathname = window.location.pathname; var parkinglot_id = pathname.charAt(pathname.length-1); console.log(pathname); $.ajax(&#123; //使用ajax请求数据 method: \"POST\", url: \"/parkinglot/\"+parkinglot_id+\"/space\", &#125;) .done(function( spaceList ) &#123; // console.log(spaceList); //打印全部车位信息 $.each(spaceList,function(i,space)&#123; var spaceName = \"车位\"+space.id; if(space.inUse==1)&#123; //表示车位被使用了 inUseNameList.push(spaceName); &#125;else &#123; notInUseNameList.push(spaceName); &#125; &#125;); map.changeModelColor(&#123; //占用车位设置成绿色 name: inUseNameList, color: '#FF0000'&#125; ); map.changeModelColor(&#123; //空闲车位设置成绿色 name: notInUseNameList, color: '#00FF00'&#125; ); &#125;);&#125;","tags":[{"name":"项目","slug":"项目","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://hfq123.github.io/tags/JavaWeb/"}]},{"title":"《Head-First-设计模式》读书笔记charpter2","date":"2020-04-06T14:26:09.000Z","path":"2020/04/06/《Head-First-设计模式》读书笔记charpter2/","text":"本篇博客是《Head First 设计模式》第二章的读书笔记。 分享主题是设计模式中的 「观察者模式(Observer Pattern)」。 1、应用场景—气象监测应用书中给出的例子是：公司要建立一个气象监测应用，如下图，WeatherData对象会从气象检测站获取实时更新的气象数据（湿度、温度、气压），WeatherData对象要做的就是将这些数据及时“分发”到多个布告板，使得每个布告板能使用最新的气象数据以更新它的显示情况。除此之外，附加的需求是系统必须可扩展，能够让用户随心所欲地添加或删除布告板，也就是说，目前系统有“目前状况”、“气象统计”、“天气预报”三个布告板，以后可能会删除某个或者新增别的布告板，言外之意就是说，WeatherData对象要随时准备好停止向现有的布告板分发最新数据以及随时准备好向新的布告板分发最新数据。 image-20200406223021520 2 实现思路2.1 错误示范我们先来看一个很容易想到的思路，然而这被书中称之为“错误示范”（这也是我学习观察者模式之前的思路）。首先我们先约定：一旦气象站测量的气象数据更新，WeatherData类的measurementsChanged()方法就会被调用，在本文，我们不用关心它是怎么做的，只要知道在此方法下，我们要做的就是将这些数据及时“分发”到多个布告板类。 接下来我们就一起来看看这个简单自然但是错误的示例吧，如下图，在WeatherData类的中measurementsChanged()方法里，做的事情很简单，就是获得最新的气象数据，然后以此作为参数各个布告板类的更新方法。 image-20200406223736428 看似完全能实现我们的需求：当气象站检测到新的数据，measurementsChanged()被调用：获得最新的气象数据，然后分别调用各个不同的布告板的update()方法（在这个方法里，布告板会根据自己的需求使用最新数据来改变显示板，我们无需关注update()方法里究竟做了什么，只要知道它需要获得WeatherData类的最新气象数据，供它们更新自己的数据以改变显示屏）。 这样实现究竟有哪些错误呢？ 各个布告板类之间是独立的，没有一个共同的接口，是典型的“针对实现而非针对接口编程”的错误。 每当添加或删除新的布告板，我们都不得不修改方法体内的代码。比如说设计了一个新的testDisplay布告板，我们就要加上一行testDisplay.update(temp,humdity,pressure)，当testDisplay不再需要获取最新的气象状态，就要删除这行代码。 也正是因为每当添加或删除新的布告板，我们都不得不修改方法体内的代码，所以我们无法在运行时动态地增加或者删除布告板。 2.2 观察者模式引入观察者模式就能解决上述实现带来的问题。 先简单介绍一下什么是观察者模式，在观察者模式中，有两个主角，分别是主题(Subject)和观察者(Observer)，书上用了“出版者”和“订阅者”来类比观察者模式中的主题和观察者。出版者一旦出版新的报纸，他就要负责将新报纸分发到各个订阅者手中，而那些没有订阅报纸的人就不会收到，就和这里的例子一样，WeatherData类一旦获得新的气象数据，就要负责分发到各个布告板类中。观察者模式的概念是：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 借助下图，能够让我们清楚地看到观察者模式的“一对多依赖”。 image-20200406230651346 观察者模式为主题和观察者都创建了各自的接口。在主题接口中，定义了注册观察者(registerObserver)方法、撤销观察者(removeObserver)方法、更新所有观察者状态方法（notifyObservers,一旦主题状态改变会触发）；在观察者接口中，定义了更新观察者状态的方法(update)。 image-20200407002547510 我们再把目光转移到应用场景，前面我们已经分析了思路1实现带来的问题，接下来就要好好考虑怎么解决： 首先，我们可以考虑需要为所有布告板类创建一个观察者接口，因为在WeatherData类中，WeatherData不关心布告板是叫currentConditionDisplay还是叫statisticsDisplay，只关心它是否需要在气象数据更新时获得自己的最新气象数据，如果它实现了观察者接口并且注册了主题（相当于订报人完成了订阅动作），那么当WeatherData类的数据更新时，它就是分发数据的目标之一。 然后，我们可以在WeatherData类中维护一个所有观察者组成的列表，这样做能让WeatherData类轻松地获取所有观察者（布告板）。有了观察者列表之后，每当WeatherData类的数据更新，就遍历列表内的所有布告板，调用它们的update()方法即可，WeatherData类不用再关注有几个观察者布告板，它们叫什么名字。当需要添加或删除新的布告板的时候，只需要对列表做增删操作，而不用像思路1中那样改动measurementsChanged()方法体内的代码，同时，这也解决了不能运行时动态地增删布告板的问题，因为运行时可以动态的修改列表的元素（比如说系统运行了十分钟后将currentConditionDisplay公告板从观察者列表中移除）。 想到这些，引入观察者模式之后的模型就呼之欲出了。引入观察者模式之后，本气象站应用的的类图就如下图所示，WeatherData和各布告板分别实现主题接口和观察者接口。 image-20200407002514351 接下来我们从代码的层面上来考虑一下主题的方法是如何实现的。 registerObserver(Observer o)：将观察者对象o加入到WeatherData维护的观察者列表。 removeObserver(Observer o)：将观察者对象o从WeatherData维护的观察者列表中删除。 notifyObservers():遍历WeatherData维护的观察者列表，在循环体内调用每个观察者对象的update()方法。 对比思路1和思路2，可以发现，通过引入观察者模式，我们不仅能方便地实现布告板的增删：当有了新的布告板对象o要“监听”WeatherData的最新数据，就调用registerObserver(o)，当它不再需要获取最新气象数据，就调用removeObserver(o)，还能在运行时动态地增删布告板：，比如说为布告板对象o设置一个“监听”时间10分钟，在10分钟内，它需要监听主题的状态变化，10分钟以后，它就不需要再监听，那么就可以通过在到达10分钟的时候调用removeObserver(o)将其从观察者列表移除即可。 3、总结与思考从观察者模式的两个主角来看，主题拥有自己的一些状态(参考例子中WeatherData对象的天气数据)，而多个观察者想要获知这些状态来改变自身的状态，从而构成了一对多依赖。主题向全体观察者通知，观察者可以随时决定取消监听主题。 如果我们仔细体会本例中一下思路1到思路2的转变，会发现实现了一个松耦合的过程，在思路1中，主题需要关注观察者是谁，而引入观察者模式后，主题不需要知道观察者的具体类是谁，只知道观察者实现了某个接口，有新的观察者出现时，主题的代码不需要修改，二者并非紧耦合。改变主题或观察者其中一方，不会影响另外一方。 最后，本文以一条设计原则结尾。为了交互对象之间的松耦合设计而努力。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"20200406 算法题2则","date":"2020-04-06T14:21:31.000Z","path":"2020/04/06/20200406 算法题2则/","text":"今天在牛客网刷了两道剑指offer关于二叉树的题，都比较简单，都可用分治法的思路解决。 题1：二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 我的解答12345678910public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); int max=leftDepth&gt;rightDepth?leftDepth:rightDepth; return max+1; &#125;&#125; 解析：略 题2：二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 &#x2F; \\ 6 10 &#x2F; \\ &#x2F; \\ 5 7 9 11 镜像二叉树 8 &#x2F; \\ 10 6 &#x2F; \\ &#x2F; \\ 11 9 7 5 我的解答：1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 解析：这里需要注意必须交换左子树根节点和右子树根节点的引用而非交换取值。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"}]},{"title":"20200406 算法题2则","date":"2020-04-06T14:21:31.000Z","path":"2020/04/06/20200406算法题2则/","text":"今天在牛客网刷了两道剑指offer关于二叉树的题，都比较简单，都可用分治法的思路解决。 题1：二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 我的解答12345678910public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); int max=leftDepth&gt;rightDepth?leftDepth:rightDepth; return max+1; &#125;&#125; 解析：略 题2：二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 &#x2F; \\ 6 10 &#x2F; \\ &#x2F; \\ 5 7 9 11 镜像二叉树 8 &#x2F; \\ 10 6 &#x2F; \\ &#x2F; \\ 11 9 7 5 我的解答：1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 解析：这里需要注意必须交换左子树根节点和右子树根节点的引用而非交换取值。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://hfq123.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"《Head First 设计模式》读书笔记charpter1","date":"2020-04-05T07:10:41.000Z","path":"2020/04/05/《Head-First-设计模式》读书笔记charpter1/","text":"本篇博客是《Head First 设计模式》第一章的读书笔记。 分享主题是设计模式中的 「策略模式(Strategy Pattern)」。 1、应用场景—一群鸭子引发的故事。书中给了这样一个例子作为应用场景引入：某公司有一套模拟鸭子游戏，游戏中会出现各种各样的鸭子，这些鸭子有一些动作：呱呱叫、戏水。按照面向对象的思想，系统设计为鸭子这一对象设计了一个名为Duck的超类，在这个类中，为实现动作呱呱叫、戏水分别设置了quack()、swim()方法，而各种不同种类的鸭子通过继承这一超类获得这些描述鸭子动作的方法。 接下来问题来了，系统引入了一个新的需求：让鸭子飞起来。开发人员需要为鸭子类加入描述飞行动作的方法，书中也是以实现此需求展开来引入策略模式的。 2、解决思路—继承还是接口 ？2.1 通过继承实现首先,我们很自然地想到，可以在超类Duck中加入一个fly()方法（就像quack()、swim()方法一样），子类通过继承获取描述鸭子飞的方法。 分析： 因为所有子类都会继承超类Duck的方法，即使是一些不能飞的鸭子如橡胶鸭也会继承fly()方法，这样做我们不得不在子类橡胶鸭中重写fly()方法以覆盖继承的方法，比如说，将其子类中不会飞的鸭子的fly()方法体修改成什么都不做。同理，如果有不会叫的鸭子，又需要在该子类中重写quack()方法。 评价：这种思路是最容易想到的,主要利用了面向对象的继承、多态（体现在重写方法）特性。在代码重用上有一定效果，因为子类可以重用父类的fly()方法，但是也存在了一些缺点： (ps:这四个缺点是书中的一道多选题，只给出了答案，具体解读为自己的想法，如有不对，欢迎指正)。 代码在多个子类中重复：假设鸭子有多种飞行方式，那么我们无法仅通过继承超类的fly()方法来描述所有鸭子的飞行方式。我们必须为所有与超类中fly()实现的飞行方式不一致的鸭子子类编写fly()的覆盖方法，而具有相同的飞行方式但不同于超类中fly()给出的飞行方式的众多鸭子子类的覆盖方法将会是一样的，导致代码重复。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们需要看完Duck超类的fly()方法和全部的鸭子子类覆盖的fly()方法才能知道鸭子全部的飞行方式。 运行时的行为不容易改变：通过继承实现，每一个特定的Duck对象的飞行方式都是确定的，这是因为在它的 fly()方法是写死的，每个Duck对象的飞行方式已经在其创建的时候确定了，也就是说，鸭子不能中途切换飞行方式。 改变会牵一发而动全身，造成其他鸭子不想要的改变：这是指如果修改了超类的fly()方法，会影响到其子类。 下文可以看到，通过使用策略模式能有效解决这些问题。 2.2 通过接口实现上面的解读以fly()举例，其实其他方法也可能存在类似的问题，比如说如果不同类的鸭子叫法不同，继承的quark()方法也会存在上述问题，有的鸭子这样飞、叫，有的鸭子那样飞、叫，有的鸭子不飞不叫。这时，我们就想到了将fly()、quark()从超类中取出来放进一个接口。如下图，以fly()为例，将其放进一个名为Flyable的接口。 image文件夹 *分析 *：这样一来，如果一个鸭子子类会飞则实现Flyable接口，将其fly()方法写到子类的方法体，如果不会飞则无需实现。 评价：从超类中分离出有些子类不需要的fly()、quack()方法，这样避免了部分子类继承它压根不需要的方法的情况。然而这样做的缺点也很明显，每次编写一个会飞的新的鸭子子类，都必须在子类中单独实现fly()方法（即使有和它飞行方式一样的其他子类），导致代码根本无法重用，所以这种方法非常不可取。 2.3 策略模式如何弥补思路1、2的缺陷，这就需要引入策略模式这一设计模式，讲策略模式之前，先引入2条设计原则。 设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 在本案例中，我们假设容易变化的方法是fly()和quack()，而每个鸭子的游泳方式是一样的，即swim()方法是不需要变化的。所以设法将fly()和quack()方法从超类中抽取出来建立一组新的结构来代表每个行为，而swim()方法继续保留在Duck超类中。 设计原则2：针对接口编程，而不是针对实现编程。 我们可以利用接口代表每个行为，比如说，引入接口FlyBehavior与QuackBehavior分别代表了飞行、呱呱叫的行为，通过实现FlyBehavior接口的fly()方法，建立各种各样飞行的行为类，来描述不同飞行方式。与思路2通过接口实现的区别在于，我们不再是直接在Duck或者是它的子类中实现不同的fly()方法，而是再另外引入一个实现了FlyBehavior接口的行为类来实现fly()方法。本系统中，每个飞行的行为类都实现了FlyBehavior接口，而在Duck类中，我们定义一个FlyBehavior接口型的成员变量，来保存其对应的行为类的指针，以调用其飞行方法。 image-20200406005221237 这样做就是策略模式的思路。使用策略模式后，本系统的全局类图如下图展示， 不变的方法swim()仍然在Duck超类中实现，而经常改变的fly()、quack()方法被抽离成为接口，再用具体的行为类去实现这些接口，在Duck超类中，保存对应的行为类一个对象的指针以确定该类鸭子的对应的fly、quack行为。 image-20200406003932396 为什么说引入了策略模式会解决上述继承的四个问题呢？ 代码在多个子类中重复：如果使用继承，如果鸭子的飞行方式与超类中给定的的不一致，即使是有同样飞行方式的鸭子子类，也不能重用代码，因为它们都要在各自的类里重写fly()方法。而引入策略模式后，只需要为有同样飞行方式的鸭子子类编写一个实现了FlyBehavior的行为类。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们只需要关注实现了FlyBehavior接口的所有类的fly()方法就能知道鸭子的全部行为。 运行时的行为不容易改变：通过改变Duck或其子类对象的行为类的指针，就可以实现运行时切换飞行方式，也就是说，在Duck类中创建一个setFlyBehavior()方法，就可以随时改变鸭子的行为。 改变会牵一发而动全身，造成其他鸭子不想要的改变：如果某种鸭子的飞行方式有所改变，只需要改变其行为类的引用，不影响其他鸭子子类。 3、总结与思考 image-20200406014158325 是时候给出策略模式的概念了（像本文一样，书中在本章节的最后才给出其概念，也就是讲完了所有细节再告诉你你已经不知不觉地学会了策略模式，我个人觉得这种学习方法比较适合人认识新事物的规律，否则，如果开头就先抛出这个晦涩的概念就能把人吓跑了！）： 策略（Strategy）模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 本项目中，我们可以把鸭子飞行的方式看作是策略，描述不同鸭子飞行方式的代码就构成了策略的算法族。之所以说策略模式让使“算法的变化独立于使用算法的客户”，是因为使用策略模式可以方便地更改客户正在使用的策略（通过更改Context类中对策略的引用）。如果认为使用思路1的继承方法，不厌其烦地在子类中编写fly()的覆盖方法、多写上几行重复代码是可以接受的话，那么，能够随时方便地为类替换策略这个优点就是你无法拒绝策略模式的理由。 这里也就引出了组合和继承(有一个VS是一个)的关系：使用策略模式之后 ，在Duck的子类中通过FlyBehavior、QuickBehavior接口间接地组合了飞行、呱呱叫的行为类，这是“有一个”的关系，理解成Duck的某个子类“有一个“飞行策略。而如果使用继承，则是”是一个“的关系，Duck的子类继承了父类的fly()方法或者重写后获得了自己的fly()方法，不能做到在运行时候动态地改变行为。在使用策略模式后，策略是以”行为类“的方式存在的，而如果使用继承，策略是以方法的形式写死在类里。使用策略模式后，当类的策略在运行时需要发生改变，只需要改变”有一个“的状态，由有一个策略A变成一个策略B，只需要修改其接口的引用（就像修改任何一个普通成员变量一样）。而如果使用继承，想要修改某个鸭子的飞行方式，需要通过修改其fly()方法的代码，当然也就做不到动态地完成改变行为了。综上对组合和继承的讲述，引出了一条新的设计原则： 设计原则3：多用组合，少用继承。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"我的第一篇博客","date":"2020-04-04T13:03:27.000Z","path":"2020/04/04/我的第一篇博客/","text":"引言我正在尝试使用Hexo搭建博客,其实早就有搭建博客的想法 ,然而一直没有去实现,今天刚做完一个SpringBoot项目。闲着无事心血来潮就开始了,完工后才发现原来搭建一个自己的博客这么简单且高效，有点相见恨晚的感觉。这第一篇博客就来简单记录一下我本次搭建博客的路线，以作纪念。以后我会更多地在此分享自己的学习内容，记录开发遇到的问题。 搭建环境本次博客搭建使用到的工具有 Hexo + Github。 Hexo是一个博客框架，让我们从渲染前端页面、部署JavaWeb开发环境中解脱出来，把更多的精力放在写博客这件事情本身上，如其官网介绍： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo的灵活性体现在其大部分前端显示内容都是通过参数来配置的，包括整个博客的主题、模板都可通过配置完成（下文会讲搭建好博客后如何更换主题）。 1586022290377 Github大家都比较熟悉，这里主要用到了它的Github Pages的功能来提供远端访问的支持，不使用Github，只使用Hexo工具也能搭建博客，不过只能在本地端口访问。 搭建步骤1 、安装Hexo 2、关联Github的库 3、更换自己喜欢的博客主题 本打算重做以详细记录一下这几个步骤，但是想想这次部署之后以后也没有必要重新部署了，再加上网上已经有很很详细的教程了，重新做一次对自己提升不大，就不浪费时间，所以直接贴教程：手把手教你用Hexo+Github 搭建属于自己的博客 遇到问题特别要注意在修改配置文件_config.xml中的配置项时的格式，正确格式形如：”属性: 空格 值”，如”title: 然后就的博客”。如果冒号和值之前没有空格隔开执行hexo命令时会报错。 以上就是本篇博客的全部内容了，没什么干货，差不多是简单的流水账，仅是为了纪念第一篇博客，以后争取只写高质量的博客！！！","tags":[{"name":"工具","slug":"工具","permalink":"http://hfq123.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","date":"2020-04-04T12:24:26.585Z","path":"2020/04/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]