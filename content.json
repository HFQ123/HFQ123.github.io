[{"title":"cxsj项目-服务端主动推送数据到客户端","date":"2020-06-11T10:42:16.718Z","path":"2020/06/11/cxsj项目-服务端主动推送数据到客户端/","text":"cxsj项目-服务端主动推送数据到客户端html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:\"Lucida Console\",Consolas,\"Courier\",monospace; } html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; } body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; } iframe { margin: auto; } a.url { word-break: break-all; } a:active, a:hover { outline: 0px; } .in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); } #write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; } #write.first-line-indent p { text-indent: 2em; } #write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; } #write.first-line-indent li { margin-left: 2em; } .for-image #write { padding-left: 8px; padding-right: 8px; } body.typora-export { padding-left: 30px; padding-right: 30px; } .typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; } @media screen and (max-width: 500px) { body.typora-export { padding-left: 0px; padding-right: 0px; } #write { padding-left: 20px; padding-right: 20px; } .CodeMirror-sizer { margin-left: 0px !important; } .CodeMirror-gutters { display: none !important; } } #write li > figure:last-child { margin-bottom: 0.5rem; } #write ol, #write ul { position: relative; } img { max-width: 100%; vertical-align: middle; } button, input, select, textarea { color: inherit; font: inherit; } input[type=\"checkbox\"], input[type=\"radio\"] { line-height: normal; padding: 0px; } *, ::after, ::before { box-sizing: border-box; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; } #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; } p { line-height: inherit; } h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; } p { orphans: 4; } h1 { font-size: 2rem; } h2 { font-size: 1.8rem; } h3 { font-size: 1.6rem; } h4 { font-size: 1.4rem; } h5 { font-size: 1.2rem; } h6 { font-size: 1rem; } .md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; } .hidden { display: none; } .md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; } a { cursor: pointer; } sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; } sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; } #write input[type=\"checkbox\"] { cursor: pointer; width: inherit; height: inherit; } figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; } figure > table { margin: 0px !important; } tr { break-inside: avoid; break-after: auto; } thead { display: table-header-group; } table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; } table.md-table td { min-width: 32px; } .CodeMirror-gutters { border-right: 0px; background-color: inherit; } .CodeMirror-linenumber { user-select: none; } .CodeMirror { text-align: left; } .CodeMirror-placeholder { opacity: 0.3; } .CodeMirror pre { padding: 0px 4px; } .CodeMirror-lines { padding: 0px; } div.hr:focus { cursor: none; } #write pre { white-space: pre-wrap; } #write.fences-no-line-wrapping pre { white-space: pre; } #write pre.ty-contain-cm { white-space: normal; } .CodeMirror-gutters { margin-right: 4px; } .md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; } .md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; } #write .md-fences.mock-cm { white-space: pre-wrap; } .md-fences.md-fences-with-lineno { padding-left: 0px; } #write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; } .md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; } .CodeMirror-line, twitterwidget { break-inside: avoid; } .footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; } .footnotes + .footnotes { margin-top: 0px; } .md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; } li div { padding-top: 0px; } blockquote { margin: 1rem 0px; } li .mathjax-block, li p { margin: 0.5rem 0px; } li { margin: 0px; position: relative; } blockquote > :last-child { margin-bottom: 0px; } blockquote > :first-child, li > :first-child { margin-top: 0px; } .footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; } #write .footnote-line { white-space: pre-wrap; } @media print { body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; } #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; } .typora-export * { -webkit-print-color-adjust: exact; } html.blink-to-pdf { font-size: 13px; } .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; } .typora-export #write::after { height: 0px; } } .footnote-line { margin-top: 0.714em; font-size: 0.7em; } a img, img a { cursor: pointer; } pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; } p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; } #write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; } p > .md-image:only-child { display: inline-block; width: 100%; } #write .MathJax_Display { margin: 0.8em 0px 0px; } .md-math-block { width: 100%; } .md-math-block:not(:empty)::after { display: none; } [contenteditable=\"true\"]:active, [contenteditable=\"true\"]:focus, [contenteditable=\"false\"]:active, [contenteditable=\"false\"]:focus { outline: 0px; box-shadow: none; } .md-task-list-item { position: relative; list-style-type: none; } .task-list-item.md-task-list-item { padding-left: 0px; } .md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; } .math { font-size: 1rem; } .md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; } .md-toc-content { position: relative; margin-left: 0px; } .md-toc-content::after, .md-toc::after { display: none; } .md-toc-item { display: block; color: rgb(65, 131, 196); } .md-toc-item a { text-decoration: none; } .md-toc-inner:hover { text-decoration: underline; } .md-toc-inner { display: inline-block; cursor: pointer; } .md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; } .md-toc-h2 .md-toc-inner { margin-left: 2em; } .md-toc-h3 .md-toc-inner { margin-left: 4em; } .md-toc-h4 .md-toc-inner { margin-left: 6em; } .md-toc-h5 .md-toc-inner { margin-left: 8em; } .md-toc-h6 .md-toc-inner { margin-left: 10em; } @media screen and (max-width: 48em) { .md-toc-h3 .md-toc-inner { margin-left: 3.5em; } .md-toc-h4 .md-toc-inner { margin-left: 5em; } .md-toc-h5 .md-toc-inner { margin-left: 6.5em; } .md-toc-h6 .md-toc-inner { margin-left: 8em; } } a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; } .footnote-line a:not(.reversefootnote) { color: inherit; } .md-attr { display: none; } .md-fn-count::after { content: \".\"; } code, pre, samp, tt { font-family: var(--monospace); } kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; } .md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); } code { text-align: left; vertical-align: initial; } a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; } .md-inline-math .MathJax_SVG .noError { display: none !important; } .html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; } .md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; } .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; } .MathJax_SVG .MJX-monospace { font-family: var(--monospace); } .MathJax_SVG .MJX-sans-serif { font-family: sans-serif; } .MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; } .MathJax_SVG * { transition: none 0s ease 0s; } .MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; } .os-windows.monocolor-emoji .md-emoji { font-family: \"Segoe UI Symbol\", sans-serif; } .md-diagram-panel > svg { max-width: 100%; } [lang=\"flow\"] svg, [lang=\"mermaid\"] svg { max-width: 100%; height: auto; } [lang=\"mermaid\"] .node text { font-size: 1rem; } table tr th { border-bottom: 0px; } video { max-width: 100%; display: block; margin: 0px auto; } iframe { max-width: 100%; width: 100%; border: none; } .highlight td, .highlight tr { border: 0px; } svg[id^=\"mermaidChart\"] { line-height: 1em; } mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); } .md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; } mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; } .CodeMirror { height: auto; } .CodeMirror.cm-s-inner { background: inherit; } .CodeMirror-scroll { overflow: auto hidden; z-index: 3; } .CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); } .CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; } .CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); } .cm-s-inner .cm-keyword { color: rgb(119, 0, 136); } .cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); } .cm-s-inner .cm-number { color: rgb(17, 102, 68); } .cm-s-inner .cm-def { color: rgb(0, 0, 255); } .cm-s-inner .cm-variable { color: rgb(0, 0, 0); } .cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); } .cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); } .cm-s-inner .cm-string { color: rgb(170, 17, 17); } .cm-s-inner .cm-property { color: rgb(0, 0, 0); } .cm-s-inner .cm-operator { color: rgb(152, 26, 26); } .cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); } .cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); } .cm-s-inner .cm-meta { color: rgb(85, 85, 85); } .cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); } .cm-s-inner .cm-builtin { color: rgb(51, 0, 170); } .cm-s-inner .cm-bracket { color: rgb(153, 153, 119); } .cm-s-inner .cm-tag { color: rgb(17, 119, 0); } .cm-s-inner .cm-attribute { color: rgb(0, 0, 204); } .cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); } .cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); } .cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); } .cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); } .cm-negative { color: rgb(221, 68, 68); } .cm-positive { color: rgb(34, 153, 34); } .cm-header, .cm-strong { font-weight: 700; } .cm-del { text-decoration: line-through; } .cm-em { font-style: italic; } .cm-link { text-decoration: underline; } .cm-error { color: red; } .cm-invalidchar { color: red; } .cm-constant { color: rgb(38, 139, 210); } .cm-defined { color: rgb(181, 137, 0); } div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); } div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); } .cm-s-inner .CodeMirror-activeline-background { background: inherit; } .CodeMirror { position: relative; overflow: hidden; } .CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; } .CodeMirror-sizer { position: relative; } .CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; } .CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; } .CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; } .CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; } .CodeMirror-gutter-filler { left: 0px; bottom: 0px; } .CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; } .CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; } .CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; } .CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; } .CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; } .CodeMirror-lines { cursor: text; } .CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; } .CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; } .CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; } .CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; } .CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; } .CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; } .CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; } .CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; } .CodeMirror-measure pre { position: static; } .CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; } .CodeMirror div.CodeMirror-cursor { visibility: hidden; } .CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; } .cm-searching { background: rgba(255, 255, 0, 0.4); } @media print { .CodeMirror div.CodeMirror-cursor { visibility: hidden; } } :root { --side-bar-bg-color: #fafafa; --control-text-color: #777; } @include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext); html { font-size: 16px; } body { font-family: \"Open Sans\",\"Clear Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif; color: rgb(51, 51, 51); line-height: 1.6; } #write { max-width: 860px; margin: 0 auto; padding: 30px; padding-bottom: 100px; } @media only screen and (min-width: 1400px) { #write { max-width: 1024px; } } @media only screen and (min-width: 1800px) { #write { max-width: 1200px; } } #write > ul:first-child, #write > ol:first-child{ margin-top: 30px; } a { color: #4183C4; } h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; } h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; } h1 tt, h1 code { font-size: inherit; } h2 tt, h2 code { font-size: inherit; } h3 tt, h3 code { font-size: inherit; } h4 tt, h4 code { font-size: inherit; } h5 tt, h5 code { font-size: inherit; } h6 tt, h6 code { font-size: inherit; } h1 { padding-bottom: .3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } h2 { padding-bottom: .3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } h3 { font-size: 1.5em; line-height: 1.43; } h4 { font-size: 1.25em; } h5 { font-size: 1em; } h6 { font-size: 1em; color: #777; } p, blockquote, ul, ol, dl, table{ margin: 0.8em 0; } li>ol, li>ul { margin: 0 0; } hr { height: 2px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; overflow: hidden; box-sizing: content-box; } li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } blockquote { border-left: 4px solid #dfe2e5; padding: 0 15px; color: #777777; } blockquote blockquote { padding-right: 0; } table { padding: 0; word-break: initial; } table tr { border-top: 1px solid #dfe2e5; margin: 0; padding: 0; } table tr:nth-child(2n), thead { background-color: #f8f8f8; } table tr th { font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; margin: 0; padding: 6px 13px; } table tr td { border: 1px solid #dfe2e5; margin: 0; padding: 6px 13px; } table tr th:first-child, table tr td:first-child { margin-top: 0; } table tr th:last-child, table tr td:last-child { margin-bottom: 0; } .CodeMirror-lines { padding-left: 4px; } .code-tooltip { box-shadow: 0 1px 1px 0 rgba(0,28,36,.3); border-top: 1px solid #eef2f2; } .md-fences, code, tt { border: 1px solid #e7eaed; background-color: #f8f8f8; border-radius: 3px; padding: 0; padding: 2px 4px 0px 4px; font-size: 0.9em; } code { background-color: #f3f4f4; padding: 0 2px 0 2px; } .md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; } .md-task-list-item > input { margin-left: -1.3em; } @media print { html { font-size: 13px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } .md-fences { background-color: #f8f8f8; } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border: 0; border-radius: 3px; color: #777777; margin-top: 0 !important; } .mathjax-block>.code-tooltip { bottom: .375rem; } .md-mathjax-midline { background: #fafafa; } #write>h3.md-focus:before{ left: -1.5625rem; top: .375rem; } #write>h4.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h5.md-focus:before{ left: -1.5625rem; top: .285714286rem; } #write>h6.md-focus:before{ left: -1.5625rem; top: .285714286rem; } .md-image>.md-meta { /*border: 1px solid #ddd;*/ border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; } .md-tag { color: #a7a7a7; opacity: 1; } .md-toc { margin-top:20px; padding-bottom:20px; } .sidebar-tabs { border-bottom: none; } #typora-quick-open { border: 1px solid #ddd; background-color: #f8f8f8; } #typora-quick-open-item { background-color: #FAFAFA; border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee; border-style: solid; border-width: 1px; } /** focus mode */ .on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); } header, .context-menu, .megamenu-content, footer{ font-family: \"Segoe UI\", \"Arial\", sans-serif; } .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state{ visibility: visible; } .mac-seamless-mode #typora-sidebar { background-color: #fafafa; background-color: var(--side-bar-bg-color); } .md-lang { color: #b4654d; } .html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; } #md-notification .btn { border: 0; } .dropdown-menu .divider { border-color: #e5e5e5; } .ty-preferences .window-content { background-color: #fafafa; } .ty-preferences .nav-group-item.active { color: white; background: #999; } 需求分析在智慧停车管理平台(WEB端)项目的公告发布模块中，管理员发布公告后，车主用户可以评论公告（这可以作为用户提问的一种途径），为了让管理员及时看到用户对公告的评论，以便及时回复，需增加一个通知提醒功能，就和大多数WEB应用一样，页面顶部有一个通知图标，如果有通知，就高亮显示起到提醒的作用。目标实现效果当没有任何通知的时候（在我这个案例中，也就是没有用户回复公告的提醒），显示通知图标。 当有通知时，高亮显示未读通知的数目，当用户点击页面顶部“通知”按钮的时候，根据时间降序显示出所有通知，并且重点标注出哪些通知是未读的。&nbsp;实现思路基本思路接下来介绍一下本案例中是怎么实现通知回复功能的。当用户进行评论公告操作后，先将用户的评论插入到数据库的评论表中，如果插入成功，生成一条对应的通知记录，在数据库设计时，通知表(notification)包含了如下字段：字段名作用id通知表的主键notifier通知发起者id，外键，关联用户表receiver通知接收者id，外键，关联用户表outerId公告id，外键，关联公告表，表示notifier在编号为outId的公告下回复了receivergmt_create通知创建的时间戳，bigint类型status通知的阅读状态（对于接收者而言），0标识未读，1标识已读结合具体场景对数据表各个字段的解读：用户A成功回复了管理员发布的公告，则生成一条通知记录，其中，notifier字段存用户A的id，recevier字段存管理员的id，outId存被回复的公告的id，gmt_create保存系统当前的时间戳，以记录通知生成的时间，status初始化为0表示通知接收者还未读。持久化通知记录到数据库之后，我们就可以获得每个用户的未读通知数目和全部历史通知数据：​x#查询某用户未读通知的数目select count(1) from notification where receiver = 用户ID and status = 0​#查询某用户的全部通知select * from notification where receiver = 用户ID至此就很明朗了：加载WEB页面时，先查询当前用户的未读通知的数目，如果是0，则显示通知图标，如果大于0，则高亮显示未读通知的数目。这个流程可以通过ajax调用后端查询接口实现，代码就不展开了。现在问题来了，这样做的缺点是什么？1、实时性差，每次需要手动刷新当前页面或者点击别的页面，重新加载后，才会获得当前实时的未读通知数目。2、效率不高，每进入一个新的页面，都会查询当前的未读通知数目，即使距离上一次查询的一段时间内，未读通知数并没有更新，也会查询。&nbsp;改进思路针对上述这两个问题，有一些改进思路：”假装实时“的客户端轮询机制首先，为了解决实时性差的问题，我们可以想到：客户端每隔一小段时间，就使用ajax调用查询接口，获取当前用户未读通知的数目，获取结果后局部刷新到顶部栏通知框内。这样做一定程度上实现了”实时“通知：比如说，每隔2秒，客户端就发起一次查询当前通知未读数的请求，服务器返回结果，如果不考虑网络等因素的延时，网页顶部的通知状态栏中的数字始终是2s内的未读通知数，对于普通WEB应用来说，这样的实时性是可以接受的。轮询机制的代码实现（每隔2000ms调用一次查询方法并更新）：xxxxxxxxxxsetInterval(function(){ &nbsp; &nbsp;此处写ajax查询的代码},2000) &nbsp;接下来，我们来分析一下这种机制的性能：轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。 这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。注:此段描述摘自于此博客。 总的来说，轮询机制似乎确实在一定程度上能解决实时性的问题，但是效率很差。由于轮询有一定的时间差，所以我在标题上说是”假装实时“。真正实时的WebSocket概念之所以轮询机制的效率低，是因为，客户端无法得知后台数据什么时候发生了更新，所以每次发送请求时只能”抱着试一试“的态度，请求当前后台某个数据的值，以尽可能获取最近一段时间内的该数据的最新值，概括地说，和普通客户端请求一样，轮询机制是由客户端发起请求。而理想的模型是在服务器端数据有了变化后，可以主动推送给客户端,这种&quot;主动型&quot;服务器是解决这类问题的很好的方案。Web Socket就是这样的方案。WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。注:此段描述摘自于菜鸟教程。 简而言之，WebSocket 拓展了客户端获取后台数据的方式，普通情况下，只能由客户端主动拉取(pull)，而用了WebSocket之后，可以通过服务器主动推送（push），客户端被动获取数据。讲到这里，终于呼应上本文的标题了。由于我还没系统学过java的网络编程，之前也没接触过WebSocket，于是采用了号称“让websocket更简单”的解决方案——GoEasy API，结果证明，使用起来确实极其简单。理解GoEasy的工作原理很简单，浏览器订阅channel，服务端后客户端都可以向channel发布消息，消息被发布 到channel后，所有订阅了该channel的客户端都可以获得channel里的消息。图源自GoEasy的工作原理。使用这里就简单地介绍一下GoEasy的使用过程吧。1、注册并登录GoEasy账号后，首先注册一个应用，选免费版即可。2、后端推送数据到channel首先，在maven项目的pom.xml中添加如下依赖:xxxxxxxxxx &nbsp; &nbsp;&lt;dependencies&gt; &nbsp; &nbsp; &nbsp; ........... &nbsp; &nbsp; &nbsp; &nbsp;&lt;!-- GoEasy的依赖 --&gt; &lt;dependency&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;groupId&gt;io.goeasy&lt;/groupId&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;artifactId&gt;goeasy-sdk&lt;/artifactId&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;version&gt;0.3.8&lt;/version&gt; &nbsp; &nbsp; &nbsp; &nbsp;&lt;/dependency&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;!-- 这是gson的依赖，一开始没有加，报错ClassNotFound了 --&gt; &nbsp; &nbsp; &nbsp; &nbsp;&lt;dependency&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;artifactId&gt;gson&lt;/artifactId&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;version&gt;2.8.5&lt;/version&gt; &nbsp; &nbsp; &nbsp; &nbsp;&lt;/dependency&gt; &nbsp; &nbsp;&lt;/dependencies&gt;xxxxxxxxxxGoEasy goEasy = new GoEasy( \"这里填写第一步注册应用完成后获取到的Common key\");goEasy.publish(\"my_channel\", String.valueOf(replyNum)); //replyNum是我项目中生成新通知后，更新后的\"通知未读数目\"3、前端从channel中获得消息首先，下载js文件，引入到thymeleaf的html模板中。编写获取channel中数据的前端代码：xxxxxxxxxx/** * 订阅channel，获取最新的未读通知数目 */function subscribleReplyNum() { &nbsp; &nbsp;var goEasy = new GoEasy({ &nbsp; &nbsp; &nbsp; &nbsp;host:'hangzhou.goeasy.io', //应用所在的区域地址: 【hangzhou.goeasy.io |singapore.goeasy.io】 &nbsp; &nbsp; &nbsp; &nbsp;appkey: 这里依旧填写第一步注册应用完成后获取到的Common key &nbsp; }); &nbsp; &nbsp;goEasy.subscribe({ &nbsp; &nbsp; &nbsp; &nbsp;channel: \"my_channel\", //“my_channel”对应于发布时的channel名 &nbsp; &nbsp; &nbsp; &nbsp;onMessage: function (message) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(\"Channel:\" + message.channel + \" content:\" + message.content); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$(\"#not_read_count\").text(message.content); //更新“通知状态栏”的未读通知数目的span的值 &nbsp; &nbsp; &nbsp; } &nbsp; });​}至此，就可以正常使用了，完成如下效果：","tags":[]},{"title":"6月每日更新-算法题","date":"2020-06-01T15:01:23.000Z","path":"2020/06/01/6月每日更新-算法题/","text":"20200616 多云题1 最大正方形 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 暴力解法： 先写一个辅助函数max(char[][] matrix,int x,int y)用来计算以(x,y)为左上角顶点的正方形的面积，然后遍历每个点，计算以它们为左上角顶点的最大正方形面积值，这个过程中记录下最大面积值，作为返回结果。 时间复杂度O(mnmin(m,n)^2) 代码: 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int maximalSquare(char[][] matrix) &#123; int max = 0; for(int i = 0;i&lt;matrix.length;i++)&#123; for(int j = 0;j&lt;matrix[0].length;j++)&#123; max = Math.max(max(matrix,i,j),max); &#125; &#125; return max; &#125; //以[x,y]为左顶点的最大正方形面积。 public int max(char[][] matrix,int x,int y)&#123; int res = 0; int copyx = x,copyy = y; boolean flag = true; while(x&lt;matrix.length &amp;&amp;y&lt;matrix[0].length &amp;&amp; matrix[x][y]=='1')&#123; for(int i = 0; i&lt;res+1; i++)&#123; if(i+copyy &gt;=matrix[0].length || matrix[x][i+copyy]!='1')&#123; flag = false; break; &#125; &#125; for(int i = 0; i&lt;res+1; i++)&#123; if(copyx+i &gt;=matrix.length || matrix[copyx+i][y]!='1')&#123; flag = false; break; &#125; &#125; if(!flag) break; res+=1; //边长加1 x++; y++; &#125; return res*res; &#125;&#125; 解法2：动态规划 以当前点为正方形的最右下角的点，其最大边长由左边点、上方点、左上方点三者中的最小值+1。 时空复杂度：O(m*n) 1234567891011121314151617181920class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return 0; &#125; int maxSide = 0; int dp[][] = new int[matrix.length][matrix[0].length]; for(int i = 0;i&lt;matrix.length;i++)&#123; for(int j = 0;j&lt;matrix[0].length;j++)&#123; if(i==0 || j==0)&#123; dp[i][j] = matrix[i][j]-'0'; &#125;else if(matrix[i][j]=='1')&#123; dp[i][j] = Math.min(Math.min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1; &#125; maxSide = Math.max(maxSide,dp[i][j]); &#125; &#125; return maxSide*maxSide; &#125; &#125; 题外话，不知怎的，暴力法的数据还好看些，执行用时还超过了80%的用户。 执行用时 :6 ms, 在所有 Java 提交中击败了82.22%的用户 内存消耗 :43.5 MB, 在所有 Java 提交中击败了12.50%的用户 题2 【待学习】 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 基本思路：下面这种做法可以认为是暴力解法： 如果要找的两个结点都存在于当前结点的左（右）子树，说明公共祖先必定在左（右）子树，否则，共同祖先就是当前结点。 123456789101112131415161718class Solution &#123; //公共祖先不可能为null public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(exists(root.left,p) &amp;&amp; exists(root.left,q) )&#123; //p和q都在左子树或者都在右子树 return lowestCommonAncestor(root.left,p,q); &#125;else if(exists(root.right,p) &amp;&amp; exists(root.right,q))&#123; return lowestCommonAncestor(root.right,p,q); &#125;else&#123; return root; &#125; &#125; //返回node结点是否在以root为根结点的树中 public boolean exists(TreeNode root,TreeNode node)&#123; if(root==null) return false; return root.val == node.val || exists(root.left,node) || exists(root.right,node); &#125;&#125; 改进思路：后序遍历 （1） 如果当前结点 rootroot 等于 NULL，则直接返回 NULL（2） 如果 rootroot 等于 pp 或者 qq ，那这棵树一定返回 pp 或者 qq（3） 然后递归左右子树，因为是递归，使用函数后可认为左右子树已经算出结果，用 leftleft 和 rightright 表示（4） 此时若leftleft为空，那最终结果只要看 rightright；若 rightright 为空，那最终结果只要看 leftleft（5） 如果 leftleft 和 rightright 都非空，因为只给了 pp 和 qq 两个结点，都非空，说明一边一个，因此 rootroot 是他们的最近公共祖先（6） 如果 leftleft 和 rightright 都为空，则返回空（其实已经包含在前面的情况中了） 时间复杂度是 O(n)O(n)：每个结点最多遍历一次或用主定理，空间复杂度是 O(n)O(n)：需要系统栈空间 作者：Wilson79链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/c-jing-dian-di-gui-si-lu-fei-chang-hao-li-jie-shi-/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 123456789101112131415161718192021class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL) return NULL; if(root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left == NULL) return right; if(right == NULL) return left; if(left &amp;&amp; right) // p和q在两侧 return root; return NULL; // 必须有返回值 &#125;&#125;; 20200615 晴坚持每日刷题已经:33天。 题1 最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 果然题目做多了就有感觉了。 这题是为数不多的中等难度的题，自行想出来高效解法。思路很顺畅，且提交后按照一个测试用例改了就对了： 执行用时 :7 ms, 在所有 Java 提交中击败了84.21%的用户 内存消耗 :40 MB, 在所有 Java 提交中击败了100.00%的用户 时间复杂度：O(n)，空间复杂度O(1)（因为字符数量是有限的128，O(128)） left和right分别表示不含重复字符子串的首个、最后一个字符的下标。 12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; HashMap &lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int left = 0,right=0,max = 0; for(int i = 0;i&lt;s.length(); i++)&#123; //注意第二个条件必不可少！要忽略所有在小于left的重复，不然\"abba\"这样的测试用例就无法通过了 if(map.containsKey(s.charAt(i)) &amp;&amp; map.get(s.charAt(i))&gt;=left)&#123; left = map.get(s.charAt(i)) + 1; //如果该元素的加入造成重复，更新左界 &#125; map.put(s.charAt(i),i); max = Math.max(max,right-left+1); right++; &#125; return max; &#125;&#125; 题2 合并区间 给出一个区间的集合，请合并所有重叠的区间。 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 基本思路： 先想明白什么情况需要合并：两个区间[x1,y1]和[x2,y2]，如果x2&lt;=y1，则需要合并，合并结果是[x1,max(y1,y2)]，注意不要错误地认为合并结果是[x1,y2]，比如说[1,4],[2,3]的合并结果将会是[1,4]。 先对各区间升序排列，然后依次合并。 对二维数组的排序、list转二维数组的操作参考了昨天做的**根据身高重排队列那题，现学现用。 时间复杂度和空间复杂度分析： O(nlogn) O(n) 1234567891011121314151617class Solution &#123; public int[][] merge(int[][] intervals) &#123; if(intervals==null || intervals.length==0) return new int[0][0]; Arrays.sort(intervals,(o1,o2)-&gt;(o1[0]!=o2[0]?o1[0]-o2[0]:o1[1]-o2[1])); List&lt;int []&gt; res = new ArrayList&lt;int []&gt;(); res.add(intervals[0]); //先加入第一个区间 for(int i=1;i&lt;intervals.length;i++)&#123; int [] lastInterval = res.get(res.size()-1); //上一个区间。 if(lastInterval[1] &gt;= intervals[i][0])&#123; //上一区间的右界大于这个区间的左界，则更新上一个区间的右界 lastInterval[1] = Math.max(intervals[i][1],lastInterval[1]); &#125;else&#123; res.add(intervals[i]); //否则，这两个区间无重复部分，加入第二个区间 &#125; &#125; return res.toArray(new int[res.size()][2]); &#125;&#125; 题3 【明天再做！】LRU缓存机制 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 注意：每次put或者get之后都要更新最久未使用的数据值。 思路1：可以直接用LinkedHashMap提供的现成API完成需要的功能，LinkedHashMap的构造方法有一个布尔类型的可选参数accessOrder，来规定是采用插入顺序还是保持顺序。 从其源码构造方法中可以看出，默认都采用插入顺序来维持取出键值对的次序。所有构造方法都是通过调用父类的构造方法来创建对象的。参考：https://www.cnblogs.com/xiaoxi/p/6170590.html 不过这样实现一来没有自己的思考，显然不是考察点，二来这API平时确实没接触过，也不常用，所以此思路知道即可。 思路2：哈希表+双向链表（直接在哈希表的结点）。 20200614 晴天坚持每日刷3题已经：32天。 题1 【待完善】 回文链表 请判断一个链表是否为回文链表。 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 常规解法很简单：用到了栈保存链表的逆序状态，所以说空间复杂度是O(n)。 12345678910111213141516171819 //空间复杂度O(n)，时间复杂度O(n)class Solution &#123; public boolean isPalindrome(ListNode head) &#123; Stack &lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode cur = head; while(cur!=null)&#123; stack.push(cur.val); cur = cur.next; &#125; cur = head; while(cur!=null)&#123; if(cur.val != stack.pop())&#123; return false; &#125; cur = cur.next; &#125; return true; &#125;&#125; 进阶解法其实和原地反转链表的思路是一样的，不过这里不需要反转整个链表，只需要反转后半部分链表然后与前半部分链表进行比较。待解决。 题2 合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 基本思路:两两合并，list[0]不断“滚雪球”，和其他k-1个链表合并，合并后，把其他链表吸收到list[0]。 1234567891011121314151617181920212223242526272829class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists==null || lists.length==0) return null; for(int i = 1; i &lt; lists.length; i++)&#123; //两两合并 lists[0] =mergeTwoList(lists[0],lists[i]); &#125; return lists[0]; &#125; //原地合并两个排序链表h1,h2，时间复杂度O(m+n),m+n分别为两个链表的长度 public ListNode mergeTwoList(ListNode h1,ListNode h2)&#123; ListNode dummy = new ListNode(0),tail = dummy; int h1Value,h2Value; while(h1!=null || h2!=null)&#123; h1Value = h1==null?Integer.MAX_VALUE:h1.val; h2Value = h2==null?Integer.MAX_VALUE:h2.val; if(h1Value&lt;=h2Value)&#123; tail.next = h1; tail = tail.next; h1 = h1.next; &#125;else&#123; tail.next = h2; tail = tail.next; h2 = h2.next; &#125; &#125; return dummy.next; &#125;&#125; 对合并两个链表的函数代码稍加改进： 123456789101112131415161718//合并两个排序链表h1,h2public ListNode mergeTwoList(ListNode h1,ListNode h2)&#123; ListNode dummy = new ListNode(0),tail = dummy; int h1Value,h2Value; while(h1!=null &amp;&amp; h2!=null)&#123; if(h1.val&lt;=h2.val)&#123; tail.next = h1; tail = tail.next; h1 = h1.next; &#125;else&#123; tail.next = h2; tail = tail.next; h2 = h2.next; &#125; &#125; tail.next = h1==null?h2:h1; return dummy.next;&#125; 空间复杂度：O(n) ，时间复杂度不太好分析： 可以参考下图（截自LeetCode官方题解）。 此题的时间复杂度分析 思路2：优先级队列（最小堆） 注意，不需要把所有结点一次性加入到优先级队列，只需要加入每个非空链表的首结点即可。 时间复杂度O(n*logk) ,这里的n是结点的总个数，因为此优先级队列最大大小为k，所以说插入1个元素的时间复杂度是logk。 1234567891011121314151617181920212223class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists==null || lists.length==0) return null; ListNode dummy = new ListNode(0),tail = dummy,tmp; //优先级队列,最小堆，这个堆的大小初始化为k即可 PriorityQueue &lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(lists.length,(node1,node2)-&gt;node1.val-node2.val); for(int i=0;i&lt;lists.length;i++)&#123; if(lists[i]!=null)&#123; //如果不加这个判断，通过不过[[]]这个测试用例（也就是说通不过有空的） queue.offer(lists[i]); //优先级队列插入元素的时间复杂度是O(logk)，k &#125; &#125; while(!queue.isEmpty())&#123; tmp = queue.poll(); if(tmp.next!=null)&#123; queue.offer(tmp.next); &#125; tail.next = tmp; tail = tail.next; &#125; return dummy.next; &#125; &#125; 题3 【待熟练】 根据身高重建队列 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解此题的关键是理解：如果高的人已经排好了，随着矮的人的加入，一定不会影响高的人的相对顺序。 如三个高的人排列好了：如[7,0],[7,1],[7,2]，这时候再来了一个[6,1]，则把它插入到[7,0]的后面，队列变成了：[7,0],[6,1],[7,1]，[7,2] ，可以看到[6,1]的加入对于原来高度为7的人的相对位置不会产生任何影响（性质①），而且[6,1]插入的位置就是原队列索引为1的地方。（性质②） 所以可以用贪心的方法去做，先将队列从高到矮排列（如果高度也就是h相同的情况，按照k升序）： [7,0],[7,1],[6,1],[5,0],[5,2],[4,4]。 然后一个个处理: 插入第一个：[7,0] 插入第二个：[7,0],[7,1] 插入第三个：[7,0],[6,1],[7,1], 插入第四个：[5,0],[7,0],[6,1],[7,1], 插入第五个：[5,0],[7,0],[5,2],[6,1],[7,1] 插入第六个：[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]。 基于此思路， 代码如下： 123456789101112class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; if(people == null || people.length == 0) return new int[0][0]; //按照h降序，如果h相同，按照k升序 Arrays.sort(people,(o1,o2)-&gt;(o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0])); //妙用lambda表达式。o1,o2都是int类型的数组 List &lt;int[]&gt; res = new LinkedList&lt;int[]&gt;(); for(int i=0;i&lt;people.length;i++)&#123; res.add(people[i][1],people[i]); //利用了上面分析的性质② &#125; return res.toArray(new int[res.size()][2]); &#125;&#125; 这份代码是参考了题解，有很高的技巧性： 对二维数组排序，[h,k]，按h降序，如果h相同的情况下，按k升序。这里巧妙地利用了lambda表达式指定了比较器。 最后把链表转成数组，res.toArray，尤其注意其参数，如果不写参数，会报错：Object[] cannot be converted to int[],[]。 时间、空间复杂度分析： image-20200614234205912 20200613 晴天坚持每日刷3题已经：31天。 今天刷的题的tag都是DP。 题1 【待改进】完全平方数 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例 2: 输入: n = 13输出: 2解释: 13 = 4 + 9. 略暴力的解决。记f(i)为求组成和为i所需要的完全平方数的最少个数的值，比如说求f(15)，其求解过程是这样的： f(15) = min{f(14) + f(1), f(13) + f(2)，f(12)+f(2)……..f(8)+f(7)} 这道题和找零钱那题比较像，不能直接想当然地认为贪心地找最大的钱，对应到这题，不是找离自己最近的完全平方数，比如说n=12时，发现比12小的最大的完全平方数是9（f(9)=1），如果这时候选择了9，还需要选择3个1，共四个完全平方数。 12345678910111213141516171819202122232425262728//待提升//时间复杂度O(n^2)，空间复杂度O(n)class Solution &#123; public int numSquares(int n) &#123; int s = (int)Math.sqrt(n); // if(s*s == n)&#123; return 1; &#125; //dp[i]表示组成和为i的完全平方数的最少个数 int [] dp = new int [n+1]; //组成和为1的完全平方数的最少个数是1 for(int i = 1; i &lt;= n; i++)&#123; int sqrt = (int)Math.sqrt(i); if(sqrt*sqrt == i)&#123; dp[i] = 1; continue; &#125; int tmpMin = Integer.MAX_VALUE; for(int j = 1;j &lt; i; j++)&#123; if(j&gt;i-j) continue; tmpMin = Math.min(tmpMin,dp[j]+dp[i-j]); &#125; dp[i] = tmpMin; &#125; return dp[n]; &#125;&#125; 题2 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 tag:动态规划。 主要思路。 image-20200613200236645 偷不偷现在这个，这是个问题。 123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; if(nums==null || nums.length==0)return 0; int [] yes =new int [nums.length]; //偷当前房屋的最大值 int [] no = new int [nums.length]; //不偷当前房屋的最大值 yes[0] = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; //偷当前房屋,肯定不能偷上一个房屋 yes[i] = no[i-1] + nums[i]; //不偷当前房屋，既可以偷上一个房屋，又可以不偷上一个房屋 no[i] = Math.max(yes[i-1],no[i-1]); &#125; return Math.max(yes[nums.length-1],no[nums.length-1]); &#125;&#125; 时间复杂度和空间复杂度都是O(n)，提交后发现时间复杂度超过100%，空间复杂度超过7%，仔细观察会发现，这题和求斐波那契数列的第n个数一样，无需用数组来保存中间状态，只要用临时变量就可以，这样做空间复杂度就是O(1)，其优化原理就是 滚动数组。 改进后，空间复杂度是O(1) 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; if(nums==null || nums.length==0)return 0; int yes = 0; //偷当前房屋 int no = 0; //不偷当前房屋 int oldYes,oldNo; for(int i=0;i&lt;nums.length;i++)&#123; //偷当前房屋,肯定不能偷上一个房屋 oldYes = yes; oldNo = no; yes = oldNo + nums[i]; no = Math.max(oldYes,oldNo); &#125; return Math.max(yes,no); &#125;&#125; 题3 【值得体会】 买卖股票的最佳时机 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 暴力法：时间复杂度O(n^2)，空间复杂度O(1) 基本思路：先确定价格数组的 i 指针表示购入时间，j指针表示可能的售出时间（j&gt;i)，j每次都选择i 后面所有最大的值。 我这里是把今天作为购入时间点来考虑。 每日价格 7 1 5 3 6 4 今天起最大的价格 7 6 6 6 6 4 差价 0 5 1 3 -2 0 12345678910111213class Solution &#123; public int maxProfit(int[] prices) &#123; int ans = 0; for(int i=0; i&lt;prices.length; i++)&#123; //当前时间购入，prices[i]就是购入价 int max = prices[i]; for(int j = i+1;j&lt;prices.length;j++)&#123; max = Math.max(max,prices[j]); //找后面日子的最高价 &#125; ans = Math.max(ans,max-prices[i]); //max是后面的最高价，price[i]是购入价 &#125; return ans; &#125;&#125; 每日价格 prices[i] 7 1 5 3 6 4 今天起最大的价格dp[i] 7 6 6 6 6 4 差价 dp[i] - prices[i] 0 5 1 3 0 0 发现差价5是最大的，也就是说最大利润是5。 昨天学了单调栈，思考的时候意识到好像可以用单调栈来求dp[]数组。 时间复杂度O(n)，空间复杂度O(n) 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int [] dp = new int[prices.length] ; Stack &lt;Integer&gt; stack = new Stack&lt;&gt;(); //单调递增栈 for(int i =prices.length-1;i&gt;=0;i--)&#123; if(stack.isEmpty() || stack.peek() &lt; prices[i])&#123; stack.push(prices[i]); dp[i] = prices[i]; continue; &#125; dp[i] = stack.peek(); &#125; int ans = 0; for(int i = 0; i&lt;prices.length; i++)&#123; ans = Math.max(ans,dp[i]-prices[i]); &#125; return ans; &#125;&#125; 不过很快，我发现了用单调栈这是多此一举。 为什么呢？因为完全可以用一个变量来代替递增栈。改进如下： 时间复杂度O(n)，空间复杂度O(n)。 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int [] dp = new int[prices.length] ; int max = 0; for(int i =prices.length-1;i&gt;=0;i--)&#123; if(prices[i] &lt; max)&#123; dp[i] = max; &#125;else&#123; //说明了这天后的所有价格都不比今天高 max = prices[i]; dp[i] = prices[i]; &#125; &#125; int ans = 0; for(int i = 0; i&lt;prices.length; i++)&#123; ans = Math.max(ans,dp[i]-prices[i]); &#125; return ans; &#125;&#125; 这是我自己想到的最优解了，不过提交后，时间超60%，空间超5%，我意识到还有优化的空间。 看了题解，最优解法是O(n)的时间复杂度和O(1）的空间复杂度。题解和我的思考角度略微有些不一样，不过还是收到启发，做了一些优化： 首先，可以直接在当前循环计算利益的最大值，没必要用两个循环，这一步对时间复杂度有优化。 12345678910111213141516class Solution &#123; public int maxProfit(int[] prices) &#123; int [] dp = new int[prices.length] ; int max = 0 ,ans = 0; for(int i =prices.length-1;i&gt;=0;i--)&#123; if(prices[i] &lt; max)&#123; dp[i] = max; &#125;else&#123; max = prices[i]; dp[i] = prices[i]; &#125; ans = Math.max(ans,dp[i]-prices[i]); &#125; return ans; &#125;&#125; 再次，我又意识到了，dp数组是完全没必要的，中间状态没必要用数组存。 于是有了最后的优化：O(n),O(1) 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; int max = 0,ans = 0; int sell=0; //sell表示最理想的售价 //prices[i]作为购入价 for(int i =prices.length-1;i&gt;=0;i--)&#123; sell = prices[i]; //最佳售价初始化为购入价 if(prices[i] &lt; max)&#123; sell = max; //最佳售价是今天之后的最高价格 &#125;else&#123; max = prices[i]; //更新前面日子的最佳售价。 &#125; ans = Math.max(ans,sell-prices[i]); &#125; return ans; &#125;&#125; By the way， ps: 以上的考虑都是把今天作为购入时间来考虑，我们想要售出时间点的价格越高越好，也就是说今天之后的最高价格是最优售出价格！ 如果把今天作为售出时间来考虑，我们希望购入时间点的价格越低越好，这里的dp[i]是可以理解成为是最优的购入价。 每日价格 prices[i] 7 1 5 3 6 4 今天以及之前最低的价格dp[i] 7 1 1 1 1 1 差价price[i] - dp[i] 0 5 4 2 0 3 代码大同小异，只是两种思考方式不一样而已，题解给的就是这种思考方式。 20200612 晴坚持每日刷3题已经：30天。 题1 【待优化】 每日温度 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 暴力解法O(n^2)，能AC，代码略。 看题解，说这道题能用单调栈解决，上次接触单调栈概念是在雨水堆积那题，当时没看懂，所以计划今天先学单调栈，然后解出这几道相关题。 介绍单调栈的博客，此博客很形象地介绍了生成单调栈的过程：把比自己元素值大（小）的元素赶出栈，然后自己进入栈。 博客还介绍了一个使用单调栈的经典场景： 单调递增栈可以找到从当前元素开始向左第一个比当前数字小的元素。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为 1，4，5。 单调递减栈可以找到从当前元素开始向左第一个比当前数字大的元素。这里就不举例说明了，同样的道理，大家可以自行验证一下。 受到这段话的启发，对比这题，其实应用场景是一致的：只不过这题是需要找到从当前元素开始向右找到第一个比当前数字大的元素(的下标与当前元素的相减得到的值)。所以从右向左遍历，构建单调递减栈解决。 1234567891011121314151617181920class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int [] res = new int[T.length]; Stack&lt;Integer&gt; indexStack = new Stack&lt;&gt;(); //从右到左处理，递增栈 for(int i=T.length-1;i&gt;=0;i--)&#123; while(!indexStack.isEmpty() &amp;&amp; T[indexStack.peek()] &lt;= T[i] )&#123; //把比当前元素小的元素都赶出栈 indexStack.pop(); &#125; //此时栈顶元素就是比当前元素大的那个元素 if(indexStack.isEmpty())&#123; res[i] = 0; &#125;else&#123; res[i] = indexStack.peek()-i; &#125; indexStack.push(i); &#125; return res; &#125;&#125; 时间复杂度和空间复杂度都是O(n)。 执行用时 :25 ms, 在所有 Java 提交中击败了50.54%的用户 内存消耗 :47.5 MB, 在所有 Java 提交中击败了6.45%的用户 but从结果看，提交了效率好像还是不太行，官方题解如下，待消化： 123456789101112131415161718192021class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int length = T.length; int[] ans = new int[length]; Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; length; i++) &#123; int temperature = T[i]; while (!stack.isEmpty() &amp;&amp; temperature &gt; T[stack.peek()]) &#123; int prevIndex = stack.pop(); ans[prevIndex] = i - prevIndex; &#125; stack.push(i); &#125; return ans; &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题2 【待优化】 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 暴力解法O(n^2)。 暴力法的基本思路：当前柱子的储水量取决于左右两边最高的柱子高度，左右两边分别最高的柱子中较矮的那个柱子减去当前柱子的高度就是这个柱子的储水量，注意，这个值可能是负数（左右两边）。 1234567891011121314151617181920class Solution &#123; public int trap(int[] height) &#123; int leftMax=0,rightMax=0; int res = 0; for(int i = 0; i&lt;height.length; i++)&#123; leftMax = 0; rightMax = 0; for(int m = 0;m&lt;i;m++)&#123; leftMax = Math.max(leftMax,height[m]); &#125; for(int n = i+1;n&lt;height.length;n++)&#123; rightMax = Math.max(rightMax,height[n]); &#125; int tmp = Math.min(leftMax,rightMax)-height[i]; res += tmp&gt;0?tmp:0; &#125; return res; &#125;&#125; 题3 盛最多水的容器 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 tag:双指针。 暴力法：O(n^2)。 双指针：O(n)。 image-20200612221247121 移动双指针的规则：i 和 j 围起来的面积区域是(j-i)*min(A[i],A[j])，发现此时A[i]&lt;A[j],所以i指针往前移一步，也就是说谁矮谁移动。 为什么从两边的双指针走到中间可以实现值得思考。 这样做的确会遗漏一些组合，由于i移动到了i’，比如说我在上图里画出来的i 和 j’围起来的区域的面积就不会被计算到 ！乍一看，j’的高度比j高，但是j到i的宽度更大，所以由ij和ij‘两个组合围成的面积大小似乎不能确定（一个高度大宽度小，另一个高度小宽度大）。但是仔细想，ij’的面积必然比ij小，因为j’虽然比j高，但是i和j’受限于低的那个柱子，也就是i。图上我红色加粗画出的矩形就是ij组合和ij’组合围成的面积差。 123456789101112131415class Solution &#123; public int maxArea(int[] height) &#123; int i = 0, j = height.length-1; int area = 0; while(i&lt;j)&#123; area = Math.max(area,Math.min(height[i],height[j])*(j-i)); if(height[i]&lt;height[j])&#123; i++; &#125;else&#123; j--; &#125; &#125; return area; &#125;&#125; 20200611 雨坚持每日刷3题已经：29天。 这几天都晚睡晚起，有点发懵，今天开始早点睡，恢复学习状态，并开始投递实习和提前批的简历。 题1 把二叉搜索树转换为累加树 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 加上所有比它大的结点的结点值，也就是所有中序遍历在该节点后面的结点值。 所以一个思路是先获取中序遍历的序列，然后将其序列反转。 12345678910111213141516171819class Solution &#123; public TreeNode convertBST(TreeNode root) &#123; ArrayList&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); inorder(root,list); //获取中序遍历序列 int sum = 0; for(int i = list.size()-1; i&gt;=0 ; i--)&#123; //从最大元素开始倒序遍历，加上sum int tmp = list.get(i).val; list.get(i).val += sum; sum += tmp; &#125; return root; &#125; public void inorder(TreeNode root,ArrayList&lt;TreeNode&gt; list)&#123; if(root==null) return; inorder(root.left,list); list.add(root); inorder(root.right,list); &#125;&#125; 优化后的解法：一步到位 12345678910111213141516class Solution &#123; int sum; public TreeNode convertBST(TreeNode root) &#123; inorderReverse(root); return root; &#125; //中序遍历（左根右）的“倒序”遍历： public void inorderReverse(TreeNode root)&#123; if(root==null) return; inorderReverse(root.right); //右 int tmp = root.val; root.val += sum; //根 sum += tmp; inorderReverse(root.left); //左 &#125;&#125; 题2 【待改进】 路径总和 III 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 我的做法比较暴力，就是根据定义来做。 以下代码框架和树的子结构那题一致。 时间复杂度应该是O(n^2) 123456789101112131415161718class Solution &#123; int cnt; public int pathSum(TreeNode root, int sum) &#123; if(root==null) return 0; pathSumFromRoot(root,sum); //这两行代码是遍历每个结点分别计数 pathSum(root.left,sum); pathSum(root.right,sum); return cnt; &#125; public void pathSumFromRoot(TreeNode root,int sum)&#123; if(root==null) return ; if(root.val == sum) cnt++; //注意，如果直接return，这样做会遗漏 1-&gt; -1 -&gt;2 -&gt;-2 = 0的路径,因为在1-&gt; -1 = 0 就退出了 pathSumFromRoot(root.left,sum-root.val); pathSumFromRoot(root.right,sum-root.val); &#125;&#125; 题3 【待熟练】 相交链表 编写一个程序，找到两个单链表相交的起始节点。如果不相交，返回空。 简单题，一次过。 执行用时 :1 ms, 在所有 Java 提交中击败了99.97%的用户 内存消耗 :42.9 MB, 在所有 Java 提交中击败了61.90%的用户 12345678910111213141516171819202122232425262728293031323334353637//思路：我们通常做这种题的思路是设定两个指针分别指向两个链表头部，一起向前走直到其中一个到达末端，另一个与末端距离则是两链表的 长度差。再通过长链表指针先走的方式消除长度差，最终两链表即可同时走到相交点。https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; int lengthA = 0,lengthB = 0; ListNode pA = headA,pB= headB; //O(m) while(pA!=null)&#123; lengthA++; pA = pA.next; &#125; //O(n) while(pB!=null)&#123; lengthB++; pB = pB.next; &#125; pA = headA; pB = headB; if(lengthA &gt; lengthB)&#123; //pA先走 lengthA-lengthB步 for(int i = 0; i&lt; lengthA-lengthB;i++)&#123; pA = pA.next; &#125; &#125;else&#123; //pB先走 lengthB-lengthA步 for(int i = 0; i&lt; lengthB-lengthA;i++)&#123; pB = pB.next; &#125; &#125; while(pA!=null)&#123; if(pA==pB) break; //注意比较的是pA和pB的引用，而不是比较pA和pB对应的值 pA=pA.next; pB=pB.next; &#125; return pA; &#125;&#125; 写完就感觉我的代码好像啰嗦了一点，想看看有没有什么更好的办法，结果果然，有一个很骚气的解法： https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/jiao-ni-yong-lang-man-de-fang-shi-zhao-dao-liang-2/ 123456789101112走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode pa = headA,pb = headB; while(pa!=pb)&#123; //如果有相交结点，会找到相交结点，如果没有相交结点，pa、pb也必然会在最后同时走到null pa = pa==null?headB:pa.next; pb = pb==null?headA:pb.next; &#125; return pa; &#125;&#125; 这要是面试，写出下面这个解法不光逼格高，而且会极其节省时间。 20200610 雨坚持每日刷3题已经：28天。 题1 【待熟练】二叉树展开为链表 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 ​ 1 / 2 5 / \\ 3 4 6将其展开为： 1 2 3 4 5 6 根据观察给出的示例，是将前序遍历的结果串成一条单向链表，且是用结点的右指针指向链表的下一结点。 所以思路可以是：用迭代法求出二叉树的前序遍历序列，同时访问时将一个个结点串起来，这样做，时间、空间复杂度都是O(n)，一开始我觉得这种空间复杂度是O（n）的算法不满足”原地展开“的要求，但是后来又看到有人说不新建结点、在原结点基础上修改指针就是原地算法。同时，又从别处了解到： 原地算法（in-place algorithm）：只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地”进行的，是节省存储的算法。非原地算法（not-in-place）：需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元。算法临时占用空间是考虑算法空间复杂度时主要考虑的部分。相比于随着问题输入规模扩大而扩大的非原地算法，原地算法是更加简洁高效的算法（仅考虑空间复杂度时）。 由于此算法需要O(n)级别的栈空间，所以好像也不符合原地算法的定义？ 同样的，leetcode很多答案给出的递归解法，这也会开辟虚拟机的栈空间，这里很迷惑。 思路：前序遍历递归。 123456789101112131415class Solution &#123; public void flatten(TreeNode root) &#123; if(root==null) return; TreeNode oldRight = root.right; //记录原来的右孩子 root.right = root.left; root.left = null; TreeNode rightMost = root; //注意这里要把原来的右孩子转移到左子树的最右元素的右边，否则右子树就丢了 while(rightMost.right!=null)&#123; rightMost = rightMost.right; &#125; rightMost.right = oldRight; // 左子树为空了，不用再操作flatten(root.left); flatten(root.right); &#125;&#125; 上面的递归可以改写成迭代写法，这样我觉得才是符合原地算法的要求： 1234567891011121314151617class Solution &#123; public void flatten(TreeNode root) &#123; while(root!=null)&#123; TreeNode oldRight = root.right; //记录原来的右孩子 root.right = root.left; root.left = null; TreeNode rightMost = root; //注意这里要把原来的右孩子转移到左子树的最右元素的右边，否则右子树就丢了 while(rightMost.right!=null)&#123; rightMost = rightMost.right; &#125; rightMost.right = oldRight; root = root.right; //相当于上面的递归写法。 &#125; &#125;&#125; 题2 【待解决】 寻找重复数 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2]输出: 2示例 2: 输入: [3,1,3,4,2]输出: 3说明： 1、不能更改原数组（假设数组是只读的）。 》不能hashset排序2、只能使用额外的 O(1) 的空间。 》不能hashset3、时间复杂度小于 O(n2) 。 》不能暴力，暴力解法O（n^2)4、数组中只有一个重复的数字，但它可能不止重复出现一次。 注意第4点说明，不然可以直接根据等差数列公式求和，再减去当前数列的和。 二分查找算法+抽屉原理。 123456789101112131415161718192021222324252627282930313233343536import java.util.*;class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; HashMap &lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key是数字,value该数字出现频率，O(n) for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(nums[i]))&#123; map.put(nums[i],map.get(nums[i])+1); &#125;else&#123; map.put(nums[i],1); &#125; &#125; //反转key-value，O(m), m为n个元素中不重复元素个数，m必然不大于n //key是频率,value是该频率对应的数字 HashMap &lt;Integer,Integer&gt; map2 = new HashMap&lt;&gt;(); for(Integer key : map.keySet())&#123; map2.put(map.get(key),key); &#125; //O(mlogk)，m必然不大于n Queue &lt;Integer&gt; queue = new PriorityQueue &lt;&gt;(k); //最小堆，求top k for(Integer key : map2.keySet())&#123; if(queue.size()&lt;k)&#123; queue.offer(key); &#125;else&#123; queue.poll(); queue.offer(key); &#125; &#125; //最后堆里留下来的就是top k 的频率，而我们要求的是该频率对应的数字。 ArrayList &lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i=0; i&lt;k; i++)&#123; res.add(map2.get(queue.poll())); &#125; return res; &#125;&#125; 题3 前 K 个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]示例 2: 输入: nums = [1], k = 1输出: [1] 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 一开始的做法：有误，比如[1,2],2，map是{(1,1),(2,1)}，map2:{(2,1)} （频率相同的元素被覆盖了！） 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; HashMap &lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key是数字,value该数字出现频率，O(n) for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(nums[i]))&#123; map.put(nums[i],map.get(nums[i])+1); &#125;else&#123; map.put(nums[i],1); &#125; &#125; //反转key-value，O(m), m为n个元素中不重复元素个数，m必然不大于n //key是频率,value是该频率对应的数字 ！！！！！！！这里有错 HashMap &lt;Integer,Integer&gt; map2 = new HashMap&lt;&gt;(); for(Integer key : map.keySet())&#123; map2.put(map.get(key),key); &#125; //O(mlogk)，m必然不大于n Queue &lt;Integer&gt; queue = new PriorityQueue &lt;&gt;(k); //最小堆，求top k for(Integer key : map2.keySet())&#123; if(queue.size() &lt; k)&#123; queue.offer(key); &#125; ！！！！这里也有错 要和堆顶元素比较 else&#123; queue.poll(); queue.offer(key); &#125; &#125; //最后堆里留下来的就是top k 的频率，而我们要求的是该频率对应的数字。 int [] res = new int[k]; for(int i=0; i&lt;k; i++)&#123; res[i] = map2.get(queue.poll()); &#125; return res; &#125;&#125; 正确代码如下（巧妙利用了比较器）： 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; HashMap &lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key是数字,value该数字出现频率，O(n) for(int i=0;i&lt;nums.length;i++)&#123; if(map.containsKey(nums[i]))&#123; map.put(nums[i],map.get(nums[i])+1); &#125;else&#123; map.put(nums[i],1); &#125; &#125; //O(mlogk)，m必然不大于n Queue &lt;Integer&gt; queue = new PriorityQueue &lt;&gt;(k,(i1,i2)-&gt;map.get(i1)-map.get(i2)); //最小堆，求top k for(Integer key : map.keySet())&#123; if(queue.size() &lt; k)&#123; queue.offer(key); &#125;else if(map.get(key) &gt; map.get(queue.peek()) )&#123; queue.poll(); queue.offer(key); &#125; &#125; //最后堆里留下来的就是top k 的频率，而我们要求的是该频率对应的数字。 int [] res = new int[k]; for(int i=0; i&lt;k; i++)&#123; res[i] = queue.poll(); &#125; return res; &#125;&#125; 其他思路：排序，同样用比较器。 题4 找到所有数组中消失的数字 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 使用额外空间（标记数组）的做法： 1234567891011121314151617class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; int n = nums.length; boolean visited[] = new boolean[n]; for(int i = 0; i&lt;n; i++)&#123; visited[nums[i]-1] = true; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i&lt;n; i++)&#123; if(!visited[i])&#123; list.add(i+1); &#125; &#125; return list; &#125;&#125; 参考官方题解，解锁一个很妙的方法——原地哈希，不适用额外空间，修改原数组就能解决。 不过要注意这种做法只有在某种限制下才能做， 比如这题1 ≤ a[i] ≤ n。 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; int hash = 0; for(int i = 0; i&lt;nums.length; i++)&#123; hash = Math.abs(nums[i])-1; if(nums[hash]&gt;0)&#123; nums[hash] = -nums[hash]; &#125; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i&lt;nums.length; i++)&#123; if(nums[i]&gt;0)&#123; list.add(i+1); &#125; &#125; return list; &#125;&#125; 20200609 晴坚持每日刷3题已经：27天。 题1 【待熟练】 下一个较大排列 实现函数next permutation（下一个排列）：将排列中的数字重新排列成字典序中的下一个更大的排列。将排列中的数字重新排列成字典序中的下一个更大的排列。 如果不存在这样的排列，则将其排列为字典序最小的排列（升序排列） 需要使用原地算法来解决这个问题，不能申请额外的内存空间 下面有机组样例，左边是输入的数据，右边是输出的答案 1,2,3→1,3,23,2,1→1,2,31,1,5→1,5,1 做的时候多考虑几位数的测试用例，如5 7 6 4 参考题解：https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/ 1，2，3，8，5，7，6，4 目标：设置一指针从后往前，当存在下标i满足a[i] &gt; a[i-1] 的时候停下（本例中a[i]=7的时候停下）。由于i指针的运动规律，易知当i停下的时候，在区间[i,a.length)的元素是降序排列的，我们要找到这部分的第一个比a[i-1]大的元素（这里是6），然后交换这个元素和a[i-1]的位置，得到： 1，2，3，8，6，4，6，7 1，2，3，8，6，7，5，4 然后，将区间[i,a.length)这一部分元素按照从小到大排列（原来是从大到小排列），在本例中，也就是7,5,4排列成4,5,7。 最后得到结果： 1，2，3，8，6，4，5，7 我是先反转，然后再交换位置。 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public void nextPermutation(int[] num) &#123; int i = 0; for( i = num.length-1; i&gt;=1 ; i--)&#123; if(num[i] &gt; num[i-1])&#123; break; &#125; &#125; //退出循环有两种可能：最后i的下标指向0（如果始终不满足a[i]&gt;a[i-1]）或者是第一个指向a[i]&gt;a[i-1]的元素 //下一个for循环完成反转[i,num.length)的元素 int end = num.length-1; for(int j = i; j&lt;end; j++)&#123; //注意j&lt;end这个条件 swap(num,j,end); end--; &#125; if(i==0) return; for(int j = i; j&lt;num.length; j++)&#123; if(num[j]&gt;num[i-1])&#123; swap(num,i-1,j); break; &#125; &#125; return; &#125; public void swap(int [] num,int i,int j)&#123; int tmp = num[i]; num[i] = num[j]; num[j] = tmp; &#125;&#125; 题2 根据中序和后序序列求二叉树递归。 123456789101112131415161718192021222324public class Solution &#123; public TreeNode buildTree (int[] inorder, int[] postorder) &#123; return buildTree(inorder,postorder,0,inorder.length-1,0,inorder.length-1); &#125; //求中序序列inorder[i1..j1]和后序序列postorder[i2...j2]的根节点 public TreeNode buildTree(int[] inorder,int [] postorder,int i1,int j1,int i2 ,int j2)&#123; if(i1&gt;j1)&#123; return null; &#125; //postorder[j2]就是根节点 TreeNode root = new TreeNode(postorder[j2]); int i,ri = i2-1; for(i = i1; i&lt; j1; i++,ri++)&#123; if(inorder[i] == postorder[j2])&#123; break; &#125; &#125; //左子树的中序序列是inorder[i1..i-1],后序是postorder[i2..ri] //右子树的中序序列是inorder[i+1..j1],后序是postorder[ri+1..j2-1] root.left = buildTree(inorder,postorder,i1,i-1,i2,ri); root.right = buildTree(inorder,postorder,i+1,j1,ri+1,j2-1); return root; &#125;&#125; 题3 【待熟练】3-sum 给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。 注意： 三元组（a、b、c、d）中的元素必须按非降序排列。（即a≤b≤c） 解集中不能包含重复的三元组。 例如，给定的数组 S = {-1 0 1 2 -1 -4},↵↵ 解集为：↵ (-1, 0, 1)↵ (-1, -1, 2) 先排序，然后选取每个数字作为base，-base就是剩下两个数的和的目标，这两个数字用双指针定位！ 时间复杂度是：排序：O(n*log(n)) + O(n^2)，所以时间复杂度可看作是O(n^2)。 注意处理重复的结果！！ 123456789101112131415161718192021222324252627282930313233343536import java.util.Arrays;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i=0;i&lt;num.length-2;i++)&#123; if(i&gt;0 &amp;&amp; num[i]==num[i-1]) continue; //如果重复，直接跳过 int target = -num[i]; int m = i+1; int n = num.length-1; while(m &lt; n)&#123; if(num[m]+num[n] == target)&#123; ArrayList&lt;Integer&gt; oneResult = new ArrayList&lt;Integer&gt;(); oneResult.add(num[i]); oneResult.add(num[m]); oneResult.add(num[n]); res.add(oneResult); m++; while(m &lt; n &amp;&amp; num[m] == num[m-1])&#123; m++; //如果重复，直接跳过 &#125; n--; while(m &lt; n &amp;&amp;num[n] == num[n+1])&#123; n--; //如果重复，直接跳过 &#125; &#125;else if(num[m]+num[n] &gt; target)&#123; n--; &#125;else&#123; m++; &#125; &#125; &#125; return res; &#125;&#125; 20200608 晴坚持每日刷3题已经：26天。 题1 回文数 回文数判断，负数不是回文数，要考虑反转后溢出的情况，所以我用了long。 1234567891011121314151617public class Solution &#123; /** * * @param x int整型 * @return bool布尔型 */ public boolean isPalindrome (int x) &#123; if(x&lt;0) return false; long tmp = 0; int xcopy = x; while(x!=0)&#123; tmp = x%10 + tmp*10; x/=10; &#125; return xcopy==tmp; &#125;&#125; 学习别人的代码： 1234567891011121314链接：https://www.nowcoder.com/questionTerminal/35b8166c135448c5a5ba2cff8d430c32?f=discussion来源：牛客网 public boolean isPalindrome(int x) &#123; // 如果是负数，或者10的整数倍，返回false if (x &lt; 0 || x != 0 &amp;&amp; x % 10 == 0) return false; int reverse = 0; while (x &gt; reverse) &#123; reverse = reverse * 10 + x % 10; x = x / 10; &#125; return (reverse == x || reverse / 10 == x); &#125; 题2 【待熟练】 不同的BST种数 给定一个值n，能构建出多少不同的值包含1…n的二叉搜索树（BST）？ 例如 给定 n = 3, 有五种不同的二叉搜索树（BST） 参考思路： 作者：加油吧~链接：https://www.nowcoder.com/questionTerminal/b2b6734cbc0b43088f6084785046b861?f=discussion来源：牛客网 二叉搜索树有个性质，就是左边的数都比根小，右边的数都比根大。另外，题目说明二叉树的节点是从1到n，所以我们能确定如果根为k，则根左边的数是1到k-1，根右边的数是k+1到n。还有一点技巧是，对于通过一个根来说，唯一二叉树的数量是其左子树的数量乘以右子树的数量，这是简单的乘法原理。并且，左右子树的形态数量是跟具体的数无关的，只跟这个树里有多少节点有关。而根可以选择从1到n的任意的数，唯一二叉树的总数，就是根为1到n的树相加。所以该问题化简为以k为根，其唯一左子树和右子树各有多少，这就是个动态规划的问题了。我们建立一个数组dp[i]，代表节点数为i的唯一子树有多少个。显然dp[0]=dp[1]=1。 123456789101112131415public class Solution &#123; public int numTrees(int n) &#123; int dp [] = new int[n+1]; //dp[i]的含义是i个结点有几种排法 dp[0] = 1; dp[1] = 1; for(int i=2;i&lt;=n;i++)&#123; //结点的总个数 //乘法原理 //左子树的结点个数在0到i-1,右子树的结点个数则是i-1-leftNum（因为它们的左右子树的结点总个数是i-1) for(int leftNum = 0; leftNum &lt; i;leftNum++)&#123; dp[i] += (dp[leftNum] * dp[i-1-leftNum]); &#125; &#125; return dp[n]; &#125;&#125; 题3 字符串二进制数的加法 给出两个用字符串表示的二进制数，返回他们的和（也用字符串表示） 例如： a =”11”b =”1”返回”100”. 很简单的题，因为条件判断写错了浪费了很多时间调试，实在不应该。 本题涉及到的重要api：sb.insert(0,‘a’) 用于StringBuilder类型的变量在字符串首部添加元素。 123456789101112131415161718192021222324import java.util.*;public class Solution &#123; public String addBinary (String a, String b) &#123; int lastA,lastB,carry=0,digit=0; int curA = a.length()-1,curB = b.length()-1; StringBuilder res = new StringBuilder(\"\"); while(carry==1 || curA &gt;=0 || curB&gt;=0)&#123; lastA = curA&gt;=0?a.charAt(curA)-'0':0; //-'0' lastB = curB&gt;=0?b.charAt(curB)-'0':0; digit = carry+lastA+lastB; if(digit&gt;1)&#123; digit %= 2; carry = 1; &#125;else&#123; carry = 0; &#125; res.insert(0,digit); //这个api要记住！！！！！ curA--; curB--; &#125; return res.toString(); &#125;&#125; 20200607 晴坚持每日刷3题已经：25天。 题1 三角形最小路径和 给出一个三角形，计算从三角形顶部到底部的最小路径和，每一步都可以移动到下面一行相邻的数字， 例如，给出的三角形如下： 1[↵ [2],↵ [3,4],↵ [6,5,7],↵ [4,1,8,3]↵] 最小的从顶部到底部的路径和是2 + 3 + 5 + 1 = 11。 注意：如果你能只用O（N）的额外的空间来完成这项工作的话，就可以得到附加分，其中N是三角形中的行总数。 注意：题目里说的“可以移动到下面一行相邻的数字”指的是下一行的对应位置元素和下一行其右边的元素。（leetcode中对此进行了说明——相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。）。 没有用到额外空间，但是修改了输入。 123456789101112131415import java.util.ArrayList;public class Solution &#123; public int minimumTotal(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; triangle) &#123; if(triangle==null || triangle.get(0)==null ) return 0; for(int i = triangle.size()-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;triangle.get(i).size();j++)&#123; //int left = j&gt;0?triangle.get(i+1).get(j-1):Integer.MAX_VALUE; 这个不算相邻！ int down = triangle.get(i+1).get(j); int right = j&lt;triangle.get(i).size()?triangle.get(i+1).get(j+1):Integer.MAX_VALUE; triangle.get(i).set(j,triangle.get(i).get(j)+Math.min(down,right)); &#125; &#125; return triangle.get(0).get(0); &#125;&#125; 题2 丑数 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 这是剑指Offer上的一道题，之前一直没思路，昨天看了大佬的题解数学定义太多也看得迷迷糊糊，今天get到了，手动计算了一遍，写代码一遍过。牛客网上tag是穷举，不过做了发现更像是动态规划。 理解此题的核心在于理解：从第二个丑数开始，任何一个丑数都可以由前面的某个丑数x2,或者x3,或者x5得到。 手动计算过程 1234567891011121314151617181920212223242526public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index&lt;=0) return 0; int [] dp = new int [index]; dp[0] = 1; //p1、p2、p3分别指向*2 , *3 ,*5的备选项 int p2 = 0,p3 = 0,p5 = 0; int p2Value,p3Value,p5Value; for(int i = 1; i&lt;index; i++)&#123; p2Value = dp[p2] * 2; p3Value = dp[p3] * 3; p5Value = dp[p5] * 5; dp[i] = Math.min(Math.min(p2Value,p3Value),p5Value); if(dp[i] == dp[p2]*2)&#123; //最小 p2++; &#125; if(dp[i] == dp[p3]*3)&#123; p3++; &#125; if(dp[i] == dp[p5]*5)&#123; p5++; &#125; &#125; return dp[index-1]; &#125;&#125; 简化上述代码： 12345678910111213141516public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index&lt;=0) return 0; int [] dp = new int [index]; dp[0] = 1; //p1、p2、p3分别指向*2 , *3 ,*5的备选项 int p2 = 0,p3 = 0,p5 = 0; for(int i = 1; i&lt;index; i++)&#123; dp[i] = Math.min(Math.min(dp[p2]*2,dp[p3]*3),dp[p5]*5); if(dp[i] == dp[p2]*2) p2++; if(dp[i] == dp[p3]*3) p3++; if(dp[i] == dp[p5]*5) p5++; &#125; return dp[index-1]; &#125;&#125; 题3 【待熟练】数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 tag:堆 这是一个涉及堆的问题，虽然说堆的实现不难，不过面试的时候估计是没那么多时间去自己实现一个堆，还是用现成的轮子——PriorityQueue吧。不过对其api不是很熟悉，这里复习一下： JDK提供的PriorityQueue底层实现是最小堆。 如果要通过PriorityQueue完成最大堆的功能，需要指定比较器。 12345678 PriorityQueue &lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125; &#125;);可以用lambda表达式简化： PriorityQueue &lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(k, (o1, o2) -&gt; o2-o1); queue.add(Object o)和queue.remove()可分别用于在堆中插入元素、移除堆顶元素。 queue.size()返回堆的大小。 熟悉完了PriorityQueue，就可以做这个题目了。 这题是基于用一个最大堆和一个最小堆，分别平均地保存数据流中的较小的数字和较大的数字的思想，比如说数据流是1,2,3,4,5,6， 我们希望，其内部存储形如（只要满足堆的性质就好，其中1和2以及5和6的位置可以调换）： ​ 3 4 ​ / \\ / \\ 2 1 5 6 这样一来， 其中位数就可以通过最大堆和最小堆的堆顶元素得到。 难点就是在于，怎么在插入元素的同时维持两个堆的平衡、且不破坏堆的性质。 为了保持平衡，也就是哪个堆元素少，新添加的元素就要插入到哪个堆，而如果两个堆的大小相同，可以规定默认插入到最小堆。 比如说这时候再来一个元素7，插入到最小堆，再来一个元素，变成4567，中位数是4， 再来一个元素8，因为这个时候，最大堆的元素个数比较少，为了保证两堆的平衡，我们是希望最大堆能多一个元素，但如果直接把8插入到最大堆，堆就变成了8312，最小堆仍是4567，计算中位数就变成了(4+8)/2 ，显然不对，为什么会不对呢？这是因为我们把8这个大元素插入到了最大堆，而最大堆应该保存的是比较小的元素，所以说，我们想要增加最大堆的元素个数，不能将现在的元素直接插入到最大堆，而是应该先插入到最小堆，在最小堆中大元素下沉，变成45678，这个时候再把4取走插入到最大堆，也就是说最小堆变成了5678，最大堆变成了4321，这样一来，才能保证了最大堆的大小确实+1，而且维持了用一个最大堆和一个最小堆，分别平均地保存数据流中的较小的数字和较大的数字的目标。 同理，最大堆是321，最小堆是456，当又来了一个元素0，我们也不能直接插入到最小堆，而是要先插入到最大堆，让0下沉，再把最大堆的堆顶元素3取过来到最小堆。 说的很繁琐，简单总结一下：通过维持两个堆的大小相等（或最小堆的大小大1）来保证以O(1)时间找到中位数，而如果要插入新的元素，如果此时两堆大小相等，我们希望最小堆中再多放一个元素（大小能增加1），但是我们不能直接把新元素插入，而是要先插入最大堆，再从最大堆取出堆顶元素加入到最小堆，这样一来，最大堆的元素个数没变，最小堆的元素个数增加1。 1234567891011121314151617181920212223242526import java.util.PriorityQueue;//思路:如果两个堆的大小一样，随便加入到哪个堆，如果两个堆的大小不一样，加入到元素少的那个堆//我的处理是如果两个堆大小一样，就加入到最小堆//关键在于：想加到最大/小堆不能直接加，而要虚晃一下，加入另一个堆，再把另一个堆的堆顶加入到你真正想加入的那个堆public class Solution &#123; private PriorityQueue &lt;Integer&gt; minQueue = new PriorityQueue&lt;&gt;(); //最小堆 private PriorityQueue &lt;Integer&gt; maxQueue = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); //最大堆 public void Insert(Integer num) &#123; if(minQueue.size()&lt;=maxQueue.size())&#123; //我们希望minQueue里增加一个元素，但是不能直接加入 maxQueue.add(num); minQueue.add(maxQueue.remove()); &#125;else&#123; //我们希望maxQueue里增加一个元素，但是不能直接加入 minQueue.add(num); maxQueue.add(minQueue.remove()); &#125; &#125; public Double GetMedian() &#123; if(minQueue.size()==maxQueue.size()) return (minQueue.peek()+maxQueue.peek())/2.0; return minQueue.peek()*1.0; &#125;&#125; 20200606 晴坚持每日刷3题已经：24天。 今天出去小浪了一波吃了个烤鱼，回来睡到晚十点，本来想做几道DP，太累了看了几题实在没思路，题解也看不进去，索性从leetcode top100挑几道简单题完成任务。 题1 汉明距离 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 while循环最多进入32次。 123456789101112class Solution &#123; public int hammingDistance(int x, int y) &#123; int cnt = 0; while(x!=0||y!=0)&#123; cnt+=(x&amp;1)^(y&amp;1); x = x&gt;&gt;1; y = y&gt;&gt;1; &#125; return cnt; &#125;&#125; 这里有种改进方案。 123456789101112131415161718class Solution &#123; public int hammingDistance(int x, int y) &#123; int xor = x ^ y; int distance = 0; while (xor != 0) &#123; distance += 1; // remove the rightmost bit of '1' xor = xor &amp; (xor - 1); &#125; return distance; &#125;&#125;作者：LeetCode链接：https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题2 合并二叉树 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 我自己做的递归： 12345678910111213141516171819class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; TreeNode res = null; if(t1==null &amp;&amp; t2==null)&#123; return null; &#125;else if(t1 == null)&#123; //t1空t2不空 res = new TreeNode(t2.val); &#125;else if(t2 == null)&#123; res = new TreeNode(t1.val); &#125;else&#123; res = new TreeNode(t1.val + t2.val); &#125; if(res!=null)&#123; res.left = mergeTrees(t1!=null?t1.left:null,t2!=null?t2.left:null); res.right = mergeTrees(t1!=null?t1.right:null,t2!=null?t2.right:null); &#125; return res; &#125;&#125; 其实做之前也想到了，可以以一棵树为基准，不用new结点。 但是想到这样的话就会修改原来两棵树的结构，就没这样做了。 题解给的递归方法很简洁，就是基于此思路的: 1234567891011121314151617public class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null) return t2; if (t2 == null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; &#125;&#125;作者：LeetCode链接：https://leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题3 比特位计数 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2输出: [0,1,1]示例 2: 输入: 5输出: [0,1,1,2,1,2] 12345678910//tag:位运算，这题有点动态规划的思想，参考官方题解的\"方法三：动态规划 + 最低有效位 \" class Solution &#123; public int[] countBits(int num) &#123; int res [] = new int[num+1]; for(int i=0; i&lt;=num; i++)&#123; res[i] = res[i&gt;&gt;1] + (i &amp; 1); &#125; return res; &#125;&#125; 20200605 多云坚持每日刷3题已经：23天。 题1 爬楼梯12你在爬楼梯，需要n步才能爬到楼梯顶部每次你只能向上爬1步或者2步。有多少种方法可以爬到楼梯顶部？ dp数组动态规划。 123456789101112131415161718192021222324public class Solution &#123; /** * * @param n int整型 * @return int整型 */ // 1-1 // 2-2 // 3-dp[i-1]+dp[i-1] public int climbStairs (int n) &#123; if(n&lt;=2)&#123; return n; &#125; int dp[] = new int[n]; dp[0] = 1; dp[1] = 2; for(int i = 2; i&lt;n; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n-1]; &#125;&#125; 进一步优化:不需要数组，只用几个临时变量迭代（逻辑上有点像双指针,画图理解）： 1234567891011121314151617181920public class Solution &#123; /** * * @param n int整型 * @return int整型 */ public int climbStairs (int n) &#123; if(n&lt;=2)&#123; return n; &#125; int res = 2; int jump = 1 ,tmp; while((n--)&gt;2)&#123; tmp = res; res += jump; jump = tmp; &#125; return res; &#125;&#125; 题2 格雷码 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。 格雷编码序列必须以 0 开头。 格雷码n位,也就是说有2^n(1&lt;&lt;n)个数字。 下面代码可以用公式算出n个数字中的第i个格雷码序列的元素，(i标识这组格雷码编码系统中的第i个元素）。 格雷码的手动计算过程和公式计算验证 1234567891011public class Solution &#123; public ArrayList&lt;Integer&gt; grayCode (int n) &#123; ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); int sum = 1&lt;&lt;n; //这个系统中的数字个数 for(int i=0;i&lt;sum;i++)&#123; list.add((i&gt;&gt;1)^i); &#125; return list; &#125;&#125; 其他解法 题3 反转整数 将给出的整数x翻转。例1:x=123，返回321例2:x=-123，返回-321 你有思考过下面的这些问题么？ 如果整数的最后一位是0，那么输出应该是什么？比如10,100你注意到翻转后的整数可能溢出吗？假设输入是32位整数，则将翻转10000000003就会溢出，你该怎么处理这样的样例？抛出异常？这样做很好，但是如果不允许抛出异常呢？这样的话你必须重新设计函数（比如添加一个额外的参数）。 这题牛客的测试用例不完整！ 提交时上Leetcode。 一开始我写的代码如下：考虑到了溢出情况的处理，如果结果溢出了，就返回0。在leetcode提交还是不行，这是因为当x=Integer.MIN_VALUE时，-x的值是Interger.MAX_VALUE+1，对于int类型来说，这就溢出了！（同样的，计算pow(x,n)那题也会有这样的情况，注意避免！） 1234567891011121314151617class Solution &#123; public int reverse(int x) &#123; if(x&gt;=0)&#123; long res = 0; while(x!=0)&#123; res *= 10; res += (x%10); x/=10; &#125; if(res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE) return 0; return (int)res; &#125; //如果小于0 return -reverse(-x); //有问题！！当x=Integer.MIN_VALUE调用reverse就溢出了int。 &#125;&#125; 修正后： 12345678910111213class Solution &#123; public int reverse(int x) &#123; long res = 0; while(x!=0)&#123; res *= 10; res += (x%10); x/=10; &#125; if(res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE) return 0; return (int)res; &#125;&#125; 在Leetcode看到一个很妙的方法： 123456789101112public int reverse(int x) &#123; int ans = 0; while (x != 0) &#123; if ((ans * 10) / 10 != ans) &#123; //如果*10再/10后不等于自己，就说明*10是溢出了 ans = 0; break; &#125; ans = ans * 10 + x % 10; x = x / 10; &#125; return ans;&#125; ansx10未溢出时, ansx10个位为0, x%10的取值范围是0~9, 故ans*10 + x%10一定没有进位, 故不会溢出，所以就只要考虑ansx10这部分是否溢出就行了。 20200604 多云坚持每日刷3题已经：22天。 今天刷了三题动态规划。如果说21天养成一个习惯，刷题这个习惯已经养成了哈哈哈。 题1 unique-paths 一个机器人在m×n大小的地图的左上角（起点，下图中的标记“start”的位置）。 机器人每次向下或向右移动。机器人要到达地图的右下角。（终点，下图中的标记“Finish”的位置）。 可以有多少种不同的路径从起点走到终点？ 递归解法： 1234567891011public class Solution &#123; public int uniquePaths (int m, int n) &#123; return dp(1,1,m,n); &#125; public int dp(int r,int c,int m,int n)&#123; if(r==m || c==n)&#123; return 1; &#125; return dp(r+1,c,m,n)+dp(r,c+1,m,n); //分别表示向下走、向右走 &#125;&#125; 动态规划： 1234567891011121314151617181920public class Solution &#123; public int uniquePaths (int m, int n) &#123; int dp[][] = new int [m][n]; //最后一列初始化为1 for(int i=0;i&lt;m;i++)&#123; dp[i][n-1] = 1; &#125; //最后一行初始化为1 for(int i=0;i&lt;n;i++)&#123; dp[m-1][i] = 1; &#125; for(int i=m-2;i&gt;=0;i--)&#123; for(int j = n-2;j&gt;=0;j--)&#123; dp[i][j] = dp[i+1][j] + dp[i][j+1]; &#125; &#125; return dp[0][0]; &#125; &#125; 题2 unique-paths-ii递归解法未AC 12345678910111213141516171819202122232425！！有误import java.util.*;public class Solution &#123; /** * * @param obstacleGrid int整型二维数组 * @return int整型 */ public int uniquePathsWithObstacles (int[][] obstacleGrid) &#123; if(obstacleGrid==null || obstacleGrid[0]==null ) return 0; return dp(0,0,obstacleGrid); &#125; public int dp(int r,int c,int [][]obstacleGrid)&#123; if(r==obstacleGrid.length-1 || c==obstacleGrid[0].length-1)&#123; //边界返回1 return obstacleGrid[r][c]^1; &#125; if(obstacleGrid[r][c]==1)&#123; //路障返回0 return 0; &#125; return dp(r+1,c,obstacleGrid)+dp(r,c+1,obstacleGrid); &#125;&#125; 动态规划:成功AC 注意dp数组的最后一列和最后一行的初始化！！ 1234567891011121314151617181920212223242526272829public class Solution &#123; public int uniquePathsWithObstacles (int[][] obstacleGrid) &#123; if(obstacleGrid==null || obstacleGrid[0]==null ) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int dp[][] = new int[m][n]; boolean obstacleFlag = false; //标记是否出现了障碍，没必要！ for(int i=m-1;i&gt;=0;i--)&#123; //初始化最后一列 if(obstacleGrid[i][n-1] == 1)&#123; obstacleFlag = true; &#125; dp[i][n-1] = obstacleFlag?0:1; &#125; obstacleFlag = false; for(int i=n-1;i&gt;=0;i--)&#123; //初始化最后一行 if(obstacleGrid[m-1][i] == 1)&#123; obstacleFlag = true; &#125; dp[m-1][i] = obstacleFlag?0:1; &#125; for(int i=m-2;i&gt;=0;i--)&#123; for(int j=n-2;j&gt;=0;j--)&#123; dp[i][j] = obstacleGrid[i][j]==1?0:dp[i+1][j]+dp[i][j+1]; &#125; &#125; return dp[0][0]; &#125;&#125; 上面的代码标记了最后一行和最后一列是否出现了障碍，其实没必要，直接break就好了。 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Solution &#123; /** * * @param obstacleGrid int整型二维数组 * @return int整型 */ public int uniquePathsWithObstacles (int[][] obstacleGrid) &#123; if(obstacleGrid==null || obstacleGrid[0]==null ) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int dp[][] = new int[m][n]; for(int i=m-1;i&gt;=0;i--)&#123; //初始化最后一列 if(obstacleGrid[i][n-1] == 1)&#123; break; &#125; dp[i][n-1] = 1; &#125; for(int i=n-1;i&gt;=0;i--)&#123; //初始化最后一行 if(obstacleGrid[m-1][i] == 1)&#123; break; &#125; dp[m-1][i] = 1; &#125; for(int i=m-2;i&gt;=0;i--)&#123; for(int j=n-2;j&gt;=0;j--)&#123; dp[i][j] = obstacleGrid[i][j]==1?0:dp[i+1][j]+dp[i][j+1]; &#125; &#125; return dp[0][0]; &#125;&#125; 题3 minimum-path-sum 给定一个由非负整数填充的m x n的二维数组，现在要从二维数组的左上角走到右下角，请找出路径上的所有数字之和最小的路径。注意：你每次只能向下或向右移动。 方便起见，我直接把grid作为dp数组了，修改了grid这个二维数组的值，实际开发中不要这样做，(调用了一个函数直接把输入改了..)。 时间复杂度是O(m*n),空间复杂度都是O(1) 123456789101112131415161718public class Solution &#123; public int minPathSum (int[][] grid) &#123; if(grid ==null || grid[0]==null) return 0; int m = grid.length,n=grid[0].length; for(int i = n-2; i&gt;=0; i--)&#123; //初始化最后一行 grid[m-1][i] += grid[m-1][i+1]; &#125; for(int i = m-2; i&gt;=0; i--)&#123; //初始化最后一列 grid[i][n-1] += grid[i+1][n-1]; &#125; for(int i = m-2; i&gt;=0; i--)&#123; for(int j=n-2; j&gt;=0;j--)&#123; grid[i][j] += Math.min(grid[i+1][j],grid[i][j+1]); &#125; &#125; return grid[0][0]; &#125;&#125; 20200603 雨坚持每日刷3题已经：21天。 今日tag：分治。 题1 sqrtx 实现函数 int sqrt(int x). 计算并返回x的平方根 思路：二分搜索。 复杂度O(logn)，注意不能用mid*mid 和x比较，要用和mid和x/mid比较，否则会溢出！ 如果mid == x/mid，直接返回 如果mid &gt; x/mid ，(mid*mid&gt;x)， 1234567891011121314151617181920public class Solution &#123; public int sqrt (int x) &#123; int begin = 1; int end = x; int mid = 0; while(begin&lt;=end)&#123; mid = (end-begin)/2+begin; if(mid==x/mid)&#123; return mid; &#125;else if(mid &lt; x/mid)&#123; begin = mid+1; if((mid+1)&gt;x/(mid+1)) return mid; &#125;else&#123; end = mid -1; if((mid-1)&lt;x/(mid-1)) return mid-1; &#125; &#125; return 0; &#125;&#125; 上面的判断条件不太优雅（且判断条件太多效率也有影响），回想一下二分查找，如果找到了就返回元素下标，如果没找到就返回其应该插入的位置的下标（begin），而这里可以理解成返回根号x插入下标的前一个坐标(比如说x=2，根号x的二分查找范围是[1,2]，可以理解成把根号2也就是1.4插入位置下标1的前一位)，所以可以直接返回begin-1，上面的代码能简化成： 12345678910111213141516171819public class Solution &#123; public int sqrt (int x) &#123; int begin = 1; int end = x; int mid = 0; while(begin&lt;=end)&#123; mid = (end-begin)/2+begin; if(mid==x/mid)&#123; return mid; &#125;else if(mid &lt; x/mid)&#123; begin = mid+1; &#125;else&#123; end = mid -1; &#125; &#125; return begin-1; &#125;&#125; 题2 【待优化】 跳跃游戏 给出一个非负整数数组，你最初在数组第一个元素的位置 数组中的元素代表你在这个位置可以跳跃的最大长度 判断你是否能到达数组最后一个元素的位置 例如 A =[2,3,1,1,4], 返回 true. A =[3,2,1,0,4], 返回 false. 写的时候抱着试一试的心态，写完还一次过了（牛客）。 关键是要能理解：最远能到达某个位置，就一定能到达它前面的任何位置，所以可以用贪心，每次都选择最优的跳。 如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。 如果可以一直跳到最后，就成功了。 123456789101112131415161718192021222324252627282930import java.util.*;public class Solution &#123; public boolean canJump (int[] A) &#123; int cur = 0; while(cur &lt; A.length-1)&#123; if(cur+A[cur] &gt;= A.length-1) //防止调用bestJumpStep()越界，要先判断一次 return true; int step = bestJumpStep(cur,A); if(step==0) //如果“跳不动了” return false; cur+=step; &#125; return true; &#125; //计算这一次要跳几步是最优解,cur:当前下标 //比如说 2,3，1,返回1 public int bestJumpStep(int cur,int [] A)&#123; int step=0,maxDistance = 0; for(int i=1;i&lt;=A[cur];i++)&#123; //最少跳1步，最多跳A[cur]步 if(i+A[cur+i]&gt;maxDistance)&#123; step = i; maxDistance = i+A[cur+i]; //更新最大值 &#125; &#125; return step; &#125;&#125; https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode-solution/ 看看人家的代码： 12345678910class Solution &#123; public boolean canJump(int[] nums) &#123; int k = 0; for (int i = 0; i &lt; nums.length; i++)&#123; if (i &gt; k) return false; k = Math.max(k, i + nums[i]); &#125; return true; &#125;&#125; 题3 可能重复的全排列 给出一组可能包含重复项的数字，返回该组数字的所有排列 例如； [1,1,2]的排列如下：[1,1,2],[1,2,1], [2,1,1]. 这题的难点在于避免重复：先对数组num进行排序，保证重复数字相邻，这样在后续操作中，利用条件，若后一数与前一数相等，则不处理 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Arrays;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; Arrays.sort(num); //先排序 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(num.length); boolean visited[] = new boolean[num.length]; dfs(num,res,path,0,visited); return res; &#125; public void dfs(int [] num,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; path,int cur,boolean visited[])&#123; if(cur==num.length)&#123; res.add(new ArrayList(path)); return; &#125; //每个元素只能用一次 for(int i=0;i&lt;num.length;i++)&#123; if(!visited[i])&#123; if(i&gt;=1 &amp;&amp; num[i]==num[i-1] &amp;&amp; visited[i-1])&#123; //这两行用来避免重复！ 三个判断条件缺一不可 continue; &#125; path.add(num[i]); visited[i] = true; dfs(num,res,path,cur+1,visited); path.remove(path.size()-1); visited[i] = false; &#125; &#125; &#125;&#125; 1234if(i&gt;=1 &amp;&amp; num[i]==num[i-1] &amp;&amp; !visited[i-1])&#123; //这两行用来避免重复！ 三个判断条件缺一不可 continue;&#125; 这里的第三个条件不好理解：可以参考下图，只有当 i-1 这个元素是被选择了的时候，才需要剪枝，如果不加第三个条件，会出现下图的错误情况。 image-20200603123358618 20200602 晴坚持每日刷3题已经：20天。 今天把回溯做完了，开始学习贪心算法，今天看了小码哥讲的贪心，01背包问题。 题1 跳跃最少步数 给出一个非负整数数组，你最初在数组第一个元素的位置 数组中的元素代表你在这个位置可以跳跃的最大长度 你的目标是用最少的跳跃次数来到达数组的最后一个元素的位置 例如 给出数组 A =[2,3,1,1,4] 最少需要两次才能跳跃到数组最后一个元素的位置。（从数组下标为0的位置跳长度1到达下标1的位置，然后跳长度3到数组最后一个元素的位置） 思路：贪心。每次跳到 本次跳跃距离+潜力最大的的位置（多看一步）。 下次做题的测试用例：[2,3,1,1,4]；[2,1]；[3,2,1] 做题情况： 首次提交30%，看了未通过的测试用例后，发现自己少了一个判断条件导致了数组越界的情况，改了后AC60%。 图解 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Solution &#123; /** * * @param A int整型一维数组 * @return int整型 */ //贪心：每一步都跳到“潜力”最大的元素 public int jump (int[] A) &#123; //从A[0] 开始 跳到A[length-1] int cur = 0; //当前位置 int cnt = 0; //记录跳跃次数 int distance = 0, max=0,step=0; while(cur &lt; A.length-1)&#123; distance = A[cur]; max = 0; step = A[cur]; for(int i = 1; i&lt;= A[cur] &amp;&amp; cur+i &lt; A.length; i++)&#123; distance = i+A[cur+i]; //此次跳的步长+到达位置的跳跃最大长度 if(distance&gt;max)&#123; max = distance; step = i; //记录跳几步是最优解 &#125; &#125; //跳step步 cur = cur+step; cnt++; &#125; return cnt; &#125;&#125; 正确代码： 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Solution &#123; /** * * @param A int整型一维数组 * @return int整型 */ //贪心：每一步都跳到“潜力”最大的元素 public int jump (int[] A) &#123; //从A[0] 开始 跳到A[length-1] int cur = 0; //当前位置 int cnt = 0; //记录跳跃次数 int distance = 0, max=0,step=0; while(cur &lt; A.length-1)&#123; distance = A[cur]; max = 0; step = 0; for(int i = 1; i&lt;= A[cur]; i++)&#123; if(cur+i &gt;= A.length-1)&#123; //如果cur+i越界，说明再跳一次就到了，这个判断很关键，否则cur+i可能越界 return cnt+1; &#125; distance = i+A[cur+i]; //此次跳的步长+到达位置的跳跃最大长度 if(distance&gt;max)&#123; max = distance; step = i; //记录跳几步是最优解 &#125; &#125; //跳step步 cur = cur+step; cnt++; &#125; return cnt; &#125;&#125; 题2 最大子数组（最大连续子序列） 请计算给出的数组（至少含有一个数字）中具有最大和的子数组（子数组要求在原数组中连续） 例如：给出的数组为[−2,1,−3,4,−1,2,1,−5,4], 子数组[−2,1,−3,4,−1,2,1,−5,4],具有最大的和:6. 拓展： 如果你已经提出了O(n)的解决方法，请尝试使用分治算法来解决这道题。这道题分治的解法更巧妙一些。 一气呵成，一次AC，感动中国。 这道题目可以用DP做，但是题目点名用分治法了，就试试看 T(n) = 2T(n/2) + O(N)，时间复杂度是O(nlogn)。 123456789101112131415161718192021222324252627public class Solution &#123; /** * * @param A int整型一维数组 * @return int整型 */ public int maxSubArray (int[] A) &#123; return maxSubArray(A,0,A.length-1); &#125; public int maxSubArray(int [] A,int begin,int end)&#123; if(begin==end) return A[begin]; int mid = (end-begin)/2+begin; int leftMax = maxSubArray(A,begin,mid); int lmax=0,rmax=0,lsum=0,rsum=0,middleMax = A[mid]; for(int i=mid-1;i&gt;=begin;i--)&#123; lsum+=A[i]; if(lsum&gt;lmax) lmax = lsum; &#125; for(int i=mid+1;i&lt;=end;i++)&#123; rsum+=A[i]; if(rsum&gt;rmax) rmax = rsum; &#125; middleMax = middleMax+lmax+rmax; int rightMax = maxSubArray(A,mid+1,end); return Math.max(Math.max(leftMax,rightMax),middleMax); &#125;&#125; 题3 合法的BST 输入: 5 / 1 4 / 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 注意：不允许元素重复，比如说[1，1]返回false。 这是之前做的，没做出的题。 使用带上下界限的递归很容易解决! 注意：Integer.MIN_VALUE-1 = Integer.MAX_VALUE！！！ 所以要转成long类型后再减1。 这样做超越双100%。 12345678910111213class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return isValidBST(root,(long)Integer.MIN_VALUE-1,(long)Integer.MAX_VALUE+1); &#125; //root.val必须大于最小限制minLimit且小于最大限制maxLimit public boolean isValidBST(TreeNode root,long minLimit,long maxLimit)&#123; if(root==null) return true; if(root.val &gt;= maxLimit || root.val &lt;= minLimit )&#123; return false; &#125; return isValidBST(root.left,minLimit,root.val) &amp;&amp; isValidBST(root.right,root.val,maxLimit); &#125;&#125; 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 [1,2,5],11 输出：3 [18,49,8,48] 50, 输出 :5 （4X8+1X18） 20200601 晴坚持每日刷3题已经：19天。 六月的第一天，今天仍然是复习回溯算法。 题1 二叉树中和为某一值的路径 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 图解回溯思路 一开始的做法如下，提交发现通过率0% 12345678910111213141516171819202122232425262728错误代码！！错误提示：path是引用、重复结果！import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); if(root==null)&#123; return res; &#125; findPath(root,target,path,res); return res; &#125; public void findPath(TreeNode root,int target,ArrayList&lt;Integer&gt; path,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)&#123; if(root==null)&#123; //递归到叶子结点 if(target==0)&#123; //如果=0 res.add(path); &#125; return; &#125; path.add(root.val); findPath(root.left,target-root.val,path,res) findPath(root.right,target-root.val,path,res); path.remove(path.size()-1); &#125;&#125; 分析：测试用例 单节点树 1，1 手动调试发现会有重复结果！ 返回值是[[1],[1]]，因为左右子树重复计算了，加了判断条件，结果还是0%正确，看未通过的测试用例，发现我的返回结果是[],这个时候还没没意识到什么，后面才意识到是path是引用的问题，最后会回退到path里啥都没有的状态 ，而path是引用，每次递归实际上只是修改堆内存的同一个对象! 正确代码如下： 12345678910111213141516171819202122232425262728import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); if(root==null)&#123; return res; &#125; findPath(root,target,path,res); return res; &#125; public void findPath(TreeNode root,int target,ArrayList&lt;Integer&gt; path,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)&#123; if(root==null)&#123; //递归到叶子结点 if(target==0)&#123; //如果=0 res.add(new ArrayList(path)); &#125; return; &#125; path.add(root.val); findPath(root.left,target-root.val,path,res); if(root.left!=null)&#123; //这里很关键、一定要写，不然会有重复结果！ findPath(root.right,target-root.val,path,res); &#125; path.remove(path.size()-1); &#125;&#125; 下次做题提示：引用、避免左右子树都为null的重复结果。 题2 机器人的运动范围 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：做题前思考，一开始我想，不是直接两层for循环就可以判断每个格子能否容纳，后来一想才反应过来，可能中间有一行断了，机器人到不了，这样的话，更到不了后面的行了。 if(visited[r][c+1]) backtrace(r,c+1,threshold,rows,cols,visited); //走右格子 if(visited[r][c-1]) backtrace(r,c-1,threshold,rows,cols,visited); //走左格子 if(visited[r-1][c]) backtrace(r-1,c,threshold,rows,cols,visited); //走上格子 if(visited[r+1][c]) backtrace(r+1,c,threshold,rows,cols,visited); //走下格子123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; int count; public int movingCount(int threshold, int rows, int cols) &#123; boolean visited[][] = new boolean[rows][cols]; backtrace(0,0,threshold,rows,cols,visited); return this.count; &#125; public void backtrace(int r,int c,int threshold, int rows, int cols,boolean visited[][])&#123; if(r&lt;0 || r&gt;=rows || c&lt;0 || c&gt;=cols)&#123; return; &#125; visited[r][c] = true; //访问标记置为true if(canJoin(r,c,threshold))&#123; this.count++; &#125;else&#123; //否则这条路就断了 return; &#125; if(!hasVisited(r,c+1,visited)) backtrace(r,c+1,threshold,rows,cols,visited); //走右格子 if(!hasVisited(r,c-1,visited)) backtrace(r,c-1,threshold,rows,cols,visited); //走左格子 if(!hasVisited(r-1,c,visited)) backtrace(r-1,c,threshold,rows,cols,visited); //走上格子 if(!hasVisited(r+1,c,visited)) backtrace(r+1,c,threshold,rows,cols,visited); //走下格子 &#125; //判断是否访问过了某个格子,注意越界的情况 public boolean hasVisited(int r, int c,boolean visited[][])&#123; return r&gt;=0 &amp;&amp; r&lt;visited.length &amp;&amp; c&gt;=0 &amp;&amp; c&lt;visited[0].length &amp;&amp; visited[r][c]; &#125; //判断机器人能否进入(row,col)这个格子 public boolean canJoin(int r,int c,int threshold)&#123; int sum = 0 ; while(r!=0)&#123; sum = sum + r%10; r = r/10; &#125; while(c!=0)&#123; sum = sum + c%10; c = c/10; &#125; return sum&lt;=threshold; &#125;&#125; 对上面的代码中 if(!hasVisited(r+1,c,visited)) 的改进： 1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; int count; public int movingCount(int threshold, int rows, int cols) &#123; boolean visited[][] = new boolean[rows][cols]; backtrace(0,0,threshold,rows,cols,visited); return this.count; &#125; public void backtrace(int r,int c,int threshold, int rows, int cols,boolean visited[][])&#123; if(r&lt;0 || r&gt;=rows || c&lt;0 || c&gt;=cols || visited[r][c])&#123; //注意最后一个条件！ return; &#125; visited[r][c] = true; if(canJoin(r,c,threshold))&#123; this.count++; &#125;else&#123; //否则这条路就断了 return; &#125; backtrace(r,c+1,threshold,rows,cols,visited); //走右格子 backtrace(r,c-1,threshold,rows,cols,visited); //走左格子 backtrace(r-1,c,threshold,rows,cols,visited); //走上格子 backtrace(r+1,c,threshold,rows,cols,visited); //走下格子 &#125; //判断机器人能否进入(row,col)这个格子 public boolean canJoin(int r,int c,int threshold)&#123; int sum = 0 ; while(r!=0)&#123; sum = sum + r%10; r = r/10; &#125; while(c!=0)&#123; sum = sum + c%10; c = c/10; &#125; return sum&lt;=threshold; &#125;&#125; 写完代码的体会：利用递归，回溯。 上述代码还可以进一步改进：不用成员变量count，直接让backtrace返回值是int。 为什么不推荐成员变量作为返回结果： 一个对象重复调用方法会覆盖 内存不会释放，容易造成内存溢出。 题3 待解决 矩阵中的路径在牛客网做的这题，卡了很久，先睡觉了","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"}]},{"title":"数据结构与算法——排序学习笔记","date":"2020-05-24T02:55:31.000Z","path":"2020/05/24/数据结构与算法——排序学习笔记/","text":"本篇博客是记录我学习排序算法的学习笔记，目前更新到了几种常用的、基于比较的排序：冒泡、选择、堆、插入、归并、快速6种排序方式，还有一些排序方式希尔排序、计数排序、基数排序、桶排序，待更。 每种排序算法的介绍都从排序思路、实例计算、代码实现、算法分析几个角度展开。 另外请注意本文提到的排序全都默认是升序排序。 冒泡排序（Bubble Sort）排序思路每一轮冒泡过程依次比较每两个相邻的元素，将值大的元素交换到右边，经过一轮冒泡过程后，最大的元素就被交换到了最后一位，进行下一轮冒泡过程时，忽略上一轮最后一位的元素，循环直到所有元素有序（也就是经过了n-1轮冒泡）。 实例计算下图给出了使用冒泡排序对数组{3，2，4，1}进行排序的过程。 冒泡排序的实例计算过程 以上图的第一轮冒泡为例讲解详细冒泡过程：首先进行比较①：比较3和2，发现3比2大，所以交换，数组变成2，3，4，1；然后进行比较②，注意此时第二个元素已经变成3了，所以这里比较②比较的是3和4，发现3比4小，所以无需交换，数组仍然是2，3，4，1；然后进行比较③，发现4比1大，所以交换，数组变成了2，3，1，4。 经过第一轮排序后，数组中最大的元素放到了数组的末尾，所以第二次冒泡不用再考虑这个元素。也就是说，第二次冒泡的只需要进行两次比较了，以此类推。 代码实现1234567891011121314/** * 冒泡排序的实现 * @param array 需要升序排序的整型数组 */public static void bubbleSort(Integer[] array) &#123; for (int end = array.length - 1; end &gt; 0; end--) &#123; for (int begin = 1; begin &lt;= end; begin++) &#123; //这相邻的两个元素中，如果前面的元素比后面的元素大，交换 if (array[begin] &lt; array[begin - 1]) &#123; swap(array, begin, begin - 1); &#125; &#125; &#125;&#125; 算法分析时间复杂度：O(n^2)。 针对冒泡排序还有一种针对最后一些元素局部有序的优化思路，如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数，这里不展开了。 空间复杂度：O(1) 稳定性: 稳定 选择排序（Selection Sort）排序思路每轮选择遍历数组中的未排序部分选出最大的数，与数组中最后一个未排序的元素交换位置，如此一来，没经过一轮选择，最大的数字就被交换到了未排序元素的最后，这个元素就可以被认为是有序的了，下一轮选择时忽略这个已排序的数字，循环直到所有元素有序（也就是经过了n-1轮选择）。 实例计算下图给出了使用选择排序对数组{3，2，4，1}进行排序的过程。 选择排序的实例计算过程 以上图第一轮选择为例：遍历发现4是最大的元素，就交换元素4和末尾元素1的位置，得到3，2，1，4。 代码实现123456789101112131415161718/** * 选择排序的实现 * * @param array 需要升序排序的整型数组 */public static void selectionSort(Integer[] array) &#123; //end记录当前数组中未排序部分的最后一个元素的下标 for (int end = array.length - 1; end &gt; 0; end--) &#123; //记录这一轮选择中的最大元素的下标 int indexOfMax = 0; for (int i = 1; i &lt;= end; i++) &#123; if (array[i] &gt; array[indexOfMax]) &#123; indexOfMax = i; &#125; swap(array, indexOfMax, end); &#125; &#125;&#125; 算法分析时间复杂度：O（n^2），选择排序的流程和冒泡排序的流程类似，都是每经过一轮，可以获得数组中当前未排序部分的最大元素，但是可以看到，选择排序的交换(swap)次数远小于冒泡排序的交换次数，所以平均性能会更好一点。 空间复杂度：O（1） 稳定性： 不稳定。 需要注意选择排序是不稳定的！比如说数组是： 3a ,2a,2b,3b。按照上面选择排序的代码来执行， 经过第一轮选择后变成了：3b,2a,2b,3a,而经过第一轮选择后，3a就固定在了最后一位，也就是说3a的位置本来在3b的前面，经过排序后，位置变成了在3b的后面，所以说这种排序算法是不稳定的。 探究其原因，这是因为当前最大值初始是3a（indexOfMax=0），即使后面遇到了3b，因为不满足array[i] &gt; array[indexOfMax]条件，最大值依旧被认为是3a而不是3b。这时候你可能会想到，把代码中的判断条件改成 array[i] &gt; =array[indexOfMax]，如此一来，第一轮选择的结果就变成了：3a,2a,2b,3b，这样的话3a和3b的相对顺序就不会被破坏,但是别着急下结论，以此类推， 第二轮选择的结果是：2b,2a,3a,3b,第三轮的选择是：2b,2a,3a,3b。选择排序结束，可以看到2b和2a的相对顺序发生了改变，也就是说，即使判断条件改了，还是可能不稳定！ 堆排序 (Heap Sort)排序思路其实堆排序的思路和选择排序的思路类似：也是想办法先从数组中未排序部分找出最大值，然后放到数组的末尾，只不过找未排序部分中的最大值的策略不一样：选择排序中，由于未排序部分没有什么特殊的性质，只能直接通过遍历一遍，来找到最大值，显然这一过程的时间复杂度是O(n)，而在堆排序中巧妙地用到了最大堆的特性，把数组中未排序部分建成一个最大堆，这样找最大元素值的复杂度就变成了O（1）（不过为维持最大堆的特性就需要额外的O(logn)开销）。 如果对最大堆的含义和性质、建立过程还不清楚的话，可以参考我的这篇博客： 数据结构与算法—二叉堆学习笔记。 总体来说，堆排序的排序流程是这样的： 第一步：对需要排序的数组原地建最大堆(heapify操作)。 这一步可以通过自下而上（从最后一个非叶子结点开始递减至根节点）的下沉操作完成，时间复杂度是O(n)。 第二步：开始进行选择未排序部分中的最大元素操作，并交换到未排序部分的最后，循环下面三步操作直到堆的大小减小为1。 2.1 交换堆顶元素和堆中的最后一个元素。 2.2 堆的大小减小1，也就是说，上一步操作被放到最后的元素被排除在堆外。 2.3 对现在的堆顶元素（也就是空降上来的、2.1步中的最后一个元素）进行sinkDown下沉操作。 可以看到，每进行一轮第二步的操作（2.1、2.2、2.3），就会选出未排序部分中的最大值放到未排序数组的末尾，这样一来最后一个元素就成为有序的了，这也是为什么堆的size减小的原因，因为最大堆只维护未经排序的部分。 实例计算下图给出了使用堆排序对数组{3，2，4，1}进行排序的过程。 堆排序的实例计算过程 注意：图上红色结点是已经不属于当前堆的结点，因为它们已经是排序了的，而堆中只会保留当前所有未被排序的部分。 代码实现这里给出了堆排序要用到的的核心方法：siftDown下沉操作，在堆排序的第一步建堆和第二步排序中都会用到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** 堆排序的实现 * @param array 要排序的整型数组 */ public static void heapSort(Integer array[]) &#123; //堆排序的第一步：在array数组上原地建堆 heapify(array); //记录当前未排序部分构成的堆的大小，初始大小为待排序数组的长度 int heapSize = array.length; //堆排序的第二步: while (heapSize &gt; 1) &#123; swap(array, 0, heapSize - 1); heapSize--; siftDown(array, heapSize, 0); &#125; &#125;/** 最大堆的下沉操作 * @param heap 存储最大堆的数组 * @param size 当前最大堆的大小 * @param index 要下沉的结点在数组中的下标 */ public static void siftDown(Integer[] heap, int size, int index) &#123; //2*i+1&lt;size说明 int leftChildIndex = 2 * index + 1; //记录index结点的左右孩子中较大的孩子的下标 int bigChildIndex; while (leftChildIndex &lt; size) &#123; //大孩子下标默认为左孩子下标 bigChildIndex = leftChildIndex; //如果右孩子存在且右孩子的值大于左孩子 if (leftChildIndex + 1 &lt; size &amp;&amp; heap[leftChildIndex + 1] &gt; heap[leftChildIndex]) &#123; bigChildIndex = leftChildIndex + 1; &#125; //然后当前结点和大孩子进行比较,如果小于大孩子需要交换 if (heap[index] &gt;= heap[bigChildIndex]) &#123; break; &#125; swap(heap, index, bigChildIndex); index = bigChildIndex; leftChildIndex = 2 * index + 1; &#125; &#125; /**把一个任意整型数组建成最大堆（利用数次下沉操作） * @param array 要被建立成最大堆的整型数组 */ public static void heapify(Integer[] array) &#123; //从最后一个非叶子结点开始下沉操作 for (int i = array.length / 2; i &gt;= 0; i--) &#123; //array表示堆存储的数组，array.length表示堆的大小 siftDown(array, array.length, i); &#125; &#125; 算法分析时间复杂度：第一步通过自下而上的下沉的建堆过程的时间复杂度是O(n)，而第二步每一轮（2.1、2.2、2.3的三个操作）时间复杂度是O(logn)，第二部会循环次数约为n次（实际上是n-1次，每次选个未排序中的最大元素使其有序），所以堆排序第二步的时间复杂度是n*O(logn)。所以总的来说，时间复杂度是O(n)+O(nlogn)。 综上所述，堆排序最好最坏时间都是复杂度：O(nlogn)，说的更精确一点就是O(n)+O(nlogn)。 空间复杂度：O(1) 稳定性：不稳定。 比如：5,4a,4b,4c: 第一轮选择出5作为最大元素，与4c交换，然后4c就成为堆顶了，无需调整，4c会成为第二个被选择的元素。 插入排序（Insertion Sort）排序思路插入排序的排序思路和平时打扑克牌时理牌一样：打牌时，我们在左手拿着已经理好顺序从小到大的牌，右手从桌面拿了一张大小不确定的牌，然后把它插入到左手牌堆的合适的位置使得左手的所有牌仍然是有序的，重复直到牌抓完了，最后左手的牌肯定是有序的。这里很形象地类比了插入排序的要素：插入排序将要排序的序列分成两部分：一部分是已排序部分，另外一部分是未排序部分，然后将未排序部分的第一个元素插入到已排序部分的合适位置，这样的话这个元素也成为已排序的了，直到未排序部分为空，排序完成。 实例计算 堆排序的实例计算过程 如上图，插入排序的每一轮都会选出第一个未排序的数字，将其插入到左边已排序部分的合适位置。 代码实现1234567891011121314/** * 插入排序的实现 * @param array 需要排序的数组 */public static void insertSort(Integer array[]) &#123; //begin为第一个未排序元素的下标,此下标会不断后移一位直到所有元素都排序 for (int begin = 1; begin &lt; array.length; begin++) &#123; int i = begin; while (i &gt;= 1 &amp;&amp; array[i] &lt; array[i - 1]) &#123; swap(array, i, i - 1); i--; &#125; &#125;&#125; 上面的插入排序的代码可以优化一下：先将待插入的元素备份,确定了位置再把待插入元素插入。 1234567891011121314151617181920/** * 插入排序的实现（优化后） * @param array 需要排序的数组 */public static void insertSort2(Integer array[]) &#123; //begin为第一个未排序元素的下标,此下标会不断后移一位直到所有元素都排序 for (int begin = 1; begin &lt; array.length; begin++) &#123; int i = begin; //iValue备份了要插入的元素 int iValue = array[i]; //比较待插入元素与array[i - 1] while (i &gt;= 1 &amp;&amp; iValue &lt; array[i - 1]) &#123; array[i] = array[i-1]; i--; &#125; //确定了插入位置后一步到位完成赋值操作 array[i] = iValue; &#125;&#125; 这样一来，能减少中间过程的赋值次数，这个优化思路其实很多地方都有用到，比如说二叉堆的上浮和下沉操作。 插入排序还有一种优化方式：结合二分查找确定待插入的那个元素在已排序部分的插入位置，这里就不展开了。 算法分析时间复杂度：最坏、平均时间复杂度是O(n^2)，最好时间复杂度是O(n)（也就是当待排序数组已经是升序的）。实际上，插入排序的算法时间复杂度和逆序对的数量成正比关系，逆序对的数量越多，插入排序的时间复杂度就越高，当逆序对数量很少、待排序数组几乎有序的情况下，插入排序甚至比快速排序还快。 空间复杂度：O(1) 稳定性：稳定 归并排序（Merge Sort)排序思路归并排序是典型的分治算法。分治算法的基本思路是把一个复杂的问题分成两个或更多的性质相同而规模更小的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 《算法导论》中将分治算法归纳为分解、解决、合并三个步骤，这三个步骤在归并排序中的是怎么体现的呢？ 分解：把原问题中对数组排序，分解成2个子问题——对数组的左半部分排序和对数组的右半部分排序。 解决：如果待排序数组的规模够小（只有一个元素），直接返回，否则继续分解成更小的子问题，递归解决。 合并：把两个子问题排序的结果合并，合并成有序数组。 实例计算 选择排序的实例计算过程 代码实现归并排序中最关键的就是把array[begin…mid] 和 array[mid+1…end]这两个已经有序的数组合并，也就是merge方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 归并排序的实现 * * @param array */public static void mergeSort(Integer array[]) &#123; mergeSort(array,0,array.length-1);&#125;/** * 归并排序的辅助函数 * @param array * @param begin * @param end */public static void mergeSort(Integer array[],int begin,int end)&#123; //如果不超过两个元素。 if(begin&gt;=end) &#123; return; &#125; int mid = (begin+end)/2; mergeSort(array,begin,mid); mergeSort(array,mid+1,end); merge(array,begin,mid,end);&#125;/** * 合并两个有序数组。注意这里说的两个有序数组只是逻辑上可以看作是两个有序数组，实际上它们存储在一个数组里 * 需要合并的数组分别是： array[begin...mid] 和 array[mid+1...end] */public static void merge(Integer array[],int begin,int mid,int end) &#123; Integer res [] = new Integer[end-begin+1]; int p=0,p1=begin,p2=mid+1; while(p1&lt;=mid &amp;&amp; p2&lt;=end)&#123; if (array[p1] &lt;= array[p2]) &#123; res[p++] = array[p1++]; &#125; else &#123; res[p++] = array[p2++]; &#125; &#125; //退出循环，说明有一个数组的全部元素都已经全部加入到res数组了,另一个数组的部分元素还没加入，就将其剩余元素都加入进来 while (p2 &lt;= end) &#123; res[p++] = array[p2++]; &#125; while (p1 &lt;=mid) &#123; res[p++] = array[p1++]; &#125; //复制res数组到array数组 for(int i=begin;i&lt;=end;i++)&#123; array[i] = res[i-begin]; &#125;&#125; 归并排序的merge方法有一个细节:需要进行merge操作的两组序列存储在同一个数组中，并且是挨在一起的。合并操作要开辟额外的空间，可以只开辟一个临时数组（用于保存左半边），然后直接在原数组修改。下面的代码时开辟了一整个数组然后复制：优化后的merge(只开辟左半部分的空间): 123456789101112131415161718192021222324252627/** * 合并两个有序数组。注意这里说的两个有序数组只是逻辑上可以看作是两个有序数组，实际上它们存储在一个数组里 * 需要合并的数组分别是： array[begin...mid] 和 array[mid+1...end] */public static void merge(Integer [] array,int begin,int mid,int end) &#123; Integer [] leftCopy = new Integer[mid-begin+1]; for(int i=begin;i&lt;=mid;i++)&#123; leftCopy[i-begin] = array[i]; &#125; int p=begin,p1=0,p2=mid+1; while(p1&lt;leftCopy.length &amp;&amp; p2&lt;=end)&#123; if (leftCopy[p1] &lt;= array[p2]) &#123; array[p++] = leftCopy[p1++]; &#125; else &#123; array[p++] = array[p2++]; &#125; &#125; //退出循环，说明有一个数组的全部元素都已经全部加入到res数组了,另一个数组的部分元素还没加入，就将其剩余元素都加入进来 while (p2 &lt;= end) &#123; array[p++] = array[p2++]; &#125; while (p1 &lt;leftCopy.length) &#123; array[p++] = leftCopy[p1++]; &#125;&#125; 其实merge方法还可以进一步优化：上面的代码中，每次调用merge方法，都会开辟一次左半边的数组，事实上我们可以只开辟一次（大小定为原数组的一半），也像array一样作为调用时的参数传入，这样的话从头到尾只需要用到一个长度为原数组一半的临时数组，这里就不展开了。 算法分析时间复杂度：归并排序是递归实现的，其递归表达式是T(n) =2*T(n/2)+O(n) （n&gt;=2），T(1)=O(1), 对应的时间复杂度是O(nlogn) 空间复杂度：因为进行合并操作时要用到临时数组存放左半边的有序数组，开辟了额外空间，归并排序的空间复杂度是O(n) 稳定性：稳定，归并排序分解和合并两个步骤中，，分解只是确定两个子数组的下标，合并操作时才会交换元素的位置，而需要合并的两个有序数组是原数组的左左边和右半边数组，只要保证如果左右数组有元素相等的情况下，左边的数组优先就能保证稳定。 比如说合并数组：1a,4, (左半边)| 1b,5。 合并结果是 1a,1b,4,5。 快速排序排序思路和归并排序，快速排序的思想也是分治。 快速排序的过程是： 1．先从数组中取出一个数作为基准数。 2．分区过程，将不小于基准数的数全放到它的右边，不大于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数。 实例计算 快速排序的实例计算过程 代码实现在实现快速排序时，最重要的方法就是partition方法，它的作用是选择一个基准点（我的代码中选择第一个元素作为基准点），然后以某种策略调整数组，用来把乱序数组划分成为3部分：所有元素值都不大于基准点的左半部分 | 基准点 | 所有元素值都不小于基准点右半部分，此方法的返回结果是调整后基准点的下标。 注意：调整数组来把基准点放在合适位置有多种不同的实现方式，所以partition方法也有多种不同的实现思路，不过其目的都是一样的。 快速排序的完整代码如下（分别给出了两种不同思路的partition实现）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public static void quickSort(Integer array[]) &#123; quickSort(array, 0, array.length - 1); &#125; /** * 对array[begin...end]进行排序 */ public static void quickSort(Integer array[], int begin, int end) &#123; if (end &lt;= begin) &#123; return; &#125; int mid = partition2(array, begin, end); quickSort(array, begin, mid); quickSort(array, mid + 1, end); &#125; /** * 元素array[begin]作为轴点，将轴点放在合适位置，使左边的元素全都不大于它，右边的元素全不小于它 * * @return 返回值是轴点插入位置的下标，调用者根据它可以将原数组划分成两个子数组 */ public static int partition(Integer array[], int begin, int end) &#123; //备份轴点值 int pivotValue = array[begin]; while (begin &lt; end) &#123; while (end &gt; begin &amp;&amp; array[end] &gt;= pivotValue) &#123; end--; &#125; //此时array[begin]的位置是无效元素（已经备份了） array[begin] = array[end]; while (begin &lt; end &amp;&amp; array[begin] &lt;= pivotValue) &#123; begin++; &#125; //此时array[end]的位置是无效元素（已经备份了） array[end] = array[begin]; &#125; //退出循环时，begin必然等于end，因为始终只有一个指针在移动 array[begin] = pivotValue; return begin; &#125;/*** partition的另一种实现思路*/ public static int partition2(Integer array[], int begin, int end) &#123; //备份轴点值 int pivotValue = array[begin]; int beginCopy = begin; while (begin &lt; end) &#123; while (end &gt; begin &amp;&amp; array[end] &gt;= pivotValue) &#123; end--; &#125; //一旦上一个while循环退出，说明 array[end] &lt; pivotValue 或者 begin==end while (begin &lt; end &amp;&amp; array[begin] &lt;= pivotValue) &#123; begin++; &#125; //一旦上一个while循环退出，说明 array[begin] &gt; pivotValue 或者 begin==end //到这里，说明array[end] &lt; pivotValue且array[begin] &gt; pivotValue 或者 begin==end。无论是那种情况，都可以交换下标begin、end对应的元素。 swap(array, begin, end); &#125; //交换 swap(array, beginCopy, begin); return begin; &#125; 算法分析时间复杂度：平均时间复杂度是O(nlogn)，最坏时间复杂度是O(n^2)。 理想情况下，我们希望每次经过partition操作之后，能将原数组划分成平均的两部分。这样一来，原问题也是被划分成两个规模相等的子问题（它们的规模都是原问题的一半），也就是说在左右平均的情况下，递归表达式是T(n)=2T(n/2)+O(n)，（后面的O(n)是执行partition操作的时间复杂度）,对应的时间复杂度是O(nlogn)。 而在最坏情况下，如果划分的左右数组元素数量极度不均匀（比如说选出的基准点始终是最大或最小值），递归表达式是T(n)=T(n-1)+O(n)，对应的时间复杂度是O(n^2)。为了降低最坏情况出现的概率，可以采取随机选择轴点元素的方式（写代码的时候仍旧可以选择第1个作为轴点元素，不过在此之前先随机挑一个元素和它互换位置）。 partition操作是O(n)级别的 空间复杂度：因为涉及到递归调用造成栈空间的使用，空间复杂度是O(logn) 稳定性：不稳定。 十大排序算法总结 算法 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 冒泡排序 O(n^2) O(n) O(n^2) O(1) 稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn) 不稳定 备注：上表中冒泡排序的最好时间复杂度是O(n)针对的是优化后的冒泡排序：优化的冒泡排序中每次冒泡过程会记录最后交换的位置，此优化对于最后一些元素已经局部有序的情况有效，当数组已经是有序状态，有最好的时间复杂度，为O(n)。","tags":[{"name":"置顶文章","slug":"置顶文章","permalink":"http://hfq123.github.io/tags/%E7%BD%AE%E9%A1%B6%E6%96%87%E7%AB%A0/"},{"name":"算法","slug":"算法","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法—二叉堆学习笔记","date":"2020-05-22T04:36:36.000Z","path":"2020/05/22/数据结构与算法—二叉堆学习笔记/","text":"本篇博客是我学习数据结构与算法的笔记，分享主题是「二叉堆」。 引入二叉堆是什么？以下给出一些二叉堆的定义： 堆（Heap）是一种树状的数据结构，它有一个重要性质：任意节点的值总是大于等于或小于等于子节点的值。 如果任意节点的值总是大于等于子节点的值，称为最大堆。 如果任意节点的值总是小于等于子节点的值，称为最小堆。 而二叉堆的逻辑结构就是一颗完全二叉树，由于完全二叉树的一些性质，代码实现时可以用数组存储，下文会详细介绍。 一个最大堆示例 为什么要引入二叉堆这个数据结构？ 想象这样一个场景：我们要设计一种数据结构，用来存放未知数量的整数，我们可以随时向其添加任意整数，在使用时,我们特别关注它的最大值，而不关心其他值, 除了添加元素操作之外，还有两个操作分别是：获取当前这个数据结构的最大值、删除最大值。 这个数据结构可以用线性表、BBST（如AVL、RBT）实现，它们的时间复杂度分析如下表： 数据结构 获取最大值时间复杂度 删除最大值时间复杂度 添加元素时间复杂度 有序的动态数组 O（1） O(1) O(n) 红黑树 O(logN) O(logN) O(logN) 针对此需求，有没有更优的数据结构？ 我们发现，无论是维护元素顺序的动态数组还是红黑树都考虑了整个数据结构的顺序。有序数组不用多说，至于红黑树，构建时也间接维护了每个元素之间大小关系，其中序遍历结果是有序的。 而在需求中，我们重点关注对象的是这个数据结构的最大值，不在乎其他元素的大小顺序，维护整个数据结构的顺序显得有些“杀鸡用牛刀”的感觉。 实际上，这一需求就能用最大堆来实现，使获取最大值、添加元素、删除最大值这三个操作都有不错的效率： 获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn)。 代码实现此部分以最大堆为例，给出代码实现。 在写代码前，先研究一下二叉堆的特性，前面已经提到了二叉堆的逻辑结构就是一棵完全二叉树，完全二叉树的结构可以存储在数组里，根据索引的关系就能计算出每个结点的父结点、子结点： 二叉堆的特性 在二叉堆的接口设计中：重点关注这三个操作：获取最大值、添加元素、删除最大值。 获取最大值这一操作很简单，根据最大堆的定义，任意节点的值总是大于等于子节点的值，所以根节点的值就是最大值，也就是说，数组的首元素就是最大值。 添加元素时，直接添加到最大堆的最后，但是这可能会破坏最大堆的结构，所以需要上浮(sift up)操作：如果插入的结点元素值比父节点元素值大，就要交换两者位置，循环直到插入结点的元素值不大于父节点的值或者插入结点已经上浮成为根节点（也就是说此节点没有父节点了）退出循环。 12345678910111213141516171819202122232425262728293031/** * 添加元素到最大堆 * @param element 要插入的元素值 */void add (E element)&#123; elements[size]=element; //插入到数组的最后 siftUp(size); //对刚才添加的元素执行“上浮”操作 size++;&#125;/** * 上浮操作，调整插入元素的位置 * @param index 需要上浮操作的数组元素的索引 */void siftUp(int index)&#123; int pIndex = 0; //父节点的索引 E value = elements[index],pValue; //自己的元素值和父节点的元素值 while (index&gt;0)&#123; //只要还有父节点，就循环 pIndex = (index-1)/2; //父节点的索引 pValue = elements[pIndex]; //父节点的元素值 if(cmp(value,pValue)&lt;=0)&#123; //cmp函数用于比较两个元素的大小 break; &#125; //如果大于父结点，就交换。 //E tmp = elements[index]; ---标注1 elements[index] = elements[pIndex]; //elements[pIndex] = tmp; ---标注2 index = pIndex; &#125; elements[index] = value; //----标注3&#125; 在上述代码，处理上浮操作的时候有一个小细节：在循环中，如果插入结点元素值比父节点要大，就要交换当前结点和父节点的位置，按理说交换操作应该是三步走：临时变量保存本结点的元素值（代码中标注1），本结点元素值=父节点元素值，父节点元素值=临时值（代码中标注2），然而这里由于每次比较的都是父节点和待插入结点的值，所以可以将新添加节点备份，确定最终位置才摆放上去（代码中标注3）。 删除最大值时，并不是直接删除根节点，而是先用最后一个结点的值覆盖根节点的值，然后再删除最后一个结点。 最后一个结点的值覆盖根节点的值这可能又会破坏最大堆的结构，所以需要下沉(sift down)操作。 12345678910111213141516171819202122232425262728293031323334353637/** * 移除最大值（也就是数组的首个元素） */void remove()&#123; if(size==0) &#123; return; &#125; elements[0] = elements[size-1]; //用最后一个元素值覆盖首结点的元素值 elements[size-1] = null; //真正移除的是最后一个元素 size--; siftDown(0);&#125;/** * 下沉操作，删除最大值后调用 * @param index */void siftDown(int index)&#123; int leftChild; int bigChild; //记录左右孩子中较大的那个的索引 E value = elements[index]; while(index&lt;size/2)&#123; //只要还有子结点 也就是左孩子索引2i+1&lt;size，也就是i&lt;(size-1)/2 leftChild = 2*index+1;//左孩子索引 bigChild = leftChild; //大孩子默认为左孩子（因为右孩子可能不存在） if(leftChild+1&lt;size &amp;&amp; cmp(elements[leftChild+1],elements[leftChild])&gt;0)&#123; //第一个条件表示右孩子存在，第二个条件表示右孩子比左孩子大 bigChild = leftChild +1; &#125; if(cmp(elements[bigChild],value)&lt;=0)&#123; break; &#125; //如果大孩子的值比自己大，才进行后续操作 elements[index] = elements[bigChild]; index = bigChild; &#125; //退出循环时，要么就是该节点已经下沉到最底了(没有子结点了)，要么就是该节点已经到了大于等于所有子结点的位置 elements[index] = value;&#125; 二叉堆的接口设计中，除了上面这三个最重要的方法，还有一些别的方法： replace(E element) 删除最大值的同时插入一个新元素：用元素element代替根节点的值，然后进行下沉(siftDown)操作。 批量建堆,也就是把一个没有规律的数组建立成堆： 有两种办法。 方法1：自上而下的上浮O(nlogn)：本质是一个个添加 12345678/** * 自上而下的上浮 */void heapify1()&#123; for(int i=1;i&lt;size;i++)&#123; siftUp(i); &#125;&#125; ​ 方法2：自下而上的下沉O(n)。 12345678/** * 自下而上的下沉 */void heapify2()&#123; for(int i=size/2;i&gt;=0;i--)&#123; //从非叶子结点开始下沉 siftDown(i); &#125;&#125; 注意：自上而下的下沉或者自下而上的上浮都不能作为批量建堆的方法。 应用1、Top K问题 从n个数里找出最大的k个数。（k&lt;&lt;n） ◼ 如果使用排序算法（如快速排序）进行全排序，需要 O(nlogn) 的时间复杂度。 把所有数都排序了，杀鸡用牛刀。 ◼ 如果使用进行k次局部排序（每次选出未处理的元素中的最大值放到前面），需要 O(n*k) 的时间复杂度。 处理完毕后，最大的k个数也排序了，需求中这最大的k个元素也不需要排序，似乎多此一举。 ◼而如果使用二叉堆（最小堆）来解决，可以使用 O(nlogk) 的时间复杂度来解决。 建立一个大小为k的堆，先把数组n中的前k个元素添加到堆，然后对剩余元素做如下处理： 如果n数组中的当前元素大于堆顶元素，就用它代替最小堆堆顶元素，并进行sift down操作，以维护堆的性质。 如果当前元素小于堆顶元素，什么都不用做，继续访问下一个元素。 最后，堆中的k个数字就是最大的K个数，完美解决。 2、优先级队列 jdk的PriorityQueue就是二叉堆（最小堆）实现的。 这里截取部分代码看看：这不就是我们的siftUp上浮操作吗！ JDK的PriorityQueue实现部分代码截图 另外多说一句，在我写代码的时候，直接把两个元素的比较逻辑封装起来——在二叉堆类中组合了一个比较器对象(Compartor类型)，如果有外部比较器，就用外部比较器的逻辑比较，否则强制转成Comparable接口比较，像下面这样： 123456int cmp(E e1,E e2)&#123; if(comparator!=null)&#123; return comparator.compare(e1,e2); &#125; return ((Comparable)e1).compareTo(e2);&#125; 这样把比较逻辑封装起来之后的好处就是写代码时很简洁，但是仔细一想也有缺点：每次比较任何两个元素时都会判断比较器是否为空，再决定这两个元素比较的逻辑，这其实是没必要的，做了很多多余的判断，这也是为什么JDK实现中分为了siftUpComparable和siftUpUsingComparator，看上去有些啰嗦，实际上减少了判断次数。 关于优先级队列的更详细内容，推荐阅读:PriorityQueue详解。 总结最后做一个简单总结。 用于维护二叉堆性质的的上浮和下沉操作： sift up 上浮：添加元素时直接添加到数组末尾，可能会破坏二叉堆性质——每个结点元素值必须大于子结点元素值，所以要上浮找到新元素的合适插入位置，想象一下如果把一个最大的元素值插入到了数组末尾后，会一直上浮到根节点。 sift down 下沉: 当要删除最大值的时候，直接让最后一个元素”空降“替代最大值，这种”空降“也可能会破坏二叉堆性质，所以要下沉，直到让”空降“的末尾节点找到合适的位置。 最大堆和最小堆的”无缝切换“ 另外值得一提的是，我上面写的代码是最大堆的实现，如何在此基础上修改成最小堆呢？ 实际上不用修改封装好了的二叉堆类的代码，只要调用代码处指定自定义的比较器就好了。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之树学习小结","date":"2020-05-20T05:33:29.000Z","path":"2020/05/20/数据结构与算法—树学习笔记/","text":"此系列是我数据结构的学习笔记，观看视频课程，网上有很全面的笔记了，节约时间，细节没有再展开。 本篇博客分享主题：「树」，简单总结一下近期学的二叉搜索树、平衡二叉搜索树、红黑树，重点介绍二叉搜索树。 基本认识二叉搜索树(Binary Search Tree),又叫做二叉查找树、二叉排序树。 任意一个节点的值都大于其左子树所有节点的值。 任意一个节点的值都小于其右子树所有节点的值。 它的左右子树也是一颗二叉搜索树。 一棵二叉搜索树（BST） 为什么要引入二叉搜索树，需求是什么？ 在乱序数组中插入元素，搜索操作平均时间复杂度O(n)，插入操作复杂度O(1) 排好序的数组，二分搜索，最坏时间复杂度O(logn),但插入、删除操作平均复杂度是O(n) 使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)））（更准确得说是O(h),h为树高） 而后面学到的平衡二叉搜索树（AVL）、红黑树（Red Black tree）都是特殊的二叉搜索树，它们主要是为了解决BST太不平衡时效率退化的问题，只不过为了维持二叉树的(相对)平衡，它们有各自附加的要求。总的来说，添加、删除节点这两个基本操作都是一样的，只不过对于AVL和RBT来说，在添加或删除元素之后，可能会破坏树原来的性质，所以需要一些额外的操作（对于AVL来说是旋转，对于RBT来说是着色和旋转）来维持树的性质，以达到更好的性能。 退化成链表的二叉搜索树时间复杂度就变成了O(n)，那么AVL和RBT是怎么优化的呢？AVL树的节点除了维护节点的左右父节点的指针之外，还会维护此节点的高度，AVL树规定每个节点的平衡因子只可能是1，0，-1，否则，称之为失衡。添加和删除节点后可能会导致失衡，我们就做一些额外的操作让它重复恢复平衡就行,具体又分为LL、RR和LR、RL的旋转情况，本文不再展开。 上面那棵BST等价的AVL树 而红黑树的节点除了维护节点的左右父节点的指针之外，还会维护此节点的颜色,红黑树的性质比起AVL更加复杂： 1、节点是RED或者BLACK2、根节点是BLACK3、叶子节点（外部节点，空节点）都是BLACK4、RED节点的子节点都是BLACK RED节点的parent都是BLACK 从根节点到叶子节点的所有路径上不能有2个连续的RED节点 5、从任意节点到叶子节点的所有路径都包含相同数目的BLACK节点。 上面那棵BST等价的红黑树 BST的插入删除操作插入操作比较简单，只需要不断将要插入结点的值和当前工作节点比较，如果待插入节点的值比当前节点的值大，就往左走，否则就往右走，直到工作节点为空，就确定了插入位置。 查找的操作也类似。 删除需要考虑三种情况：度为0、1、2。 度为2： 令后继结点的元素值覆盖删除结点，然后删除后继节点，后继节点的度必为0/1，所以就转化成了下面的两种情况 (ps.取前驱节点替代也可以）度为1： 使删除结点的父节点指向删除结点的子结点，注意删除的是根节点的特殊情况度为0： 直接删除，注意删除的是根节点的特殊情况 常用方法遍历(适用所有二叉树) 前序遍历(Preorder)，访问顺序： 根节点 -&gt; 前序遍历左子树 -&gt; 前序遍历右子树递归实现。 中序遍历(Inorder)，访问顺序：中序遍历左子树 -&gt; 根节点 -&gt; 中序遍历右子树 中序遍历的结果是有序的，因为根据BST的定义，左&lt;中&lt;右。 后序遍历(Postorder)，访问顺序：后序遍历左子树 -&gt; 后序遍历右子树 -&gt; 根节点 层序遍历(Level Order)，访问顺序：从上到下，从左到右依次访问节点。 对于前中后序遍历来说，既可以用递归实现，还可以非递归实现(栈)。 参考我的其他博客： 前序遍历的非递归实现 后序遍历的非递归实现 一棵二叉树的遍历结果 求前驱节点和后续节点一个节点的前驱节点和后续节点分别指的是树的中序遍历结果中这个节点的前一个结点和后一个结点，计算前驱节点的思路如下： 如果此节点有左子树，必定有前驱节点，前驱节点=node.left.right…right 如果此节点没有左子树，但是有根节点，则可能有前驱节点，前驱节点=node.parent.parent…直到当前结点是父节点的左孩子。 否则，返回null 后续节点同理。 设计思想这一部分，简单谈一谈设计BST类代码时候的设计模式，可供参考，把代码写的优雅一点。 策略模式从二叉搜索树的定义来看，涉及到比较操作，所以二叉搜索树存储的元素必须具备可比较性。 一方面，我们可以规定节点元素必须是可比较的，也就是使节点元素的类实现Comparable接口，里面实现compareTo方法，又可以在BST类中加入一个外部比较器，可以让调用者自行决定使用什么比较方法来比较元素大小。详情不再展开，参考比较器comparable与comparator的使用 模板方法模式BST类是父类，AVL和RBT是子类。我们前面说了，在BST中的插入删除方法，只需要做基本操作，而AVL和RBT的插入删除操作之后，还需要做一些额外操作来维持树的性质，所以在设计BST这一个父类的时候，将add()和remove()方法（分别用于插入和删除结点）作为模板方法，在两个方法的最后调用afterAdd()和afterRemove()作为“钩子”，在BST类中，afterAdd()和afterRemove()这两个方法里什么都不做，而AVL和RBT子类重写它们，里面写插入/删除节点后维持树性质的代码。 这样一来，AVL和RBT这两个子类，就可以重用基本操作部分的代码。 性能比较参考动态查找树比较。 BST效率总结： 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)，和高度相关O(h)。 插入删除操作算法简单，时间复杂度与查找差不多。 AVL效率总结： 查找的时间复杂度维持在O(logN)，不会出现最差情况 AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。 AVL树在执行删除时代价稍大，可能造成O(logN)次旋转，执行每个删除操作的时间复杂度需要O(2logN)。 红黑树效率总结： 查找效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些（因为树高可能比AVL高），但也远远好于BST。 插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。 AVL树和红黑树性能对比以及选择图解 个人总结BST和AVL树和红黑树的基础，在理想情况下，它的查找、插入、删除的时间复杂度是O(logN)，但是在一些情况下，其时间复杂度会退化，极端情况下退化成链表，总的来说，BST查找、插入、删除的时间复杂度是和其整体高度正相关的。所以，AVL为了不让BST由于高度失衡而导致时间复杂度退化，就规定了平衡因子的概念，它的查找操作完全和BST一样，插入删除操作之后如果导致树失衡会做旋转操作使得恢复平衡，这样就严格控制了其平衡性（也就是控制了树的高度），所以查找、插入、删除三个操作的时间复杂度都能稳定维持在O(logN）。这里我们还有必要了解一些AVL插入和删除节点的细节:在AVL树插入节点只会造成1次旋转（单旋或双旋），而在AVL树删除节点可能会造成O(logN)次旋转（删除后，父节点失衡调整后导致其祖父节点直到根节点都失衡，都需要旋转）。 而红黑树相较于AVL树来说，对于树的平衡要求没有AVL那么高（所以说，拥有同样多节点的树，红黑树可能比AVL树的树高更大），虽然在红黑树节点定义中，并没有看到关于高度的定义，只有颜色的定义，但是实际上只要满足了其五条要求（在插入删除节点后可能会破坏红黑树要求，所以要进行染色和旋转操作），最后构建出来的红黑树的高度就不会像BST那样有高度严重失衡的坏情况，事实上，红黑树的最长路径长度不超过最短路径长度的2倍，所以说其查找代价还是能基本维持在O(logN)，有时查找性能或许比AVL略逊色一点（因为其高度可能比AVL大），但是其RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。 推荐阅读以下博文的笔记很详细，给出链接供查阅。 小码哥《恋上数据结构与算法》笔记（八）：二叉搜索树 小码哥《恋上数据结构与算法》笔记（九）：平衡二叉搜索树（AVL） 小码哥《恋上数据结构与算法》笔记（十）：B树 小码哥《恋上数据结构与算法》笔记（十一）：红黑树 为什么HashMap使用红黑树而不使用AVL树 另外，推荐一个可以模拟各种树构建、删除过程的网页： 构建各种树的可视化网页工具 还有一个常用的树：哈夫曼树,参考：哈夫曼树与哈夫曼编码","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Mybatis错误排查-多表联合查询时两张表字段相同造成的记录缺失的问题","date":"2020-05-13T14:37:43.000Z","path":"2020/05/13/Mybatis错误排查-多表联合查询时两张表字段相同造成的记录缺失的问题/","text":"问题背景这是在学习Mybatis框架做学习demo时遇到的问题，特此记录。 现有用户表和账户表，规定：一个用户可以有多个账户，一个账户对应确定的一个用户，即对于账户记录来说，是一对一的关系。 两张表的记录如下： image-20200513224038566 现需要使用Mybatis查询出账户表的所有记录，并且需要查询此账户记录对应的用户（利用外键uid）。 sql语句和查询结果如下： 123456789# 一个简单的内连接查询select a.id,a.uid,a.money,u.* from account a,user u where a.uid =u.id;# 此条sql语句执行的结果：1 41 1000 41 张三 2000-02-27 17:47:08 男 杭州市西湖区3 41 2000 41 张三 2000-02-27 17:47:08 男 杭州市西湖区2 45 1000 45 小胡 1999-03-04 12:04:06 男 杭州市杭州电子科技大学 账户类对应的Mapper的xml部分配置如下： 1234567891011121314151617181920 &lt;resultMap id=\"accountMap\" type=\"Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 在Account类中，组合了一个User对象 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;!-- 查询所有账户记录（含用户信息） --&gt; &lt;select id=\"findAll\" resultMap=\"accountMap\" &gt; select a.id,a.uid,a.money,u.* from account a,user u where a.uid =u.id; &lt;/select&gt; 按照此配置测试，发现结果有两个问题： 1、只查询出两条记录信息，而实际上账户数据表中有三条账户记录。 2、账户id结果有误，两条账户记录的正确id应该分别是id=1和id=2，而不是下图中的41和45。 测试结果截图（有两处错误） 排查解决排查思路：其实根据上面执行结果出现的第二个问题就大致定位到了问题所在：账户id打印的是用户id，原因很有可能是因为这两张表的字段id重复，导致无法区分。 解决思路：为其中的一个id字段起别名，以便区分开来。 1234567891011121314151617&lt;resultMap id=\"accountMap\" type=\"Account\"&gt; ！注意此处的column修改了 &lt;id property=\"id\" column=\"accountId\"&gt;&lt;/id&gt; ....此部分和修改前一样，故省略 &lt;association property=\"user\" column=\"uid\" javaType=\"User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; ....此部分和修改前一样，故省略 &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAll\" resultMap=\"accountMap\" &gt; ！注意此处为acocount表的id 起了别名accountId。 select u.*,a.id as accountId,a.uid,a.money from account a,user u where a.uid =u.id;&lt;/select&gt; 果然，修改后，解决了，得到了正确查询结果。 修改后的正确测试结果截图 总结在使用mybatis进行多表联合查询时，如果两张表中的字段名称形同，会出现无法正常映射的问题。 问题解决办法：在SQL查询语句中时，给重复的字段 起别名，然后在column属性使用别名进行映射。","tags":[{"name":"错误排查","slug":"错误排查","permalink":"http://hfq123.github.io/tags/%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"}]},{"title":"Java基础查漏补缺之反射","date":"2020-05-12T08:17:45.000Z","path":"2020/05/12/Java基础查漏补缺之反射/","text":"反射的原理反射是什么? JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 为什么要学习反射？ “反射是框架设计的灵魂。” 大三上初学Spring框架时，就听过这句话，看了介绍反射的知识点云里雾里，完全是硬着头皮跟着做，现在学了JVM类加载过程之后，这块知识还是比较好理解的。 首先回顾一下类加载过程：加载-&gt;连接-&gt;初始化 其中加载这一步骤要做三件事： 通过类的全限定名获取此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的访问入口。 我们需要重点关注，生成的Class对象描述了这个对象的所有信息，比如都有哪些构造方法，都有哪些成员方法，都有哪些字段等，在反射中就要利用到Class对象。 反射的使用使用反射要关注以下2个重点问题。 如何获取类的Class对象?有以下3种获取类的Class对象的方法: 12345678910111213//方法1：调用类的一个实例的getClass方法Dog dog = new Dog();Class&lt;Dog&gt; dogClass = dog.getClass();//方法2：类的字面量Class&lt;Dog&gt; dogClass1 = Dog.class;//方法3：推荐！利用Class类的静态方法forName()，其参数是需要获取的类的全限定类名，需处理ClassNotFoundException异常try &#123; Class&lt;Dog&gt; dogClass2 = (Class&lt;Dog&gt;) Class.forName(\"reflect.Dog\");&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 对这三种获取Class对象的方式的理解：每个对象的对象头里存了该对象所在类的Class对象的引用（这块知识点在JVM中有详细介绍），所以从原理上看，可以直接根据对象获取Class对象，如方法1，实际上getClass()是Object类的方法,所以自然所有对象都会有这个方法了。 获得Class对象之后有什么用？当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取该类中的构造方法、成员变量、方法等信息，类的这一个个组成部分会被映射成一个个对象,比如说利用反射获得类的构造器对象，然后就可以利用这个类的构造器对象构造一个这个类的实例，总的来说,利用反射能做的事情有： 获取构造方法，用此构造方法创建对象 aClass.getConstructor(); newInstance() 获取成员变量 getFiled(“filedName”) getFileds() getDeclaredFileds() 获取成员方法，并执行此成员方法 getMethod() getDeclaredMethod() invoke() 反射的应用 修改私有成员变量的值 执行私有成员方法 反射妙用：通过反射运行配置文件内容 我利用反射+代理模式写了个demo，用来计算任意类的无参方法的执行时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package reflect;import java.lang.reflect.Method;/** * @Created by hfq on 2020/5/12 * @used to: 用于计算任意类的任意无参方法的执行时间 */public class TimeProxy &#123; String className; String methodName; public TimeProxy()&#123; &#125; public TimeProxy(String className, String methodName) &#123; this.className = className; this.methodName = methodName; &#125; public Long exeucte() throws Exception &#123; Class&lt;?&gt; aClass = Class.forName(className); Long start = System.currentTimeMillis(); Method method = aClass.getDeclaredMethod(methodName,null); method.setAccessible(true); method.invoke(aClass.newInstance(),null); return System.currentTimeMillis()-start; &#125; public static void main(String[] args) throws Exception &#123; TimeProxy timeProxy = new TimeProxy(\"reflect.Person\",\"eat\"); System.out.println(\"人吃饭，吃了:\"+timeProxy.exeucte()+\" ms\"); TimeProxy timeProxy2 = new TimeProxy(\"reflect.Brid\",\"fly\"); System.out.println(\"鸟飞行，飞了:\"+timeProxy2.exeucte()+\" ms\");// 测试系统Math类的random()方法，报java.lang.IllegalAccessException// TimeProxy println = new TimeProxy(\"java.lang.Math\", \"random\"); // System.out.println(\"Math执行random方法，执行了\"+println.exeucte()+\" ms\"); &#125;&#125;class Person&#123; private void eat() throws InterruptedException &#123; Thread.sleep(1000); //人吃饭三秒 &#125;&#125;class Brid&#123; private void fly() throws InterruptedException &#123; Thread.sleep(3000); //鸟飞翔三秒 &#125;&#125;/*打印结果如下：人吃饭，吃了:1001 ms鸟飞行，飞了:3001 msProcess finished with exit code 0*/ 更多内容我就不在此展开了，参考如下文章，案例比较全面： 原文链接：https://blog.csdn.net/sinat_38259539/article/details/71799078","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://hfq123.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java基础查漏补缺系列前言","date":"2020-05-12T06:13:44.000Z","path":"2020/05/12/Java基础/","text":"当初大一下初学Java课程的时候，教学重点是基础语法和面向对象的设计思想。而基础的高级部分只涉及到了I/O、极少量的多线程知识、异常处理，而且也是非考试重点，当时的学习程度比较浅显，很多知识如泛型、反射等知识都是后面现用现学，没有系统地学习，导致整个知识面不怎么清晰。以至于到现在框架都学了，然而Java语言本身的了解程度还不够，有点本末倒置的意思，所以推出这个系列文章，记录一些Java基础的进阶部分学习笔记，作为查漏补缺。 分为以下几个部分： 反射 异常 泛型 注解 I/O 正则表达式","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://hfq123.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"java并发编程-等待/通知机制","date":"2020-05-09T09:01:04.000Z","path":"2020/05/09/java并发编程-等待-通知机制/","text":"https://www.cnblogs.com/powercto/p/10848825.html#a%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E8%AF%B4wait-%E8%A6%81%E6%94%BE%E5%9C%A8while%E9%87%8C%E9%9D%A2%EF%BC%9F while的作用 标志的作用： 即使唤醒线程先执行了，也正常。","tags":[{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"cxsj项目-服务端主动推送数据到客户端","date":"2020-05-07T05:20:09.000Z","path":"2020/05/07/cxsj项目-服务端主动推送数据到客户端/","text":"需求分析在智慧停车管理平台(WEB端)项目的公告发布模块中，管理员发布公告后，车主用户可以评论公告（这可以作为用户提问的一种途径），为了让管理员及时看到用户对公告的评论，以便及时回复，需增加一个通知提醒功能，就和大多数WEB应用一样，页面顶部有一个通知图标，如果有通知，就高亮显示起到提醒的作用。 目标实现效果当没有任何通知的时候（在我这个案例中，也就是没有用户回复公告的提醒），显示通知图标。 没有通知的时候页面顶部状态栏 当有通知时，高亮显示未读通知的数目，当用户点击页面顶部“通知”按钮的时候，根据时间降序显示出所有通知，并且重点标注出哪些通知是未读的。 image-20200508134511709 实现思路基本思路接下来介绍一下本案例中是怎么实现通知回复功能的。 当用户进行评论公告操作后，先将用户的评论插入到数据库的评论表中，如果插入成功，生成一条对应的通知记录，在数据库设计时，通知表(notification)包含了如下字段： 字段名 作用 id 通知表的主键 notifier 通知发起者id，外键，关联用户表 receiver 通知接收者id，外键，关联用户表 outerId 公告id，外键，关联公告表，表示notifier在编号为outId的公告下回复了receiver gmt_create 通知创建的时间戳，bigint类型 status 通知的阅读状态（对于接收者而言），0标识未读，1标识已读 结合具体场景对数据表各个字段的解读： 用户A成功回复了管理员发布的公告，则生成一条通知记录，其中，notifier字段存用户A的id，recevier字段存管理员的id，outId存被回复的公告的id，gmt_create保存系统当前的时间戳，以记录通知生成的时间，status初始化为0表示通知接收者还未读。 持久化通知记录到数据库之后，我们就可以获得每个用户的未读通知数目和全部历史通知数据： 12345#查询某用户未读通知的数目select count(1) from notification where receiver = 用户ID and status = 0#查询某用户的全部通知select * from notification where receiver = 用户ID 至此就很明朗了：加载WEB页面时，先查询当前用户的未读通知的数目，如果是0，则显示通知图标，如果大于0，则高亮显示未读通知的数目。这个流程可以通过ajax调用后端查询接口实现，代码就不展开了。 现在问题来了，这样做的缺点是什么？ 1、实时性差，每次需要手动刷新当前页面或者点击别的页面，重新加载后，才会获得当前实时的未读通知数目。 2、效率不高，每进入一个新的页面，都会查询当前的未读通知数目，即使距离上一次查询的一段时间内，未读通知数并没有更新，也会查询。 改进思路针对上述这两个问题，有一些改进思路： ”假装实时“的客户端轮询机制首先，为了解决实时性差的问题，我们可以想到：客户端每隔一小段时间，就使用ajax调用查询接口，获取当前用户未读通知的数目，获取结果后局部刷新到顶部栏通知框内。 这样做一定程度上实现了”实时“通知：比如说，每隔2秒，客户端就发起一次查询当前通知未读数的请求，服务器返回结果，如果不考虑网络等因素的延时，网页顶部的通知状态栏中的数字始终是2s内的未读通知数，对于普通WEB应用来说，这样的实时性是可以接受的。 轮询机制的代码实现（每隔2000ms调用一次查询方法并更新）： 123setInterval(function()&#123; 此处写ajax查询的代码&#125;,2000) 接下来，我们来分析一下这种机制的性能： 轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。 这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。 注:此段描述摘自于此博客。 总的来说，轮询机制似乎确实在一定程度上能解决实时性的问题，但是效率很差。 由于轮询有一定的时间差，所以我在标题上说是”假装实时“。 真正实时的WebSocket概念之所以轮询机制的效率低，是因为，客户端无法得知后台数据什么时候发生了更新，所以每次发送请求时只能”抱着试一试“的态度，请求当前后台某个数据的值，以尽可能获取最近一段时间内的该数据的最新值，概括地说，和普通客户端请求一样，轮询机制是由客户端发起请求。而理想的模型是在服务器端数据有了变化后，可以主动推送给客户端,这种”主动型”服务器是解决这类问题的很好的方案。Web Socket就是这样的方案。 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 注:此段描述摘自于菜鸟教程。 简而言之，WebSocket 拓展了客户端获取后台数据的方式，普通情况下，只能由客户端主动拉取(pull)，而用了WebSocket之后，可以通过服务器主动推送（push），客户端被动获取数据。 讲到这里，终于呼应上本文的标题了。 由于我还没系统学过java的网络编程，之前也没接触过WebSocket，于是采用了号称“让websocket更简单”的解决方案——GoEasy API，结果证明，使用起来确实极其简单。 理解GoEasy的工作原理很简单，浏览器订阅channel，服务端后客户端都可以向channel发布消息，消息被发布 到channel后，所有订阅了该channel的客户端都可以获得channel里的消息。 GoEasy的推送机制 图源自GoEasy的工作原理。 使用这里就简单地介绍一下GoEasy的使用过程吧。 1、注册并登录GoEasy账号后，首先注册一个应用，选免费版即可。 2、后端推送数据到channel 首先，在maven项目的pom.xml中添加如下依赖: 12345678910111213141516 &lt;dependencies&gt; ........... &lt;!-- GoEasy的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.goeasy&lt;/groupId&gt; &lt;artifactId&gt;goeasy-sdk&lt;/artifactId&gt; &lt;version&gt;0.3.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这是gson的依赖，一开始没有加，报错ClassNotFound了 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12GoEasy goEasy = new GoEasy( \"这里填写第一步注册应用完成后获取到的Common key\");goEasy.publish(\"my_channel\", String.valueOf(replyNum)); //replyNum是我项目中生成新通知后，更新后的\"通知未读数目\" 3、前端从channel中获得消息 首先，下载js文件，引入到thymeleaf的html模板中。 编写获取channel中数据的前端代码： 1234567891011121314151617/** * 订阅channel，获取最新的未读通知数目 */function subscribleReplyNum() &#123; var goEasy = new GoEasy(&#123; host:'hangzhou.goeasy.io', //应用所在的区域地址: 【hangzhou.goeasy.io |singapore.goeasy.io】 appkey: 这里依旧填写第一步注册应用完成后获取到的Common key &#125;); goEasy.subscribe(&#123; channel: \"my_channel\", //“my_channel”对应于发布时的channel名 onMessage: function (message) &#123; console.log(\"Channel:\" + message.channel + \" content:\" + message.content); $(\"#not_read_count\").text(message.content); //更新“通知状态栏”的未读通知数目的span的值 &#125; &#125;);&#125; 至此，就可以正常使用了，完成如下效果： image-20200508174335930","tags":[{"name":"项目 JavaWeb","slug":"项目-JavaWeb","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE-JavaWeb/"}]},{"title":"再谈单例模式","date":"2020-05-06T15:20:09.000Z","path":"2020/05/06/再谈单例模式/","text":"之前，学设计模式的时候，接触了单例模式的四种实现方法，那个时候还不怎么理解，糊里糊涂地整理了笔记。 现在学了JVM和并发编程后，对单例模式的实现细节有了更好的掌握。借此机会回顾一下DCL(Double Check Lock，即双重检查锁)实现单例和静态内部类实现单例。 DCL单例模式经典懒汉单例模式的实现123456789101112public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public synchronized static Singleton getInstance()&#123; if(instance==null) return new Singleton(); return instance; &#125;&#125; 在此代码，重点关注synchronized关键字，它修饰了获取单例的静态方法。 之所以在这里要用synchronized，是因为防止多线程情况下，如果多个线程同时执行到了if(instance==null)，判断都是true，将会导致在多个不同的线程创建了多个不同实例，违背了单例模式的目标，所以需要使用synchronized保证这块代码的原子性，也就是在一个线程创建实例的时候避免其他线程的干扰。 一步步改进我们知道，synchronized关键字修饰静态方法，就相当于修饰了所在类.Class对象，所以上述代码等价于如下代码: 1234567891011121314public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; synchronized (Singleton.class)&#123; if(instance==null) return new Singleton(); &#125; return instance; &#125;&#125; 这种方法虽然实现了懒惰实例化，需要用到单例时才会创建，而且也保证了线程安全。 但是性能上存在缺陷： 原因是，在此实现中，每次进入getInstance方法获取单例时，都要进入先synchronized修饰的同步代码块。但实际上只有在首次创建单例（第一次调用getInstance方法）的时候，有线程安全的问题，一旦创建了单例后，多个线程获取单例不会有线程安全的问题，而synchronized加锁是有性能开销的，这样做就相当于把一部分不需要加锁的情况，也加了锁。 根据此思路，我们对这段代码改进，就会得到DCL单例模式的初步实现： 12345678910111213141516public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; if(instance==null)&#123; //根据分析，只有首次创建（也就是当前instance为空）时，需要进入同步代码块 synchronized (Singleton.class)&#123; if(instance==null) return new Singleton(); &#125; &#125; return instance; &#125;&#125; 在此实现中，先后两次对instance进行是否为空的判断，这也是“double check“这个名字的由来。 细心的读者会看到上文我说，这一种是DCL的”初步实现“，看似完美的实现有什么不足呢？ 这就要从字节码的角度分析了。 指令重排。 先调用构造方法再内存指向，先内存指向再调用构造方法都有可能！！。 其他线程执行第一个检查的时候，判断instance==null的条件不成立，直接返回了instance对象，而对比经典的单例模式实现中，synchronized关键字修饰了，只有获得了对象监视器的线程可以访问instance 。 不会影响本线程，但是可能影响其他线程 说了这么多，如何解决呢？ ​ private static volatile Singleton instance; 饿汉：类加载时就会创建单例对象。（静态成员变量会初始化阶段赋值） 懒汉：类加载时不会导致单例对象被创建，而是首次使用该对象才会创建。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"推荐阅读","slug":"推荐阅读","permalink":"http://hfq123.github.io/tags/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/"}]},{"title":"JVM-虚拟机性能监控与故障处理实战","date":"2020-05-04T09:53:58.000Z","path":"2020/05/04/JVM-虚拟机性能监控与故障处理实战/","text":"本文主要介绍如何应用一些虚拟机的性能监控和分析的命令。 jdk命令行工具jps image-20200504175625119 jps可以查看当前jvm运行的进程名和它们对应的虚拟机进程号。查到进程号后方便结合后续的很多其他命令。 jstatjstat用于监视虚拟机各种运行状态信息，显示类装载、内存、垃圾收集、JIT编译等运行数据。 image-20200504175926715 表示分析进程 id 为 8608 的 gc 情况，每隔 1000ms 打印一次记录，不停止。 jinfojinfo用于实时查看和调整虚拟机各项参数。 image-20200504180217340 带参数的jinfo image-20200504180250530 jmap用于生成堆转储快照。 image-20200504180359885 jhat用于分析堆转储快照。使用jhat，用户可以在浏览器上查看分析结果。 image-20200504180455772 进入localhost:7070: image-20200504180509345 jstack用于生成虚拟机当前时刻的线程快照。 主要目的是定位线程出现长时间停顿的原因， 如死锁、死循环、请求外部资源长时间等待….. 持续等待用户输入造成停顿时间过长 jstack定位死锁 可视化工具jconsole可以在cmd窗口打开jconsole图形化工具，然后连接到本地进程或远程进程。 image-20200504181849691 VisualVM强大的运行监视和故障处理程序，可以在cmd窗口输入jvisualvm打开此图形化工具。 image-20200504183707463 转储后分析内存","tags":[{"name":"JVM","slug":"JVM","permalink":"http://hfq123.github.io/tags/JVM/"}]},{"title":"JVM学习笔记-垃圾回收","date":"2020-05-04T08:03:13.000Z","path":"2020/05/04/JVM学习笔记-垃圾回收/","text":"主要参考材料是《深入理解Java虚拟机》第二版。 根据学习内容，制作了思维导图。 image-20200504160356910","tags":[{"name":"JVM,笔记","slug":"JVM-笔记","permalink":"http://hfq123.github.io/tags/JVM-%E7%AC%94%E8%AE%B0/"}]},{"title":"Java并发编程笔记1-基本概念","date":"2020-04-30T16:51:39.000Z","path":"2020/05/01/Java并发编程笔记1-基本概念/","text":"JVM已经学的差不多了，今天开始学习Java并发编程，记录学习笔记。 多线程的基本概念首先还是从基本概念讲起。 进程VS线程进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载到CPU，把数据加载至内存。在指令运行过程中还需要用到用到磁盘、网络等设备，进程就是用来加载指令、管理内存、管理IO的。 当一个程序运行，从磁盘加载这个程序的代码到内存，这时就开启了一个进程。 进程可以视作程序的一个运行实例，大部分程序可以同时运行多个实例进程，有些只能启动一个实例进程。 程序是静态的，而进程是动态的。 线程 一个线程就是一个指令流，将指令流中的一条条指令以一定顺序交给CPU执行。 线程是最小的CPU调度单位。进程作为资源分配的最小单位，在windows中是不活动的，只是作为线程的容器。 对比 独立性：进程之间基本上是互相独立的，而同一个进程内可能有多个线程，它们之间相互协作完成进程。 资源角度：进程拥有共享资源，如内存空间，供其内部的线程共享。 通信方式： 进程通信：同一计算机的进程之前通信称为IPC(Inter-process communication)，不同计算机之间的进程通信，需要通过网络，并且遵守共同的协议，如HTTP。 线程通信：线程通信相对简单，因为它们共享进程内的内存。 线程更轻量，线程上下文切换成本一般比进程上下文切换低。 并发VS并行推荐阅读 单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，一般会将这种 线程轮流使用 CPU 的做法称为并发（concurrent）。多核 cpu下，每个核(core) 都可以调度运行线程，这时候线程可以是并行(parallel)的。 关于并发和并行的概念辨析，这里引用Go语言创始人Rob pike的描述： &lt;%blockqoute%&gt; “Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once” &lt;%endblockqoute%&gt; 并发是一段时间内应对多个任务的能力(某个时间片内执行一个任务的一部分，下一个时间片可能执行其它任务的一部分，多个任务轮流时间片，通过不同任务之间切换，切换后的任务从上次停止的地方继续)，而并行是一个时间点上同时处理多个任务的能力。 并发是一段时间内某个系统或单元的各个组成部分通过相互配合来处理大量的任务，强调结构和调度，并行是某一时刻多个单元同时在做各自的任务， 强调执行。 多线程的应用 异步调用。 无需等待方法调用。 利用CPU多核优势并行 Java线程创建并启动线程创建线程的3种方式。 在Java中，创建线程主要是用到Thread类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @Created by hfq on 2020/5/1 * @used to: 创建线程的3种方式 */@Slf4j(topic = \"c.Test1\")public class Test1 &#123; /** * 创建线程方式1 */ public static void test1()&#123; Thread t1 = new Thread(\"myThread1\")&#123; @Override public void run()&#123; log.debug(\"thread 1 start........\"); &#125; &#125;; t1.start(); &#125; /** * 创建线程方式2 */ public static void test2()&#123; Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; log.debug(\"thread 2 start........\"); &#125; &#125;,\"myThread2\"); //Thread t2 = new Thread(() -&gt; log.debug(\"thread 2 start........\"),\"myThread2\"); t2.start(); &#125; /** * 创建线程方式3 */ public static void test3()&#123; FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; log.debug(\"thread 3 start........\"); return null; &#125; &#125;); Thread t3 = new Thread(integerFutureTask, \"myThread3\"); t3.start(); &#125; public static void main(String[] args) &#123; test1(); test2(); test3(); log.debug(\"main thread start........\"); &#125;&#125; ！！！ 【拓展阅读—Java创建涉及的设计模式】 Thread类涉及到的两种设计模式 线程类的模板方法设计模式 多线程策略模式 查看进程和线程的方法windows：tasklist、taskkill linux: ps、top、kill java: jps、jstack、jconsole Java操作线程的常见方法start&amp;run如果在主函数中直接调用线程的 run方法 是在主线程中执行了 run，没有启动新的线程使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码 sleep 与 yield调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 调节线程优先级setPriority()。Thread.MIN_PRIORITY ：1，Thread.MAX_PRIORITY：10 join方法Thread中，join()方法的作用是调用线程等待该线程完成后，才能继续往下运行。 join()方法还有一个重载方法join(long n) ，等待线程运行结束,最多等待 n毫秒。 interrupt方法打断 sleep，wait，join 的线程 给受阻塞的线程发出一个中断信号，这样受阻线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。 待理解 两阶段终止模式 守护线程默认新创建的线程是非守护线程，java进程中主线程和所有非守护线程都结束了才会结束。 设置为守护线程：setDaemon(true)。 垃圾回收器：守护线程 线程状态在操作系统课本上，我们学的是线程有五种状态。 而在Java语言中，一个线程的状态有六种。从jdk Thread类的源码中就可以看到，定义在名称为State枚举中： image-20200516184955190 线程安全问题多线程对静态变量进行相同次数的自增自减。 thread1 thread2 a++; a–; a++:取a，计算a+1，写回内存 a–:取a，计算a-1，写回内存","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"JVM学习笔记-JVM内存区域","date":"2020-04-29T16:38:18.000Z","path":"2020/04/30/JVM学习笔记-JVM内存区域/","text":"学习JVM有一段时间了，消化后整理了此笔记便于自己复习，此系列定位为“笔记”，一些地方就写得比较精简了，适合已经系统学习过JVM的读者翻阅。 主要参考材料是《深入理解Java虚拟机》第二版。 JVM内存区域运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，每个区域有各自的用途。 根据该区域是否是线程私有，可以分为线程私有的区域和线程共享的区域。 线程私有的内存区域程序计数器它的作用是指示当前线程要执行的字节码的行号（字节码指令的地址）。 java多线程是通过线程轮流切换实现的，线程被挂起后下次需要恢复到正确的执行位置，所以每个线程都需要一个独立的程序计数器。 除了线程私有，程序计数器区域的另一个特点是占用内存空间很小，唯一的一个不会OOM的区域。 Java虚拟机栈既然它是栈，那么栈元素是什么呢？答案是栈帧。栈帧用于存放局部变量表、操作数栈 、动态链接、方法出口等信息。每调用一个Java方法，与之对应的一个栈帧入栈，执行完成，出栈。 此区域有两种内存溢出的情形： StackoverflowError 栈中加入的元素（栈帧）过多造成栈溢出，也就是调用的方法过多，一直没有返回），比如说持续递归会造成这种情况 。 OutOfMemoryError 如果虚拟机栈支持动态扩展，扩展时无法申请足够的内存，就会出现此情况OOM。 本地方法栈这一内存区域与 Java虚拟机栈类似，不过其服务的对象是本地方法（一般是由C/C++实现的）而非Java方法。 线程共享的内存区域堆此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也就变得不那么绝对了。 如果从垃圾回收的角度考虑，由于大部分JVM实现都采用了分代收集的回收算法，把堆空间进一步划分成新生代和老年代,其中新生代包括了Eden空间，From Survivor空间，To Survivor空间。 方法区方法区存放已被虚拟机加载的类的元数据（类信息、常量、静态变量、编译后的代码等等）。 永久代、元空间、方法区 三者关系 方法区是内存区域的一种规范，永久代和元空间都是方法区的一种实现。JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 运行时常量池是方法区的一部分 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用），类加载后Class文件中的常量池信息就进入了方法区的运行时常量池。 HotSpot虚拟机对象探秘《深入理解Java虚拟机》书中详细地介绍在HotSpot虚拟机在堆中对象分配、布局和访问的全过程。 对象的创建对象的创建总体上有这几个步骤： 类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 为新生对象分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 初始化为零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 对象头的设置 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行init方法 把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。 Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志等等,被官方称作Mark Word，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 对象的大小必须是 8 字节的整数倍。 对象的访问建立对象就是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种。 这两种对象访问方式各有优势，使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 。。。此处待上图。。。 实战:OutOfMemoryError异常上面讲的都是理论，在实战中，可能会遇到OOM的问题，我们开发人员要做的就是快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常该如何处理。 内存溢出区域 报错信息 可能的原因 解决方法 堆 OOM java heap space 调节堆大小(-Xms,-Xmx)检查代码对象的生命周期是否合理 栈 StackoverflowError OutOfMemoryError 方法区","tags":[{"name":"JVM","slug":"JVM","permalink":"http://hfq123.github.io/tags/JVM/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter9","date":"2020-04-26T02:22:51.000Z","path":"2020/04/26/《Head-First-设计模式》读书笔记charpter9/","text":"本篇博客是《Head First 设计模式》第九章的读书笔记。 分享主题是设计模式中的 「迭代器模式(Iterator Pattern)」以及 「组合模式(Composite Pattern)」。 迭代器模式场景:菜单合并有一家早餐馆和一家饭馆合并了，我们需要合并2张菜单，由于以前它们底层实现的数据结构不同，早餐菜单是由AarryList实现的，而正餐菜单是由数组实现的，现在要打印合并后的菜单。注意：这里说的“合并”不要求底层实现的数据结构的统一，产生一个新的菜单，而只需要打印格式统一就行了，供服务员类菜单统一打印菜单。 思路1：依次打印两张菜单实现P.S.为了便于阅读，本文只给出了部分核心代码，完整代码见GitHub。 pancakeHouseMenu类和DinerMenu类分别是早餐菜单和正餐菜单，代码略。 服务员类代码： 123456789101112131415161718192021public class Waitress&#123; //服务员类，主要工作:打印菜单(包含早餐菜单和正餐菜单) PancakeHouseMenu pancakeHouseMenu; //早餐菜单对象，ArrayList实现 DinerMenu dinerMenu; //正餐菜单对象，数组实现 ..... public void printMenu()&#123; //思路1 System.out.println(\"早餐--烙饼专场:\"); ArrayList&lt;MenuItem&gt; arrayList = pancakeHouseMenu.getArrayList(); for(MenuItem item : arrayList)&#123; System.out.println(item.toString()); &#125; System.out.println(\"正餐--套餐饭专场：\"); MenuItem[] menuItems = dinerMenu.getMenuItems(); for(int i = 0; i&lt;menuItems.length; i++)&#123; if(menuItems[i] == null) return; System.out.println(menuItems[i].toString()); &#125; &#125; .....&#125; 如上代码，这种思路是依次打印早餐菜单和正餐菜单： 用一个ArrayList对象接收早餐菜单，遍历这个ArrayList对象，打印每个早餐菜单项。 用一个数组对象接收正餐菜单，遍历这个数组对象，打印每个正餐菜单项。 分析 这种方法需要服务员类清楚地知道各个菜单的内部实现是怎么样的，这样才能分别使用正确的数据类型接收各菜单。 如果有新的菜单需要合并（比如这家餐厅又并入了一个咖啡馆），毫无疑问，我们要修改服务员类的printMenu()方法：根据新的菜单的数据结构接收菜单，再遍历这个集合。 总结前面两点，也就是说，如果有第三张菜单的出现，那么就会需要三个循环，服务员类需要清楚地知道这三张菜单各自的底层数据结构，数组？ArrayList ？HashTable？…… 思路2：使用迭代器模式经过对思路1的分析，我们发现，对于服务员类来说，其实没有必要关注菜单实现的细节：不需要知道每张菜单的各个菜单项是存放在什么类型的集合中的，它只需要关注如何依次获得每个菜单项对象。为此，改进思路是设计原则中的封装变化的部分：在这里，需要封装由不同集合类型所造成的遍历。 使用迭代器之后以正餐菜单为例，设计迭代器： 123456789101112131415161718192021222324252627282930313233public class DinerMenu implements IMenu &#123; //正餐菜单 static int MAX_ITEMS = 10 ; int numberOfItems = 0 ; MenuItem [] menuItems; ..........................//省略了初始化代码 @Override public Iterator createIterator() &#123; return new DinerMenuIterator(this.getMenuItems()); //获得迭代器 &#125;&#125;public class DinerMenuIterator implements Iterator &#123; //正餐菜单的迭代器 MenuItem [] items; //正餐菜单的数据结构是数组 int postion = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if(postion&gt;=items.length || items[postion]==null) return false; return true; &#125; @Override public MenuItem next() &#123; return items[postion++]; &#125;&#125; 服务员类中打印整张菜单的方法： 123456789101112131415public void printMenuWithIterator()&#123; //使用迭代器后，打印整张合并后的菜单 System.out.println(\"早餐--烙饼专场:\"); // printMenu(pancakeHouseMenu.createIterator()); printMenu(pancakeHouseMenu.getArrayList().iterator()); //pancakeHouseMenu的菜单项组织的数据结构是ArrayList，所以可以直接获得ArrayList内置的迭代器 System.out.println(); System.out.println(\"正餐--套餐饭专场：\"); printMenu(dinerMenu.createIterator());&#125;public void printMenu(Iterator iterator)&#123; //遍历某个菜单迭代器可访问的全部菜单项 while (iterator.hasNext())&#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.toString()); &#125;&#125; 可以看到，服务员类中，只需要调用各个菜单迭代器的hasNext()和next()来获得每个菜单项，无需关注其数据结构，只有在迭代器内部才需要关注具体的数据结构。 进一步改进：如上服务员类的代码，服务员类中分别组合了早餐菜单和午餐菜单两个对象，为了提高可拓展性，可以用一个ArrayList保存所有菜单，便于今后加入新的菜单或者删除现有菜单。 改进后更加优雅的服务员类代码: 12345678910111213141516171819202122232425262728/** * @Created by hfq on 2020/4/26 * @used to: 更加优雅的服务员 */public class WaitressImproved &#123; ArrayList menuList; //保存各个菜单 public WaitressImproved(ArrayList menuList) &#123; this.menuList = menuList; &#125; public void printMenu()&#123; Iterator menuIterator = menuList.iterator(); while (menuIterator.hasNext())&#123; IMenu menu = (IMenu) menuIterator.next(); //遍历各个菜单 printMenu(menu.createIterator()); //调用printMenu方法依次遍历并打印该菜单的每个菜单项 System.out.println(); &#125; &#125; public void printMenu(Iterator iterator)&#123; //遍历某个菜单迭代器可访问的全部菜单项 while (iterator.hasNext())&#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.toString()); &#125; &#125;&#125; 可以看到，这样做的好处在于，如果有新的菜单（需要实现createIterator()方法，获得这个菜单的迭代器）加入，不需要修改服务员类的代码，就能直接调用打印整个菜单的功能。 定义接下来我们来看看迭代器模式的定义： 迭代器模式提供一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 结合上例解读迭代器模式：服务员类不需要知道各个菜单内部究竟是用数组表示的还是ArrayList表示的，它只需要获得菜单的迭代器，由迭代器告诉服务员类还有没有没有遍历到的对象( hasNext() )、下一个遍历的对象是谁)( next() )，来遍历其中的每个对象。 设计原则 一个类应该只有一个引起变化的原因 java的Iterator接口迭代器模式在平时开发中经常用到。 hasNext() next() 组合模式场景引入组合模式的场景仍然是上例中菜单的例子，现在餐厅菜单引入了新的需求：上例的正餐菜单里需要嵌套一个甜品菜单，支持嵌套菜单后，整张菜单应该长这样： 支持嵌套子菜单的菜单结构 重点关注上图的“正餐菜单”，在这个菜单集合中，其集合项既可以是它的子菜单（图上的甜品菜单），又可以是普通菜品。 在代码中，我们也需要某种树形结构，可以在一个菜单下同时容纳子菜单和菜品。 引入组合模式没错，我们要引入组合模式来解决这个问题，先来看看组合模式是什么吧： &lt;%blockquote%&gt;组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象以及对象组合。&lt;%endblockquote%&gt; 有了场景的铺垫，很容易配合其定义解读，解读之前，再来规定一下案例中涉及到的几个业务概念，避免混淆。 菜单：作为一个整体菜单独立存在，比如上图的正餐菜单，在代码中独立以一个集合的形式存在。 菜品：菜单下具体的一道菜，比如，上图鸡腿饭是正餐菜单的一道菜品，是形成树形结构的“叶子节点”。 子菜单：某张菜单下嵌套的下级菜单，比如，上图甜品菜单是正餐菜单的一个子菜单，是形成树形结构的“子树”。 菜单项：在菜单概念中，提到了菜单是以一个集合的形式独立存在的，菜单项则就是菜单集合的集合项了，本案例中，菜品和子菜单都可以作为菜单项。 绕了这么多，让我们结合组合模式的定义分析：在本例中，“整体”对应菜单，“部分”对应菜单项，“个别对象”对应菜品，“对象组合”对应子菜单。因为菜单项既可以是菜品，也可以是子菜单，就构成了有层级关系的树形结构，而我们引入组合模式的目标就是希望能够以统一的方式地处理菜单下级的菜品和子菜单这两种不同结构，而不用关注它到底有没有、有几个子菜单，甚至在子菜单中也能再嵌套子菜单。写出简单的代码，就能够对整个菜单结构应用相同的操作，可以忽略对象组合（子菜单）和个别对象（菜品）的差别。 组合模式的UML图如下，接下来我们就要根据这个类图来编写本案例引入组合模式的代码，我已在图上红字标出本例中涉及到的类分别对应的组合模式角色。 组合模式的UML图 代码第一步，编写菜单项这一抽象父类代码再次强调，菜品可以作为菜单项，子菜单也可以作为菜单项，所以作为菜品和子菜单的共同接口，菜单项既要规定菜品有的方法，也要规定子菜单有的方法。 对于子菜单，它需要的方法有：添加菜单项、删除菜单项等。 对于菜品，它需要的方法有：获取菜品名、获取价格等。 子菜单需要的全体方法+菜品需要的全体方法就构成了菜单项抽象类的方法了。 123456789101112131415161718192021222324252627282930313233343536package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/26 * @used to: 菜单项（子菜单+菜品）的共同接口，抽象类实现 * 其中，有部分方法只针对子菜单有意义，有部分方法只针对菜品有意义，有部分方法对于它们都有意义，提供统一操作 */public abstract class MenuComponent &#123; public void add(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; public void remove(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; public MenuComponent getChild(int i)&#123; throw new UnsupportedOperationException(); &#125; public String getName()&#123; throw new UnsupportedOperationException(); &#125; public String getDescription()&#123; throw new UnsupportedOperationException(); &#125; public double getPrice()&#123; throw new UnsupportedOperationException(); &#125; public boolean isVergetarian()&#123; //是否是蔬菜 throw new UnsupportedOperationException(); &#125; public void print()&#123; throw new UnsupportedOperationException(); &#125;&#125; 在这个抽象类接口中，我们要注意，有些方法，比如说add()、remove()，只针对子菜单这一菜单项有意义而菜品这一菜单项不需要，而有些方法，比如说getPrice()，只针对菜品这一菜单项有意义而子菜单这一菜单项不需要， 正是因为子类菜品不需要其中的某些方法，而子菜单不需要另外一些方法，所以在抽象类的默认实现中，都抛出了异常。 而print()方法是一个”操作方法“，则可看作菜品和菜单项两者共同的操作。 至此，就完成了就是菜单项父类代码的编写（对应上面UML建模图中的Component角色），接下来就来完成其子类的代码，其子类包括菜品（对应Leaf角色）和子菜单（对应Composite角色）。 第二步，编写菜单项的两个子类代码菜品类和子菜单类只要挑选抽象父类中自己感兴趣的、有意义的方法实现即可。 菜品类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/30 * @used to: 菜单项的子类之一--菜品类 */public class MenuItem extends MenuComponent &#123; String name; //名称 String desc; //描述 boolean vegetarian; //是否为蔬菜 double price; //价格 public MenuItem(String name, String desc, boolean vegetarian, double price) &#123; this.name = name; this.desc = desc; this.vegetarian = vegetarian; this.price = price; &#125; public String getName()&#123; return name; &#125; public String getDescription() &#123; return desc; &#125; public double getPrice() &#123; return price; &#125; public boolean isVergetarian() &#123; return vegetarian; &#125; public void print() &#123; String item = \"MenuItem&#123;\" + \"name='\" + name + '\\'' + \", desc='\" + desc + '\\'' + \", vegetarian=\" + vegetarian + \", price=\" + price + '&#125;'; System.out.println(item); &#125;&#125; 子菜单类： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hfq.headfirstjava.charpter9.composite;import java.util.ArrayList;/** * @Created by hfq on 2020/4/30 * @used to: 子菜单类 */public class Menu extends MenuComponent&#123; ArrayList menuComponents = new ArrayList(); //组合了一个ArrayList对象来保存子菜单的所有菜单项 String name; String description; public Menu(String name, String description) &#123; this.name = name; this.description = description; &#125; public void add(MenuComponent menuComponent)&#123; menuComponents.add(menuComponent); &#125; public void remove(MenuComponent menuComponent)&#123; menuComponent.remove(menuComponent); &#125; public MenuComponent getChild(int i)&#123; return (MenuComponent) menuComponents.get(i); &#125; public String getName()&#123; return name; &#125; public String getDescription()&#123; return description; &#125; public void print()&#123; //难点 System.out.println(name+\"(\"+description+\")\"); System.out.println(\"--------------------------------\"); Iterator iterator = menuComponents.iterator(); while (iterator.hasNext())&#123; MenuComponent menuComponent = (MenuComponent) iterator.next(); menuComponent.print(); //递归调用子菜单的所有菜单项print方法 &#125; &#125;&#125; 第三步，编写服务员类的代码服务员类对应上面UML建模图中的Client客户角色。 12345678910111213141516171819202122232425262728293031323334353637package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/30 * @used to: 引入组合模式后的服务员类，是菜单的客户(UML类图中的Client) */public class Waitress &#123; MenuComponent allMenus; public Waitress(MenuComponent allMenus) &#123; this.allMenus = allMenus; &#125; public void printMenu()&#123; allMenus.print(); &#125; //测试代码 public static void main(String[] args) &#123; MenuComponent totalMenu = new Menu(\"总菜单\",\"存放所有分菜单\"); MenuComponent breakfastMenu = new Menu(\"早餐菜单\",\"含有各种早餐\"); breakfastMenu.add(new MenuItem(\"肉包子\",\"有猪肉的包子\",false,2.0)); breakfastMenu.add(new MenuItem(\"菜包子\",\"有香菇的包子\",true,1.0)); breakfastMenu.add(new MenuItem(\"烙饼\",\"荤素搭配的烙饼\",false,3.0)); MenuComponent dinnerMenu = new Menu(\"正餐菜单\",\"含有各种饭,还包含了一个甜品菜单\"); dinnerMenu.add(new MenuItem(\"鸡腿饭\",\"有红烧鸡腿\",false,10.0)); dinnerMenu.add(new MenuItem(\"牛肉饭\",\"有香辣牛肉\",false,15.0)); MenuComponent dessertMenu = new Menu(\"甜品菜单\",\"包含多种甜品\"); dessertMenu.add(new MenuItem(\"烧仙草\",\"美味的烧仙草\",false,3.0)); dessertMenu.add(new MenuItem(\"绿豆汤\",\"清爽的绿豆汤\",true,1.0)); dinnerMenu.add(dessertMenu); totalMenu.add(breakfastMenu); totalMenu.add(dinnerMenu); Waitress waitress = new Waitress(totalMenu); waitress.printMenu(); &#125;&#125; 上述测试代码打印菜单的结果如下所示，成功达到我们的目标： 测试打印整张菜单的结果 为了让显示效果好一点，看得出菜单嵌套的层级效果，我又对上面的代码做了略微的改动，print()方法加了一个String类型的前缀，具体实现请移步Github。如下图，改动后，能在打印结果看出来甜品菜单是正餐菜单的子菜单。 改动后的显示效果具有层次 总结组合模式中让组件接口（对应于本例中的菜单项的抽象类）同时包含一些管理子节点（子菜单）和叶子节点（菜单项）的操作，客户(Client)就可以将组合和叶节点一视同仁，也就是说，一个元素究竟是组合还是叶节点，对用户是透明的，在案例中，即使是用户不知道一个菜单项究竟是子菜单还是普通菜品的情况下，也能调用统一的print方法打印。 然而，组合模式这种做法失去了一些“安全性”，这是因为客户有机会对一个元素做不恰当或者是没有意义的操作(列入本例中试图调用一个菜品对象的add方法，菜品类继承了菜单项抽象类，所以它有add方法，但是这个add方法实际上是为子菜单类服务的，而对菜品类无意义)。假如我们将菜品和子菜单各自需要的方法区分开来放到不同的接口里，客户代码就必须用条件语句和instanceof操作符来区别对待不同类型的节点(菜品和子菜单)。 所以说，使用组合模式是便利性和违背涉及原则折衷的一个选择。 组合迭代器分别学完了迭代器模式和组合模式之后，来看看它们共同作用会什么样的火花吧，亲密无间的配合也是它们放在同一个章节的原因。 我们可以这样理解，在上文介绍迭代器模式时的场景中，菜单集合是一维的，因为其集合元素都是菜品，而组合模式中的案例场景中，菜单结构是有嵌套层次的。针对一个元素全都是菜品对象的普通的菜单集合，构建它的迭代器很简单，而对于构建像这一树形层次结构的集合的迭代器又该如何做呢？","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"密码测试文章","date":"2020-04-25T16:52:33.000Z","path":"2020/04/26/密码测试文章/","text":"我的名字（全小写）？26370213ec222ab70d5b0a28fe3afc58ad364a9a8e644a0f27472f05678679b7b447aa193cd5f8e634c1f8a6c2f3768287d7d05195b8437b8f646f274a57e68d8ef79fdcd15cfb3b7b027b1c73e04d51","tags":[{"name":"日常","slug":"日常","permalink":"http://hfq123.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"【每日更新】算法题","date":"2020-04-21T12:17:21.000Z","path":"2020/04/21/【每日更新】算法题/","text":"20200531 晴截止昨日，剑指Offer刷题进度：56/67，Leetcode 40/148 ，已坚持每天刷3题的天数：17。 题1 电话号码的字母组合12345678910111213141516171819202122232425class Solution &#123; static String [] keyboard = &#123;\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; if(digits==null||digits.length()==0) return new ArrayList&lt;String&gt;(); StringBuilder oneResult = new StringBuilder(); //记录一种可能的结果 List&lt;String&gt; res = new ArrayList&lt;String&gt;(); backtrace(digits,0,oneResult,res); //回溯求解 return res; &#125; //index表示处理到第index位数字了 public void backtrace(String digits,int index,StringBuilder oneResult,List&lt;String&gt; res)&#123; if(index==digits.length())&#123; res.add(new String(oneResult)); return ; &#125; int digit = digits.charAt(index)-'0'; for(int i =0; i&lt;keyboard[digit-2].length();i++)&#123; //遍历这个数字对应的所有可能的字母 oneResult.append(keyboard[digit-2].charAt(i)); backtrace(digits,index+1,oneResult,res); //回溯求解 oneResult.deleteCharAt(oneResult.length()-1); &#125; &#125;&#125; 题3 【待改进】 全排列的第K个排列这是牛客网leetcode148的题，此份代码是按照求全排列那题的做法，加了一个计数器，也就是说，计算第K个排列之前也会把K-1个排列算出来，效率不行，算是练练手，待改进。 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Solution &#123; /** * * @param n int整型 * @param k int整型 * @return string字符串 */ int cnt=0; String res; public String getPermutation (int n, int k) &#123; StringBuilder path = new StringBuilder(); boolean used[] = new boolean[n]; dfs(0,n,k,path,used); return res; &#125; public void dfs(int index,int n, int k,StringBuilder path,boolean used[]) &#123; if(index == n)&#123; cnt++; if(cnt==k)&#123; res = new String(path); &#125; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!used[i-1])&#123; path.append(i); used[i-1] = true; dfs(index+1,n,k,path,used); path.deleteCharAt(path.length()-1); used[i-1] = false; &#125; &#125; &#125;&#125; 题2 组合总和 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 注意这题数字都可能重复使用，所以每次选择数字的时候都可以重复选择，这就会产生重复的情况。 比如说[2，2，3],7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(candidates==null||candidates.length==0)&#123; return res; &#125; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); backtrace(candidates,0,target,path,res); return res; &#125; public void backtrace(int[] candidates, int pre,int target,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(target==0)&#123; res.add(new ArrayList(path)); return; &#125; if(target&lt;0)&#123; return; &#125; for(int i=pre;i&lt;candidates.length;i++)&#123; path.add(candidates[i]); backtrace(candidates,i,target-candidates[i],path,res); path.remove(path.size()-1); &#125; &#125;&#125;//对照下面不能去重的代码：class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(candidates==null||candidates.length==0)&#123; return res; &#125; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); backtrace(candidates,target,path,res); return res; &#125; public void backtrace(int[] candidates, int target,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(target==0)&#123; res.add(new ArrayList(path)); return; &#125; if(target&lt;0)&#123; return; &#125; for(int i=0;i&lt;candidates.length;i++)&#123; path.add(candidates[i]); backtrace(candidates,target-candidates[i],path,res); path.remove(path.size()-1); &#125; &#125;&#125; //此代码没有考虑到去除重复结，比如说[2,3,6,7],7,返回结果有重复,有[2,2,3],[2,3,2],[3,2,2]... backtrace方法的参数pre设置得很巧妙，能避免重复结果。 下面的代码多设立了一个pre参数就缩短了下一次搜索的解空间，同时避免了重复。说的不是很清楚，参考下图意会： image-20200531195725771 20200530 晴今天学了回溯算法思想。目前计划是边学算法思想，边刷相关的题作为复习，换了给新题库：LeetCode HOT 100，换题库的原因：牛客网上的相关题目少，而且题解少，不便于上手。 题1 N皇后的摆法数目题2 N皇后的所有摆法题3 括号生成题4 不重复数组的全排列 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 思路没错，因为引用的问题修改了几次就过了： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; //判断数组里的每个元素是否已经用过了 static boolean used[]; static List&lt;List&lt;Integer&gt;&gt; res; static List&lt;Integer&gt; oneResult; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; oneResult = new ArrayList&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; oneResult.add(0); //无意义 &#125; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); used = new boolean[nums.length]; palce(0,nums); return res; &#125; //放置list的第n个位置 public void palce(int n,int [] nums)&#123; if(n == nums.length)&#123; res.add(new ArrayList(oneResult)); //注意这里不能直接res.add(oneResult) return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(!used[i])&#123; oneResult.set(n,nums[i]); used[i] = true; palce(n+1,nums); //递归放置下一位 used[i] = false; //回溯，重置used状态 &#125; &#125; &#125;&#125; 题5 子集这题AC了，代码写的不太好，先不放出来了，下次再做一遍。 20200529 晴截止昨日，剑指Offer刷题进度：56/67，Leetcode 40/148 ，已坚持每天刷3题的天数：16。 汉诺塔问题。 题1 面试题 08.06. 汉诺塔问题 汉诺塔 123456789101112131415161718192021class Solution &#123; //A:起点，C：终点 B：临时 public void hanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) &#123; hanota(A.size(),A,B,C); &#125; // public void hanota(int n,List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) &#123; if(n==1)&#123; move(A,C); return; &#125; hanota(n-1,A,C,B); move(A,C); hanota(n-1,B,A,C); &#125; //将单个盘子从from移动到to public void move(List &lt;Integer&gt; from,List &lt;Integer&gt; to)&#123; to.add(from.remove(from.size()-1)); &#125;&#125; 题2 108. 将有序数组转换为二叉搜索树 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 标题说的是BST，实际上说的更准确是AVL 再次吐槽一下牛客的测试用例，这份正确代码在Leetcode可以通过但是在牛客不能，原因是AVL的建立结果不一定是唯一的。 12345678910111213141516171819class Solution &#123; public TreeNode sortedArrayToBST (int[] nums) &#123; // write code here if(nums==null) return null; return sortedArrayToBST(nums,0,nums.length-1); &#125; public TreeNode sortedArrayToBST (int[] nums,int begin,int end) &#123; // write code here if(begin&gt;end) return null; int mid = (end-begin)/2+begin; TreeNode root = new TreeNode(nums[mid]); root.left = sortedArrayToBST(nums,begin,mid-1); root.right = sortedArrayToBST(nums,mid+1,end); return root; &#125;&#125; 题3 删除有序数组的重复元素2 继续思考题目”Remove Duplicates”: 如果数组中元素最多允许重复两次呢？ 例如： 给出有序数组 A =[1,1,1,2,2,3], 你给出的函数应该返回length =5, A 变为[1,1,2,2,3]. 在原题基础上设置一个是否还允许重复的标记即可。 123456789101112131415161718192021222324public class Solution &#123; //把数组A的所有元素重新原地添加一遍 public int removeDuplicates(int[] A) &#123; if(A==null) return 0; int index = 1; //当前要添加的位置 boolean flag = true; //允许当前元素再出现一次 for(int i=1;i&lt;A.length;i++)&#123; if(A[i]==A[i-1])&#123; if(flag)&#123; A[index++] = A[i]; flag = false; //重置标记 &#125;else&#123; //donothing &#125; &#125;else&#123; //说明当前元素是新的元素，允许有一次重复 A[index++] = A[i]; flag = true; &#125; &#125; return index; &#125;&#125; 看了别人的代码,拍案叫绝(注意题目前提是数组是有序的)： 1234567891011121314151617链接：https://www.nowcoder.com/questionTerminal/567f420f12ed4069b7e1d1520719d409?f=discussion来源：牛客网class Solution &#123;public: int removeDuplicates(int A[], int n) &#123; if(n&lt;=2) return n; int index=2;//允许重复两次，可以修改为三次 for(int i=2;i&lt;n;i++) &#123; if(A[i]!=A[index-2])//允许重复两次，可以修改为三次 A[index++]=A[i]; &#125; return index; &#125;&#125;; 20200528 晴截止昨日，剑指Offer刷题进度：55/67，Leetcode 38/148 ，已坚持每天刷3题的天数：15。 题1 【待改进】字符流中第一个不重复的字符 题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 123456789101112131415161718192021public class Solution &#123; //Insert one char from stringstream StringBuilder str = new StringBuilder(); int hash[] = new int [256]; public void Insert(char ch) &#123; str = str.append(ch); hash[ch]++; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; for(int i=0;i&lt;str.length();i++)&#123; if(hash[str.charAt(i)] == 1)&#123; return str.charAt(i); &#125; &#125; return '#'; &#125;&#125; 题2 【待熟练】 为普通二叉树的每个节点设置右节点原题见：20200503-题3。 这两题的思路是一样的： 从根节点开始层序遍历，遍历时设置左孩子和右孩子的next指针，然后到达下一层是通过这一层的首个结点的孩子（如果有左孩子下一层首个结点就是其左孩子，否则是右孩子）。 区别就在于，在完全二叉树中，下一层的首个孩子肯定是这一层的第一个结点的左孩子，而在普通二叉树中，就不确定了。 图解本题思路 1234567891011121314151617181920212223242526public class Solution &#123; public void connect(TreeLinkNode root) &#123; //node为工作结点指针 TreeLinkNode node = root; //把下一层的所有结点从左到右用next指针串成一个链表，dummy就是下一层这个链表的无意义头节点 TreeLinkNode dummy = new TreeLinkNode(0); //tail为下一层链表的尾结点,便于在链表尾插元素的时候使用 TreeLinkNode tail; while(node!=null)&#123; dummy.next = null; //每遍历完了一层，需要重置dummy.next和tail的值 tail = dummy; while(node!=null)&#123; if(node.left!=null)&#123; //如果这个结点的左孩子存在，就把它加入链表 tail.next = node.left; tail = tail.next; &#125; if(node.right!=null)&#123; //如果这个结点的右孩子存在，就把它加入链表 tail.next = node.right; tail = tail.next; &#125; node = node.next; &#125; node = dummy.next; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031错误代码。。。public class Solution &#123; public void connect(TreeLinkNode root) &#123; if(root==null) return; //node是工作结点指针 TreeLinkNode node = root; //nextFirstNode是下一层的首个结点指针 TreeLinkNode nextFirstNode = root.left!=null?root.left:root.right; while(node!=null)&#123; //记录是否已经找到了下一层第一个结点 boolean flag = false; nextFirstNode =null; while(node!=null)&#123; if(!flag)&#123; nextFirstNode = node.left!=null?node.left:node.right; if(nextFirstNode!=null) flag=true; &#125; if(node.left!=null)&#123; node.left.next = node.right; &#125; if(node.next!=null &amp;&amp; node.right!=null)&#123; node.right.next = node.next.left; &#125; node = node.next; &#125; node = nextFirstNode; &#125; &#125;&#125; 题3 数组表示的数加一 ​ 给出用数字数组表示的一个非负整数，请对该整数加1。 [1,2,3] —&gt; [1,2,4] 这题一次过了，题目不难，要注意写代码前考虑全面一点，尤其是特殊情况。 [2,9]-&gt;[3,0] , [9,9]-&gt;[1,0,0] 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Solution &#123; /** * * @param digits int整型一维数组 * @return int整型一维数组 */ public int[] plusOne (int[] digits) &#123; //测试用例设计：89、99、100 //个位不等于9，直接在个位+1 //个位=9，个位变成0，十位+1，如果十位又溢出，百位再进位 int [] res = new int[digits.length]; //不溢出的情况 int carry=1; //进位 for(int i=digits.length-1;i&gt;=0;i--)&#123; res[i] = digits[i]+carry; //个位 carry=0; if(res[i]==10)&#123; res[i]=0; carry=1; &#125; &#125; //最后如果还有进位，说明要多加一位1在最前面 if(carry==1)&#123; int [] res2 = new int [res.length+1]; res2[0] = 1; for(int i=0; i&lt;res.length;i++)&#123; res2[1+i] = res[i]; &#125; return res2; &#125; return res; &#125;&#125; 2020527 晴截止昨日，剑指Offer刷题进度：55/67，Leetcode 35/148 ，已坚持每天刷3题的天数：14。 此文件陆陆续续大概记录了一个月的题了，马上3w个字了，打开比较慢，6月开始换个新文件记录。 题1 O(n)求无序序列最长的连续元素的长度 给定一个无序的整数类型数组，求最长的连续元素序列的长度。 例如： 给出的数组为[100, 4, 200, 1, 3, 2], 最长的连续元素序列为[1, 2, 3, 4]. 返回这个序列的长度：4 你需要给出时间复杂度在O（n）之内的算法 注意：这题不重复计算重复元素：比如说测试用例0，0，-1返回2而不是3。 很容易想到通过先对数组排序，然后遍历一遍求连续序列的最大长度，但是这样做明显不符合O(n)时间复杂度的需求。 那能怎么样？所以想到空间换时间，想到HashMap，我一开始也是朝着这个方向想的: 遍历数组时将数组元素加入到map，同时，判断它的前一个和后一个元素是否在map里，比如说遍历到100，就去map里找看有没有99或者101，如果有的话，就将最大长度计数器+1，比如说数组是100，99，98，10，计数器初始化为1，从99开始遍历，查map发现有100，计数器+1变成2，遍历第二个元素98时查到99在map里，计数器再+1变成3，最后遍历10，发现map里没有9也没有11，计数器重置变成1，最后返回结果时返回值最大的计数器（这个只需要设置一个变量每次重置计数器前判断是否覆盖就行）。 但是一想这样做有个问题：比说数组的顺序是：1、3、2，计数器初始化为1，遍历3，发现没有2也没有1（没有2是因为这个时候2还没有被遍历到），计数器重置为1，下一个元素遍历2，发现有1，计数器+1变成2，最后返回计数器最大值2而实际上这个用例应该返回3。 后来把这个方案否决了，看题解，还真和HashMap有关，起码方向对了。题解是先遍历一遍先把数组所有的元素都加入到map,这样就避免了上面的错误情况， Iterator it = map.iterator(); while(it.hasNext()){ cnt+=it.next().getValue(); } 错误写法12345678910111213141516171819 //错误写法！！！//一开始我想到如果一个数的左右邻居不在，就删除，否则就保留，最后返回set里的元素个数。//对的用例：1、4、5、6，返回3 //为什么错： 比如 1、2、4、5、6，最后会返回5，写这份代码的时候还是没考虑清楚。。public int longestConsecutive (int[] num) &#123; if(num==null || num.length ==0)&#123; return 0; &#125; HashSet &lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0;i&lt;num.length;i++)&#123; set.add(num[i]); &#125; for(int i=0;i&lt;num.length;i++)&#123; if(!set.contains(num[i]-1) &amp;&amp; !set.contains(num[i]+1) )&#123; set.remove(num[i]); &#125; &#125; return set.size()&gt;1?set.size():1; &#125; 正确代码如下： 12345678910111213141516171819202122232425262728293031public class Solution &#123; public int longestConsecutive (int[] num) &#123; if(num==null || num.length ==0)&#123; return 0; &#125; HashSet &lt;Integer&gt; set = new HashSet&lt;&gt;(); //这个循环的时间复杂度是O(n) for(int i=0;i&lt;num.length;i++)&#123; set.add(num[i]); &#125; int cnt = 1 ,maxCnt = 1; //这个循环的时间复杂度是O(n) for(int i=0;i&lt;num.length;i++)&#123; int left = num[i]-1,right = num[i]+1; cnt = 1; while(set.contains(left))&#123; set.remove(left--); //如果存在就移除 cnt++; &#125; while(set.contains(right))&#123; set.remove(right++); cnt++; //如果存在就移除 &#125; set.remove(num[i]); // 遍历一个元素后就移除， if(cnt&gt;maxCnt) maxCnt = cnt; &#125; return maxCnt; &#125;&#125; 题2 就地移除排序数组的重复元素 给定一个已排序的数组，使用就地算法将重复的数字移除，使数组中的每个元素只出现一次，返回新数组的长度。 不能为数组分配额外的空间，你必须使用常熟级空间复杂度的就地算法。 例如，给定输入数组 A=[1,1,2]， 你给出的函数应该返回length=2，A数组现在是[1,2]。 这题还是比较有技巧性的，思想也是双指针，和昨天做的“移除元素”那题是同一个思路。 如下代码，i作为遍历指针，index作为插入不重复元素的指针。 123456789101112public class Solution &#123; public int removeDuplicates(int[] A) &#123; //记录当前所有不重复元素部分的索引 int index = 1; for(int i =1;i&lt;A.length;i++)&#123; if(A[i]!=A[i-1])&#123; A[index++] = A[i]; &#125; &#125; return index; &#125;&#125; 题3 【待debug】括号匹配最长子串的长度 给出一个仅包含字符’(‘和’)’的字符串，计算最长的格式正确的括号子串的长度。 对于字符串”(()”来说，最长的格式正确的子串是”()”，长度为2. 再举一个例子：对于字符串”)()())”,来说，最长的格式正确的子串是”()()”，长度为4. 我的思路：如果是左括号就压入栈，如果是右括号就弹栈，如果发现弹栈成功，计数器+1，否则，计数器重置。 提交通过65%测试用例。 正确做法： 栈保存左括号出现的下标。 占坑待填。 题4 找出有序数组中某个数的出现位置和结束位置 给出一个有序数组，请在数组中找出目标值的起始位置和结束位置 你的算法的时间复杂度应该在O(log n)之内 如果数组中不存在目标，返回[-1, -1]. 例如： 给出的数组是[5, 7, 7, 8, 8, 10]，目标值是8, 返回[3, 4]. [5, 7, 7, 8, 8, 10] , 设计测试用例： 7，8，0，11 优雅的代码，无论在何种情况下，时间复杂度都会是2*log(n) 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; /** * * @param A int整型一维数组 * @param target int整型 * @return int整型一维数组 */ public int[] searchRange (int[] A, int target) &#123; int [] res = new int[2]; res[0] = insertIndex(A,target-0.5); res[1] = insertIndex(A,target+0.5); if(res[0] == res[1])&#123; //如果res[0]和res[1]相等，说明target必定不存在！ res[0]=-1; res[1]=-1; &#125;else&#123; //如果存在target,右边界res[1]还得减1 res[1] -=1; &#125; return res; &#125; //返回一个double类型的小数在有序数组A中应该插入的位置下标 public int insertIndex(int []A,double target)&#123; int i = 0,j=A.length-1,mid; while(i&lt;=j)&#123; mid = (i-j)/2+j; if(A[mid] &gt; target)&#123; j=mid-1; &#125;else&#123; i=mid+1; &#125; &#125; return i; //最后i就是小数target应该插入到A元素中的下标 &#125;&#125; 2020526 雨截止昨日，剑指Offer刷题进度：55/67，Leetcode 32/148 ，已坚持每天刷3题的天数：13。 题1 【待熟练】 单向链表的插入排序提示：不要把有序部分和无序部分在同一个链表操作，而是把维护的有序部分单独拿出来！！ 这题卡了很久，我一开始的想法是在原链表的基础上调整指针，发现要用到很多指针，很绕而且一直理不清思路没做出来。后来看题解才意识到，可以直接用一个新链表保存目前已排序的链表（只需要new一个无意义头节点，对于数据结点来说，只是修改指针指向，不会new新节点），保持此链表有序的条件下逐个插入，没必要在一条链表里保持有序部分和无序部分。 解法对比 此题正确姿势： 1234567891011121314151617181920public class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; //链表已排序部分的无意义头结点 ListNode dummy = new ListNode(0); //pre用来记录dummy链表中最后一个比待插入元素小的元素 ListNode pre; //head可以直接作为工作结点 while(head!=null)&#123; ListNode headNext = head.next; pre = dummy; while(pre.next!=null &amp;&amp; head.val &gt; pre.next.val)&#123; pre = pre.next; &#125; head.next = pre.next; pre.next = head; head = headNext; &#125; return dummy.next; &#125;&#125; 题2 根据x值划分链表 给出一个链表和一个值x，以x为参照将链表划分成两部分，使所有小于x的节点都位于大于或等于x的节点之前。 两个部分之内的节点之间要保持的原始相对顺序。 例如： 给出1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2和x = 3, 返回1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 这题套路和上一题很像，可别再傻乎乎地直接在原链表操作了。 思路：新建两个链表，小于x的放到一个链表里面，不小于的放到另一个链表里，然后拼接这两个链表。 注意新建链表无需新建数据结点，只要修改指针就行了，不过为了方便写代码，每个链表new了两个头尾结点。 123456789101112131415161718192021222324public class Solution &#123; public ListNode partition (ListNode head, int x) &#123; //由所有元素值小于x的结点组成的链表的无意义头节点、尾结点 ListNode dummy1 = new ListNode(0) ,tail1 = dummy1; //由所有元素值大于等于x的结点组成的链表的无意义头节点、尾结点 ListNode dummy2 = new ListNode(0),tail2 = dummy2; //head作为原链表中的工作结点指针 while(head!=null)&#123; ListNode headNext = head.next; if(head.val &lt; x)&#123;//如果元素值小于规定值，将其加入dummy1链表 head.next = null; tail1.next = head; tail1 = tail1.next; &#125;else&#123;//如果元素值大于等于规定值，将其加入dummy2链表 head.next = null; tail2.next = head; tail2 = tail2.next; &#125; head = headNext; &#125; tail1.next = dummy2.next; return dummy1.next; &#125;&#125; 题3 移除元素 给定一个数组和一个值，使用就地算法将数组中所有等于这个值的元素删除，并返回新数组的长度。 元素的顺序可以更改。你不用去关心大于当前数组长度的空间里面存储的值 我已经走火入魔了。。最开始的思路是类似快速排序的partition方法的双指针，还没做出来。把问题想的太复杂了，忽略了最简单的。实际上就这么简单： 1234567891011public class Solution &#123; public int removeElement(int[] A, int elem) &#123; int cnt = 0; for(int i=0;i&lt;A.length;i++)&#123; if(A[i]!=elem)&#123; A[cnt++] = A[i]; &#125; &#125; return cnt; &#125;&#125; ps：牛客网的这道题的测试用例有毒，通过不了。 123456789101112131415161718192021222324252627282930！！！ 错误代码。引以为鉴public class Solution &#123; public int removeElement(int[] A, int elem) &#123; int end = A.length-1; int begin = 0; int lastElem = end+1; //记录elem最后出现的下标 if(begin==end &amp;&amp; A[0]==elem)&#123; //只有一个元素 return 0; &#125;else if(begin==end &amp;&amp; A[0]!=elem)&#123; return 1; &#125; while(begin&lt;end)&#123; //从后往前，后面的指针找不指向elem的元素 while(begin&lt;end &amp;&amp; A[end]==elem)&#123; end--; &#125; //从前往后，前面的指针找指向elem的元素 while(begin&lt;end &amp;&amp; A[begin]!=elem)&#123; begin++; &#125; if(begin!=end)&#123; int tmp = A[begin]; A[begin] = A[end]; A[end] = tmp; lastElem = end; &#125; &#125; return lastElem-1; &#125;&#125; 20200525 雨截止昨日，剑指Offer刷题进度：55/67，Leetcode 29/148 ，已坚持每天刷3题的天数：12。 题1 合并两个有序数组 给出两个有序的整数数组A和B，请将数组B合并到数组A中，变成一个有序的数组注意：可以假设A数组有足够的空间存放B数组的元素，A和B中初始的元素数目分别为m和n 今天刚复习了归并排序。这题其实就是归并排序中的merge操作。 一开始我按照归并排序的merge操作的思路写了如下代码（可以AC但是开辟了新的数组）： 12345678910111213141516171819202122232425262728public class Solution &#123; public void merge(int A[], int m, int B[], int n) &#123; //先拷贝A数组的有效数据 int copyA[] = new int[m]; for(int i=0;i&lt;m;i++)&#123; copyA[i] = A[i]; &#125; //pa、pb、pc分别是copyA、B、A三个数组的工作指针 int pa = 0,pb=0,p=0; while(pa&lt;m &amp;&amp; pb&lt;n)&#123; if(copyA[pa]&lt;=B[pb])&#123; A[p++]=copyA[pa++]; &#125;else&#123; A[p++]=B[pb++]; &#125; &#125; while(pa&lt;m)&#123; A[p++]=copyA[pa++]; &#125; while(pb&lt;n```j \\ )&#123; A[p++]=B[pb++]; &#125; &#125;&#125; 既然A数组已经可以存放下A+B的所有元素了，再开辟新的数组貌似有些多余。果然，有更好的办法： 我们可以从右到左插入元素（元素值从大到小）。按照此思路优化后： 123456789101112131415161718public class Solution &#123; public void merge(int A[], int m, int B[], int n) &#123; //pa和pb分别指向A和B数组的最后一个有效元素的下标，作为工作指针 int pa=m-1,pb=n-1; //p初始化为A、B中最大的元素在A数组中的下标 int p=m+n-1; while(pa&gt;=0&amp;&amp;pb&gt;=0)&#123; if(A[pa]&gt;=B[pb])&#123; A[p--] = A[pa--]; &#125;else&#123; A[p--] = B[pb--]; &#125; &#125; while(pb&gt;=0)&#123; A[p--] = B[pb--]; &#125; &#125;&#125; 题2 根据逆波兰表达式求四则运算结果栈的经典应用。 比如说 1+2X3的逆波兰表达式是：1、2、*、3 +，使用逆波兰表达式计算时，遇到操作数，直接入栈，遇到符号，弹出栈顶的两个操作数计算后入栈。 需要注意，对于加法和乘法不影响，对于减法和除法要注意是运算数的顺序。举个例子：3/1的逆波兰表达式是 3、1、/，根据逆波兰表达式计算的时候，3先压栈，1再压栈，遇到/，弹栈获得第①个操作数是1，第②个操作数是3，注意要第二个操作数/第一个操作数，减法同理。 用到了Integer类的valueOf(token)方法将整数字符串转成整数。 1234567891011121314151617181920212223242526272829import java.util.Stack;public class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i =0; i&lt;tokens.length; i++)&#123; String token = tokens[i]; if(token.equals(\"+\"))&#123; Integer op1 = stack.pop(); Integer op2 = stack.pop(); stack.push(op2+op1); &#125;else if(token.equals(\"-\"))&#123; Integer op1 = stack.pop(); Integer op2 = stack.pop(); stack.push(op2-op1); &#125;else if(token.equals(\"*\"))&#123; Integer op1 = stack.pop(); Integer op2 = stack.pop(); stack.push(op2*op1); &#125;else if(token.equals(\"/\"))&#123; Integer op1 = stack.pop(); Integer op2 = stack.pop(); stack.push(op2/op1); &#125;else&#123;//如果不是加减乘除，就是整数了 stack.push(Integer.valueOf(token)); &#125; &#125; return stack.pop(); &#125;&#125; 题3 打印指定行数的杨辉三角 给出一个值numRows，生成杨辉三角的前numRows行 例如，给出 numRows = 5, 返回 1234511 11 2 11 3 3 11 4 6 4 1 题目不难，理清楚思路就好了。 对于每一行row来说，都有如下规律: row[0] = 1, row[i] = lastRow[i]]+lastRow[i-1]，(0&lt; i &lt; rowNum)，其中lastRow表示上一行,rowNum表示该行的行标（从0开始） row[rowNum]=1，rowNum表示该行的行标（从0开始)。 1234567891011121314151617181920212223242526272829import java.util.*;public class Solution &#123; /** * * @param numRows int整型 * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt; */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; generate (int numRows) &#123; ArrayList &lt;ArrayList&lt;Integer&gt;&gt; lists = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList &lt;Integer&gt; lastRow = new ArrayList&lt;&gt;(); ;//记录上一行 for(int i=0;i&lt;numRows;i++)&#123; ArrayList &lt;Integer&gt; row = new ArrayList&lt;&gt;(); //每行的第一个元素都是1，直接加入 row.add(1); for(int j=1;j&lt;=i;j++)&#123; if(j==i)&#123; //最后一个元素是1 row.add(1); &#125;else&#123; //除了第一个和最后一个，别的元素根据上一行计算 row.add(lastRow.get(j)+lastRow.get(j-1)); &#125; &#125; lists.add(row); lastRow = row; &#125; return lists; &#125;&#125; 20200524 晴截止昨日，剑指Offer刷题进度：55/67，Leetcode 26/148 ，已坚持每天刷3题的天数：11。 题1 根据前序和中序序列构建二叉树思路：递归解决。 1234567891011121314151617181920212223242526272829303132public class Solution &#123; /** * * @param preorder int整型一维数组 * @param inorder int整型一维数组 * @return TreeNode类 */ public TreeNode buildTree (int[] preorder, int[] inorder) &#123; if(preorder==null) return null; return getRoot(preorder,0,preorder.length-1,inorder,0,inorder.length-1); &#125; //此方法的作用是返回 前序序列是pre[i1..j1]、中序序列是inorder[i2..j2]的树的根节点 public TreeNode getRoot(int [] preorder,int i1,int j1,int [] inorder,int i2,int j2)&#123; if(i1&gt;j1) return null; TreeNode root = new TreeNode(preorder[i1]); //leftJ记录左子树中最后一个结点在前序序列中的下标 int leftJ = i1; int i; for(i=i2;i&lt;=j2;i++) &#123; if(inorder[i]==preorder[i1]) break; leftJ++; &#125; //循环退出时，i指向了中序序列中的根节点，i-1就是中序序列左子树的最后一个结点 root.left = getRoot(preorder,i1+1,leftJ,inorder,i2,i-1); root.right = getRoot(preorder,leftJ+1,j1,inorder,i+1,j2); return root; &#125;&#125; 题2 【待熟练】 迭代求二叉树的中序遍历序列之前做过了用迭代的方法求前序和后序遍历的题。 先简单回顾一下: 迭代的方式后序遍历：先把root压栈，当栈不空，按照如下三个步骤循环访问栈顶结点： 1、栈顶结点弹栈，打印该节点的值 2、把该节点的右孩子压入栈（如果有的话） 3、把该节点的左孩子压入栈（如果有的话） 迭代的方式后序遍历：先把root压栈，当栈不空，按照如下方式循环处理栈顶结点，分为两种情况： 如果该节点是非叶子结点，且其孩子还没访问过，就先不访问，而是先让其孩子入栈： 先将其右孩子压入栈（如果有的话） 再加入其左孩子压入栈（如果有的话） 如果该节点是叶子结点（没有孩子），或者该节点的孩子已经访问完了（前一个访问结点是其孩子），就将该结点弹栈打印。 思考为什么：因为对于后序遍历来说，访问次序是左、右、根，如果左右孩子还没有访问过，那么一定不会直接访问根，而由于是用栈临时存储结点，所以压栈次序应该是根、右、左，这样后进先出的结果就符合后序遍历的左、右、根。 同理，对于中序遍历来说，访问次序是左、根、右，类比后序遍历的规律，中序遍历中，如果左孩子还没有访问过，那么一定不会直接访问根结点。根据这个思路，就得到了迭代方式求中序序列的方法：先把根节点，再把左子树压入根结点，直到该元素没有左节点，就出栈并打印，注意此时再压入右孩子，然后访问根结点， 中序遍历的思路： 待解决！！！ case通过率为70.00% 12345678910111213141516171819202122232425262728293031323334353637383940!!!! 错误代码演示public class Solution &#123; /** * * @param root TreeNode类 * @return int整型ArrayList */ public ArrayList&lt;Integer&gt; inorderTraversal (TreeNode root) &#123; // write code here ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null) return list; Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; //工作结点 TreeNode lastNode = null; stack.push(root); while(!stack.isEmpty())&#123; TreeNode top = stack.peek(); //一开始我的想法如果没有左孩子或者上一个访问的结点是左孩子（类比后序），就访问根节点！！这样是错的，因为可能上一个访问的是左孩子的右子树，所以说中序遍历的迭代不像后续遍历的迭代，保存上一个访问的结点没有意义。。 比如说访问完了6会访问1。这时候就不会退出循环了 1 / \\ 2 5 / \\ 4 6 if(top.left==null || top.left==lastNode)&#123; top = stack.pop(); list.add(top.val); lastNode = top; //访问了根节点后，如果右不空则将右孩子压栈 if(top.right!=null)&#123; stack.push(top.right); &#125; &#125;else&#123; stack.push(top.left); &#125; &#125; return list; &#125;&#125; 正确解法： 123456789101112131415161718192021222324252627public class Solution &#123; /** * * @param root TreeNode类 * @return int整型ArrayList */ public ArrayList&lt;Integer&gt; inorderTraversal (TreeNode root) &#123; // write code here ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null) return list; Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; //工作结点 while(!stack.isEmpty() || node!=null)&#123; while(node!=null )&#123; stack.push(node); node = node.left; &#125; //退出循环，node=null，也就是说明这个结点没有左孩子了，可以访问了 node = stack.pop(); list.add(node.val); //访问了根节点后，处理右节点 node = node.right; &#125; return list; &#125;&#125; 也可以写成：(while条件不同) 1234567891011121314151617181920212223242526272829public class Solution &#123; /** * * @param root TreeNode类 * @return int整型ArrayList */ public ArrayList&lt;Integer&gt; inorderTraversal (TreeNode root) &#123; // write code here ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null) return list; Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; //工作结点 while(true)&#123; while(node!=null )&#123; stack.push(node); node = node.left; &#125; if(stack.isEmpty()) break; //退出循环，node=null，也就是说明这个结点没有左孩子了，可以访问了 node = stack.pop(); list.add(node.val); //访问了根节点后，处理右节点 node = node.right; &#125; return list; &#125;&#125; 题3 交换相邻每两个链表结点老规矩，dummy、tail，以及其他相关指针。这里cur1 ，cur2有点搞，写的时候要画图辅助理解。 123456789101112131415161718192021222324public class Solution &#123; /** * * @param head ListNode类 * @return ListNode类 */ public ListNode swapPairs (ListNode head) &#123; if(head==null || head.next==null) return head; // 无意义头节点,尾节点 ListNode dummy = new ListNode(0),tail=dummy; dummy.next = head; ListNode cur1 = head ,cur2 = cur1.next; while(cur2!=null)&#123; tail.next = cur2; cur1.next = cur2.next; cur2.next = cur1; tail = cur1; cur1 = cur1.next; cur2 = cur1==null?null:cur1.next; //防止空指针异常 &#125; return dummy.next; &#125;&#125; 20200523 晴截止昨日，剑指Offer刷题进度：55/67，Leetcode 22/148 ，已坚持每天刷3题的天数：10。 题1回文串判断 判断题目给出的字符串是不是回文，仅考虑字符串中的字母字符和数字字符，并且忽略大小写 例如：”A man, a plan, a canal: Panama”是回文 “race a car”不是回文 注意： 你有没有考虑过字符串可能为空？这是面试时应该提出的一个好问题。 针对这个问题，我们定义空字符串是回文 这题挺简单的，就是比较时有点繁琐。 注意’A’ =’a’+32。 ps：我的思路是直接用头尾指针在原字符串上比较，遇到无关字符就跳过，没必要去除无关字符得到新字符串并再比较。 1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public boolean isPalindrome(String s) &#123; if(s==null||s.length()==0) return true; int i = 0,j=s.length()-1; while(i&lt;j)&#123; //如果不是数字和字母就认为是非法字符不用判断 while (i&lt;j&amp;&amp;!isVaildCharacter(s.charAt(i)))&#123; i++; &#125; while(i&lt;j&amp;&amp;!isVaildCharacter(s.charAt(j)))&#123; j--; &#125; if(i==j) return true; if(!isSame(s.charAt(i),s.charAt(j))) return false; i++; j--; &#125; return true; &#125; //判断是否合法字符，只有字母和数字才需要比较,所以这里认为字母和数字才是合法字符，忽略其他字符 public boolean isVaildCharacter(Character c)&#123; return (c&gt;='A'&amp;&amp;c&lt;='Z') || (c&gt;='a'&amp;&amp;c&lt;='z') || (c&gt;='0'&amp;&amp;c&lt;='9'); &#125; //比较两个字符是否相等，包含大小写不一致、但是字母相同的情况 public boolean isSame(Character c1,Character c2)&#123; if(c1&gt;='A'&amp;&amp;c1&lt;='Z')&#123; return c1==c2 || (c1+32)==c2; &#125;else if(c1&gt;='a'&amp;&amp;c1&lt;='z')&#123; return c1==c2 || (c1-32)==c2; &#125; //非字母情况直接比较 return c1==c2; &#125;&#125; 题2 删除链表中的重复元素 删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次 例如： 给出的链表为1-&gt;1-&gt;2,返回1-&gt;2. 给出的链表为1-&gt;1-&gt;2-&gt;3-&gt;3,返回1-&gt;2-&gt;3. Given a sorted linked list, delete all duplicates such that each element appear only once. For example,Given1-&gt;1-&gt;2, return1-&gt;2.Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3. 一开始想的复杂了，还设置了dummy、tail节点，后来发现没必要。 1234567891011121314151617public class Solution &#123; /** * * @param head ListNode类 * @return ListNode类 */ public ListNode deleteDuplicates (ListNode head) &#123; ListNode p = head; while(p!=null)&#123; while(p.next!=null &amp;&amp; p.next.val==p.val)&#123; p.next =p.next.next; &#125; p = p.next; &#125; return head; &#125;&#125; 题3 为完全二叉树的每个节点设置右节点 填充所有节点的next指针，指向它右兄弟节点。如果没有右兄弟节点，则应该将next指针设置为NULL。 初始时，所有的next指针都为NULL 注意： 你只能使用常量级的额外内存空间 可以假设给出的二叉树是一个完美的二叉树(即，所有叶子节点都位于同一层，而且每个父节点都有两个孩子节点)。 观察发现节点的右兄弟有如下规律： 右兄弟的规律 可以用递归解决：前序遍历节点的同时为左右孩子设置右兄弟指针。 不过这不符合题目常量级的额外内存空间这一要求。 1234567891011121314！！！ ATTENTION:不符合O(1)空间的要求public class Solution &#123; public void connect(TreeLinkNode root) &#123; //因为题目说了是完全二叉树，所以root.left和root.right的空判断一个就行了 if(root==null||root.left==null) return; root.left.next = root.right; if(root.next!=null)&#123; root.right.next = root.next.left; &#125; connect(root.left); connect(root.right); &#125;&#125; 把上面的代码贴出来的原因就是引发根据该思路思考：因为要确保为每个非叶子结点的子结点都设置了右孩子，所以免不了遍历！但是遍历二叉树怎么可能以常量级额外内存实现呢？对于普通二叉树的前中后层序遍历，不管是递归还是用栈迭代，时间、空间复杂度都是O(n)。而这时应该想到这题不是还专门设置了一个右指针吗？仔细一想，利用右指针就可以实现以常数级的内存空间完成层序遍历。每次都记录该层的第一个结点，然后一直向右走（并且设置该节点的孩子的右节点），直到这层没有右兄弟了，就开始走下一层（下一层的第一个结点=上一层的第一个结点的左孩子）。 123456789101112131415161718192021222324public class Solution &#123; public void connect(TreeLinkNode root) &#123; //因为题目说了是完全二叉树，所以root.left和root.right的空判断一个就行了 //反思：有问题，这里是完全二叉树而不一定是满二叉树！ if(root==null||root.left==null) return; TreeLinkNode cur = root; //工作节点 TreeLinkNode firstNode = root; //每层的第一个结点(最左边的结点) while(firstNode.left!=null)&#123; //这里如果判断条件写firstNode!=null 就不对！！！ cur = firstNode; while(cur!=null)&#123; if(cur.left!=null)&#123; cur.left.next = cur.right; &#125; if(cur.next!=null)&#123; cur.right.next = cur.next.left; &#125; cur = cur.next; &#125; firstNode = firstNode.left; &#125; &#125; &#125; 题4 判断二叉树是否镜像之前做过，算是复习了。关键是要想到构造此方法isSymmetric(TreeNode node1,TreeNode node2)来判断两棵树是否为镜像。 123456789101112131415161718192021public class Solution &#123; /** * * @param root TreeNode类 * @return bool布尔型 */ public boolean isSymmetric (TreeNode root) &#123; // write code here if(root==null)&#123; return true; &#125; return isSymmetric(root.left,root.right); &#125; public boolean isSymmetric(TreeNode node1,TreeNode node2)&#123; if(node1==null&amp;&amp;node2==null) return true; else if(node1==null || node2==null) return false; return node1.val==node2.val &amp;&amp; isSymmetric(node1.left,node2.right) &amp;&amp; isSymmetric(node1.right,node2.left); &#125;&#125; 20200522 多云截止昨日，剑指Offer刷题进度：55/67，Leetcode 20/148 ，已坚持每天刷3题的天数：9。 题1 【待解决】合法的二叉搜索树 判断给出的二叉树是否是一个二叉搜索树（BST） 二叉搜索树的定义如下 一个节点的左子树上节点的值都小于自身的节点值 一个节点的右子树上节点的值都小于自身的节点值 所有节点的左右子树都必须是二叉搜索树 一个月前在Leetcode网站里做过原题，没AC，当时的想法很简单。 1234567891011121314!!!!ATTENTION:这是错误代码！！！class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if(root == null) return true; if(root.left!=null &amp;&amp; root.left.val &gt;= root.val)&#123; return false; &#125; if(root.right!=null &amp;&amp; root.right.val &lt;= root.val)&#123; return false; &#125; return isValidBST(root.left) &amp;&amp; isValidBST(root.right); &#125;&#125; 然后提交出错了，[10,5,15,null,null,6,20]，这个测试用例的正确计算结果应该是false，而用上述递归会是true。 为什么呢？把它画成树状结构就看出来了: 在这棵树中，节点6是在根节点10的右子树（10的右孩子的左孩子），显然不是BST，因为在BST中，一个节点会大于其右子树的所有节点！ P.S：这里吐槽一下牛客网这道题目的测试用例，我在牛客网上提交这份错误代码，本来是想看看能通过百分之几，结果直接AC了，说明其设计用例没有考虑到此类情况。 123456789101112131415161718192021222324252627282930313233343536import java.util.*;/* * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &#125; */public class Solution &#123; /** * * @param root TreeNode类 * @return bool布尔型 */ public boolean isValidBST (TreeNode root) &#123; // write code here if(root == null) return true; return isValidBST(root,root.val); &#125; public boolean isValidBST(TreeNode root,int limit)&#123; //规定右子树节点的下界（minForRightNode）和左子树结点的上界（maxForLeftNode） if(root==null) return true; if(root.left!=null &amp;&amp; (root.left.val &gt;= root.val || root.left.val&gt;=limit) )&#123; return false; &#125; if(root.right!=null &amp;&amp; (root.right.val &lt;= root.val || root.right.val&lt;=limit) )&#123; return false; &#125; //这一层的结点值是下层左孩子的上限和右孩子下限 return isValidBST(root.left,root.val) &amp;&amp; isValidBST(root.right,root.val); &#125;&#125; 123456789101112131415161718192021222324252627class Solution &#123; public boolean isValidBST(TreeNode root) &#123; // write code here if(root == null) return true; return isValidBST(root,root.val,3); &#125; public boolean isValidBST(TreeNode root,int limit,int flag)&#123; //limit规定右子树节点的下界（minForRightNode）和左子树结点的上界（maxForLeftNode） //flag规定要进行哪一种判断 if(root==null) return true; if(root.left!=null &amp;&amp; root.left.val &gt;= root.val )&#123; return false; &#125; if(root.right!=null &amp;&amp; root.right.val &lt;= root.val)&#123; return false; &#125; if(flag==0 &amp;&amp; root.right.val&gt;=limit)&#123; //左子树的右孩子要小于限制 return false; &#125;else if(flag==1 &amp;&amp; root.left.val&lt;=limit)&#123; return false; &#125; //这一层的结点值是下层左孩子的上限和右孩子下限 return isValidBST(root.left,root.val,0) &amp;&amp; isValidBST(root.right,root.val,1); &#125;&#125; 题2 【改之前的bug】数值的整数次方 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 这题之前做过，能AC（牛客没考虑到某测试用例），这次主要是修复上次的bug。 1234567891011121314151617181920212223public class Solution &#123; public double Power(double base, int exponent) &#123; long e2 = exponent; //之所以要转成long是为了兼容当 exponent= -2^31的情况下,-exponent溢出了 if(exponent==0) return 1.0; if(exponent&lt;0)&#123; base = 1/base; e2 = -e2; &#125; double tmp = base; double res = 1; while(e2!=0)&#123; if((e2 &amp; 1)==1)&#123; //nCopy &amp; 1记录数值n二进制表示最后一位的取值1/0 res=res*tmp; &#125; tmp*=tmp; e2=e2&gt;&gt;1; //n右移动一位 &#125; return res; &#125;&#125; 本来是做下一题的，做完才发现要求中x、n都是double类型的，想起了这道类似题，就想着复习一遍快速幂_Leetcode上的类似题，尝试了很久都没AC，。最后才意识到Java 代码中 int32 变量 n∈[−2147483648,2147483647] ，因此当 n = -2147483648，-n=−2147483648 时 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 ，后面用 long类型操作即可。然而之前在牛客同题能AC，说明其测试用例不严谨！ Leetcode的题 题3 【疑惑】pow-x 请实现函数 pow(x, n). Implement pow(x, n).这道题有个tag是分治法，就用分治法的思想解决吧：快速幂。 ？？？n是浮点数 很迷 题4 括号匹配123456789101112131415161718192021222324252627import java.util.*;public class Solution &#123; /** * * @param s string字符串 * @return bool布尔型 */ public boolean isValid (String s) &#123; // write code here Stack &lt;Character&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='&#123;') stack.push(s.charAt(i)); else if(s.charAt(i)==')' || s.charAt(i)==']' || s.charAt(i)=='&#125;')&#123; if(stack.isEmpty()||!canMatch(stack.pop(),s.charAt(i))) return false; &#125; &#125; return stack.isEmpty(); &#125; public boolean canMatch(char c1,char c2)&#123; return c1=='('&amp;&amp;c2==')' || c1=='['&amp;&amp; c2==']' || c1=='&#123;'&amp;&amp;c2=='&#125;'; &#125;&#125; 20200521 阴截止昨日，剑指Offer刷题进度：54/67，Leetcode 18/148 ，已坚持每天刷3题的天数：9。 题1 【待改进】二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 我的想法比较简单：先把中序遍历结果存放在ArrayList里（存节点而不是值），然后在这个list里调整指针的指向，最后返回list中的第一个节点。 能AC，不过应该不是出题者的用意，待改进。 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;public class Solution &#123; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree ==null) return null; ArrayList &lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); inorder(pRootOfTree,list); //此时，list中保存了中序遍历的结果 for(int i = 0;i&lt;list.size();i++)&#123; TreeNode node = list.get(i); if(i==0)&#123; node.left = null; &#125;else&#123; node.left = list.get(i-1); &#125; if(i==list.size()-1)&#123; node.right = null; &#125;else&#123; node.right = list.get(i+1); &#125; &#125; return list.get(0); &#125; public void inorder(TreeNode root,ArrayList list)&#123; if(root==null) return; inorder(root.left,list); list.add(root); inorder(root.right,list); &#125;&#125; 题2 two sum 给出一个整数数组，请在数组中找出两个加起来等于目标值的数， 你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的 假设给出的数组中只存在唯一解 例如： 给出的数组为 {2, 7, 11, 15},目标值为9输出 ndex1=1, index2=2 思路：题目知识点打了个哈希标签。于是用了哈希表，把数组的值作为key，把数组的索引（下标）作为value，因为HashMap的查找时间复杂度平均是O(1)，所以这样做用空间换时间是合理的。 写代码的时候要注意题目要求下标是从1开始的，另外就是要注意map.put(target-numbers[i],i+1); 这一行与澳方在判断的后面，否则比如说 测试用例是：[1,0,2,4]，2 ， 正确结果应该是返回[1，2]（0+2=2），而如果先添加再判断，返回结果就变成了[1,1]。 12345678910111213141516171819202122import java.util.HashMap;public class Solution &#123; /** * * @param numbers int整型一维数组 * @param target int整型 * @return int整型一维数组 */ public int[] twoSum (int[] numbers, int target) &#123; // write code here int res [] = new int [2];//存放返回结果 HashMap &lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i&lt;numbers.length; i++)&#123; if(map.containsKey(numbers[i]))&#123; res[0] = map.get(numbers[i]); res[1] = i+1;//记得这里要加1，因为下表要加1 &#125; map.put(target-numbers[i],i+1); //存放自己期待的数(能够和自己相加得到target的数)和自己的下标（从1开始） &#125; return res; &#125;&#125; 题3 右旋转链表 将给定的链表向右转动k个位置，k是非负数。例如：给定1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null ， k=2，返回4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;null。 写时感觉代码写的不怎么优雅，有些凌乱，不过竟然一次过了。做这种题最重要的是先理解题目的意思，用实例演算一下，来帮助判断代码中的边界条件 实例演算： 原链表==12345右移1==51234右移2==45123右移3==34512右移4==23451右移5==12345 （复原） 演算几个例子就会发现是有迹可循的，可以定位到节点后一步到位地完成旋转，没必要在循环里一步步旋转。具体说来，思路是： 1.末尾节点指向头结点 2.倒数第k个元素为头结点 3.倒数第k+1个元素指向null（也就是第2步的前一个结点） 所以我的代码中设置了好几个节点的引用：末尾节点、工作节点p（用来定位尾节点以及倒数第k个节点）、结果节点，反思了一下：我在求倒数第k个节点的时候是先求链表的总长度，再求差值定位，这里可以用快慢指针。 PS 后面又想了想，这里还是有必要求处链表的长度，因为在取余操作也要用到。 题目本身不难，下一次解答此题的关注点放在怎么写出优美易懂的代码 12345678910111213141516171819202122232425public class Solution &#123; public ListNode rotateRight (ListNode head, int k) &#123; if(head==null) return null; int len = 0; ListNode p = head,tail=head; while(p!=null)&#123; len++; tail=p; p=p.next; &#125; k%=len; //取余操作，把链表的最后k%len个元素拿到链表前面来 int cnt = 0; p=head; while(cnt&lt;len-k-1)&#123; cnt++; p=p.next; &#125; tail.next = head; ListNode res = p.next; //复查代码的时候发现这个res引用没必要，可以直接用head p.next = null; return res; &#125;&#125; 20200520 晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 15/148 ，已坚持每天刷3题的天数：8。 题1自底向上的层序遍历 给定一个二叉树，返回该二叉树由底层到顶层的层序遍历，（从左向右，从叶子节点到根节点，一层一层的遍历） 我这里还是按照层序遍历的普通思路，然后调用Collections.reverse(result)，反转ArrayList。还有一个思路是result.add(0,list)，也就是说每次插入都插入到最前面，但是这个方法的时间复杂度太高了（数组头插，其他元素都要后移）。也可以考虑使用LinkedList头插，然后通过ArrayList arrayList = new ArrayList(linkedList);转换成ArrayList ，加到result中。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Queue; import java.util.LinkedList;import java.util.Collections;public class Solution &#123; /** * * @param root TreeNode类 * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt; */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom (TreeNode root) &#123; // write code here if(root==null) return new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int leftNumToNextLevel = 1; //到达下一层需要访问的剩余元素个数 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); //出队列 list.add(node.val); leftNumToNextLevel--; if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; if(leftNumToNextLevel==0)&#123; //已遍历完了一层 result.add(list); list=new ArrayList&lt;&gt;(); leftNumToNextLevel=queue.size(); &#125; &#125; Collections.reverse(result); return result; &#125;&#125; 题2 【待完善】指定区间内的链表反转 将一个链表m位置到n位置之间的区间反转，要求使用原地算法，并且在一次扫描之内完成反转。 例如： 给出的链表为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 ，n = 4, 返回1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. 注意： 给出的m，n满足以下条件： 1 ≤ m ≤ n ≤ 链表长度 之前我做反转链表的时候用到了栈，需要O(n)级别的空间复杂度，今天刚听说并学了原地反转链表（意味着O（1）级别的空间复杂度）的思路，核心是使用3个移动指针p1、p2、p3和一个定指针tail。 一开始，做这题要考虑的特殊情况很多（比如说是否只有0、1、2个元素，分别做不同处理），根据错误测试用例调整了许久，结果还是只能AC45%： 看题解，很简洁地求解了这个问题，果然，如果发现自己代码中的特殊情况很多，很可能是代码写的不好。 附上我的45%代码，以供日后修正： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; /** * * @param head ListNode类 * @param m int整型 * @param n int整型 * @return ListNode类 */ public ListNode reverseBetween (ListNode head, int m, int n) &#123; // write code here if(head==null || head.next==null) //为空或者只有一个元素 return head; if(head.next.next==null)&#123;//只有两个元素 if(m==1 &amp;&amp; n==2)&#123; //这种情况才会有元素需要反转 ListNode node = head.next; node.next = head; head.next = null; return node; &#125; return head; &#125; ListNode dummy = new ListNode(0); dummy.next=head; ListNode p1=dummy,p2=p1.next,p3=p2.next,tail=dummy; int cur=0; while(cur&lt;m &amp;&amp; p3!=null)&#123; //此循环的目的是定位tail、p1、p2、p3 cur++; tail=p1; //记录下tail的位置 p1=p1.next; p2=p1.next; p3=p2.next; &#125;//退出循环时，cur=m，说明要开始反转动作了 while(cur&lt;n &amp;&amp; p3!=null )&#123; //以下三步用于完成反转操作 tail.next=p2; p1.next=p3; p2.next=p1; //以下三步用于p1、p2、p3前移 p1=p1.next; p2=p2.next; p3=p3.next; cur++; &#125; return dummy.next; &#125;&#125; 题3 二叉树的层序遍历这道题就是今天做的题1的简单版。直接在其基础上复制了，今天学习时间太长，有点累了，不过每天三题还是要保证的，层序遍历已经很熟悉了，就算是偷个小懒。 题4 之字形二叉树层序遍历同上，今天AC的这几题都是一个系列的，今天算是水一下任务。 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; /** * * @param root TreeNode类 * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt; */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder (TreeNode root) &#123; // write code here if(root==null) return new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int leftNumToNextLevel = 1; //到达下一层需要访问的剩余元素个数 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); boolean leftToRight = true; while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); //出队列 list.add(node.val); leftNumToNextLevel--; if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; if(leftNumToNextLevel==0)&#123; //已遍历完了一层 if(!leftToRight)&#123; //如果不是从左向右，说明要反转 Collections.reverse(list); &#125; result.add(list); list=new ArrayList&lt;&gt;(); leftNumToNextLevel=queue.size(); leftToRight^=true; //leftToRight取反 &#125; &#125; return result; &#125;&#125; 20200519 晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 12/148 ，已坚持每天刷3题的天数：7。 rotate-image顺时针旋转矩阵 给出一个用二维矩阵表示的图像 返回该图像顺时针旋转90度的结果 扩展： 你能使用原地算法解决这个问题么？ 旋转前后 题1 有序链表合并 将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。 这题想了很久才理清思路，实在不应该。 思路 12345678910111213141516171819202122public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode m = l1; //这两个变量没必要，可以直接使用l1、l2 ListNode n = l2; ListNode res = new ListNode(0); //先随便指定一个无意义的头节点（以遍后续代码统一） ListNode tail = res; //尾结点 while(m!=null &amp;&amp; n!=null)&#123; if(m.val&gt;n.val)&#123; //l2的当前结点比较小 tail.next=n; n=n.next; &#125;else&#123; //l1的当前结点比较小 tail.next=m; m=m.next; &#125; tail=tail.next; &#125; tail.next=(m==null?n:m); return res.next; //记得返回的是res.next。 &#125;&#125; 题2 查找二维数组中的数 请写出一个高效的在m*n矩阵中判断目标值是否存在的算法，矩阵具有如下特征： 每一行的数字都从左到右排序, 每一行的第一个数字都比上一行最后一个数字大 1234567891011121314151617public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix==null || matrix[0]==null) return false; //思路：从左下角开始找 int curI=matrix.length-1,curJ=0; //分别表示当前数字的纵坐标和横坐标 while(curI&gt;=0 &amp;&amp; curJ&lt;=matrix[0].length-1)&#123; if(target&lt;matrix[curI][curJ])&#123; curI--; //当前数字要变小，往上走 &#125;else if(target&gt;matrix[curI][curJ])&#123; curJ++; //当前数字要变大，往右走 &#125;else return true; &#125; return false; &#125;&#125; 题3 两链表的数相加 给定两个代表非负数的链表，数字在链表中是反向存储的（链表头结点处的数字是个位数，第二个结点上的数字是百位数…），求这个两个数的和，结果也用链表表示。 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出： 7 -&gt; 0 -&gt; 8 题目本身不难，考虑得全面一点就好了。 1234567891011121314151617181920212223242526public class Solution &#123; //需要考虑：诸如5+5的情况，正确结果应该是01 //需要考虑: l1和l2长度不一样的情况,我这里的处理方式是空时也放在循环内，+0 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0);//无意义的头节点 ListNode tail = head; int carry = 0; //下次计算的进位 while(l1!=null || l2!=null)&#123; int temp = (l1==null?0:l1.val)+(l2==null?0:l2.val)+carry; //这一位的相加结果 if(temp&gt;=10)&#123; temp-=10; carry=1; &#125;else&#123; carry=0; &#125; tail.next = new ListNode(temp); tail=tail.next; l1=(l1==null?l1:l1.next); l2=(l2==null?l2:l2.next); &#125; if(carry==1)&#123; //如果最后还有进位，末尾再加一个1 tail.next = new ListNode(1); &#125; return head.next; &#125;&#125; 20200518 晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 6/148 ，已坚持每天刷3题的天数：6。 题1 非递归二叉树后序遍历1234567891011121314151617181920212223242526import java.util.Stack;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if(root==null) return new ArrayList&lt;&gt;(); Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); stack.push(root); //先加入根节点 while(!stack.isEmpty())&#123; TreeNode node = stack.peek(); if(node.left==null &amp;&amp; node.right==null)&#123; list.add(stack.pop().val); &#125;else&#123; if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); node.right=null; node.left=null; &#125; &#125; return list; &#125;&#125; 分析：用栈实现，后序访问次序是左右根，所以按照根、右、左的次序依次加入栈，比如说求root的后序序列，就是先将root结点压栈，再将root.right压栈，再将root.left压栈（当left和right都非空的情况下），最后将root.left压栈这一步也就是压入了左子树的根节点，此时再检查栈顶节点是否是叶子结点（也就是判断是否还有孩子），如果是叶子节点，就出栈加到list中，如果不是，就依旧按照右孩子、左孩子的次序压栈，且把栈顶的该结点的right和left都置为空，这样的话下次再访问该栈顶元素，第一个if条件成立,就加入list了。 这个做法是前几天我学了非递归前序遍历后想出来的，可以AC，不过稍加分析，有明显缺陷： 1234node.right&#x3D;null;node.left&#x3D;null;这两行代码破坏了原二叉树的结构。 后序遍历二叉树的非递归写法图解 根据上图思路，改进后： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.Stack;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if(root==null) return new ArrayList&lt;&gt;(); Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); //TreeNode node = root; stack.push(root); //先加入根节点 TreeNode frontNode=root; //初始化为root，如果初始化为null会有问题。 while(!stack.isEmpty())&#123; TreeNode node = stack.peek(); if((node.left==null &amp;&amp; node.right==null) || frontNode==node.left||frontNode==node.right )&#123; frontNode = stack.pop(); list.add(frontNode.val); &#125;else&#123; if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); &#125; &#125; return list; &#125;&#125; 题2二叉树路径和 给定一个二叉树和一个值sum，判断是否有从根节点到叶子节点的节点值之和等于sum的路径。 递归实现，体现了分治法的策略。 12345678910public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root==null) return false; if(root.left==null &amp;&amp; root.right==null)&#123; //是叶子结点 return sum==root.val; &#125; return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val); &#125;&#125; 题3 【未解决】 有序单链表转平衡BST题4 平衡二叉树判断 判断给定的二叉树是否是平衡的 在这个问题中，定义平衡二叉树为每个节点的左右两个子树高度差的绝对值不超过1的二叉树. 123456789101112131415161718public class Solution &#123; private boolean flag=true; public boolean isBalanced(TreeNode root) &#123; getHeight(root); return flag; &#125; public int getHeight(TreeNode root)&#123; if(root==null || !flag) //如果flag已经是false，就没必要算了 return 0; int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); int diff = leftHeight - rightHeight; if(Math.abs(diff)&gt;1)&#123; //递归计算高度的同时进行平衡判断 flag=false; &#125; return 1+Math.max(leftHeight,rightHeight); &#125;&#125; 递归解法，用了成员变量作为标志，不太优雅。。 20200517 雨转晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 6/148 ，已坚持每天刷3题的天数：5。 换个策略，按照通过率从高到低刷题。 假设你有一个数组，其中第i个元素表示某只股票在第i天的价格。设计一个算法来寻找最大的利润。你可以完成任意数量的交易(例如，多次购买和出售股票的一股)。但是，你不能同时进行多个交易(即，你必须在再次购买之前卖出之前买的股票)。 思路：每天都考虑是否要买。有赚就买，亏损则不买。 题1 买卖股票的最佳时间2123456789101112public class Solution &#123; public int maxProfit(int[] prices) &#123; //每天都考虑是否要卖出 int res=0; for(int i=0;i&lt;prices.length-1;i++)&#123; int diff = prices[i+1]-prices[i]; //计算本日与昨日的盈利额 if(diff&gt;0) res+=diff; &#125; return res; &#125;&#125; 题2 container-with-most-water 盛放最多水的容器这题有印象，之前好像在leetcode做过。本来一直在按照动态规划的思路做，后来才意识到，这是一道双指针的题。而且两边的指针要从中间开始向两边，而不是从两边开始。 public class Solution { public int maxArea(int[] height) { if(height==null||height.length==1) return 0; int dp [] = new int[height.length]; //dp[i]表示以height[i]结束的容器的最大盛水量 int tempMax = height[0]; //记录当前最高的下标（因为要计算长度），也就是height[i]之前的最大值 for(int i=1;i&lt;dp.length;i++){ if(height[i-1]&gt;tempMax){ tempMax=height[i-1]; } dp[i]=dp[i]*Math.max(height[]); } }} 题3 [same-tree] 给出两个二叉树，请写出一个判断两个二叉树是否相等的函数。 判断两个二叉树相等的条件是：两个二叉树的结构相同，并且相同的节点上具有相同的值。 最简单的递归了， 面试遇到这个题能笑出声。 123456789public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null) return true; else if(p==null || q==null) return false; return p.val==q.val &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); &#125;&#125; 二分查找 给出一个有序的数组和一个目标值，如果数组中存在该目标值，则返回该目标值的下标。如果数组中不存在该目标值，则返回如果将该目标值插入这个数组应该插入的位置的下标假设数组中没有重复项。下面给出几个样例：[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 12345678910111213141516public class Solution &#123; public int searchInsert(int[] A, int target) &#123; int l = 0,r=A.length-1,m; //分别表示left，right,mid while(l&lt;=r)&#123; m = (r-l)/2+l; if(A[m]==target)&#123; return m; &#125;else if(A[m]&gt;target)&#123; //说明要在左边找 r=m-1; &#125;else&#123; l=m+1; &#125; &#125; return l; &#125;&#125; 20200516 多云截止昨日，剑指Offer刷题进度：54/67，Leetcode 3/148 ，已坚持每天刷3题的天数：4。 题1 判断链表有环思路：快慢指针都从链表的头节点出发，然后快指针每次走两步，慢指针每次走一步，如果有环，它们迟早会相遇。 之前，剑指Offer做过比这难的，还要求求出进入环的那个结点，做了那题在做这题就是小意思了。 12345678910111213public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head, slow=head; while(fast!=null&amp;&amp;fast.next!=null)&#123; fast=fast.next.next; //每次走两步 slow=slow.next; //每次走一步 if(fast==slow)&#123; return true; &#125; &#125; return false; &#125;&#125; 题2single-number 现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。 注意： 你需要给出一个线性时间复杂度的算法，你能在不使用额外内存空间的情况下解决这个问题么？ 思路：位运算。 a ^ a = 0，0 ^ x = x 12345678910public class Solution &#123; public int singleNumber(int[] A) &#123; int res = 0; for(int i = 0;i&lt;A.length;i++)&#123; res^=A[i]; &#125; return res; &#125;&#125; 题3 深拷贝带随机指针的链表 现在有一个这样的链表：链表的每一个节点都附加了一个随机指针，随机指针可能指向链表中的任意一个节点或者指向空。 请对这个链表进行深拷贝。 剑指Offer做过，权当是复习了。 分三步骤： 第一次遍历，在原链表原地复制每个结点（在原链表的每个结点之后插入它的复制结点），先不用例会它的随机指针。 第二次遍历，为新复制的结点指定random指针。 第三次遍历，分离原链表和复制链表。 思路很正确，一直卡在了一个点。注意随机指针可能是空。题目还特意提示了，我一直没考虑到这一点，早点看题目就能发现了，然而我一直盯着代码找bug所以一直没想到。 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; RandomListNode p = head; while(p != null)&#123; RandomListNode copyNode = new RandomListNode(p.label); copyNode.next = p.next; p.next = copyNode; p = copyNode.next; &#125; p = head; RandomListNode q = head; while(p!=null &amp;&amp; p.next!=null)&#123; q = p.next; if(p.random != null)&#123; q.random = p.random.next; &#125;else&#123; q.random = null; &#125; p = p.next.next; &#125; p = head; q = head.next; RandomListNode res = q; while(q!=null&amp;&amp;q.next!=null)&#123; p.next = p.next.next; q.next = q.next.next; p = p.next; q = q.next; &#125; return res; &#125;&#125; 20200515 雨截止昨日，剑指Offer刷题进度：54/67 ，已坚持每天刷3题的天数：3。 从今天开始，开始刷牛客网上的Leetcode精选题，剑指Offer剩下的13题都没啥思路，先放一放，回头说不定会有想法。 题1 二叉树的最小深度 求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量。 思路： 迭代的方法：层序遍历二叉树，记录层数，一旦发现了叶子结点，返回当前记录的层数。 递归的方法：略。 1234567891011121314151617## 先提供一种错误解法！！！错误解法public class Solution &#123; public int run(TreeNode root) &#123; return minHeight(root); &#125; public int minHeight(TreeNode root)&#123; if(root==null) return 0; if(root.left==null &amp;&amp; root.right==null) return 1; return 1+Math.min(minHeight(root.left),minHeight(root.right)); &#125;&#125; 比如说树是 1 2 这样做，会认为最小深度是 mimHeight(1) = 1+min&#123;minHeight(2)，minHeight(null)&#125;,结果是1，实际上结果是2 层序遍历实现。成功AC。 12345678910111213141516171819202122232425262728293031import java.util.Queue;import java.util.LinkedList;public class Solution &#123; public int run(TreeNode root) &#123; if(root==null) return 0; Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int leftNumToNextLevel = 1; //到下一层的剩余数,(再层序访问leftNumToNextLevel个结点到达下一层) int cnt = 1; //最小层数 while(queue.size()!=0)&#123; TreeNode node = queue.poll(); leftNumToNextLevel--; if(node.left==null &amp;&amp; node.right==null)&#123; break; &#125; if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; if(leftNumToNextLevel==0)&#123; leftNumToNextLevel = queue.size(); cnt++; &#125; &#125; return cnt; &#125;&#125; 题2 evaluate-reverse-polish-notation题1 计算逆波兰式（后缀表达式）的值 运算符仅包含”+”,”-“,”*”和”/“，被操作数可能是整数或其他表达式 例如： 题3 max-points-on-a-line 对于给定的n个位于同一二维平面上的点，求最多能有多少个点位于同一直线上 题4 二叉树的前序遍历（非递归方法）思路： 首先打印根结点，然后打印左子树的根节点，若右子树不为空，把右子树的根节点压入栈。注意右子树可能还有孩子，所以不能直接遍历栈的元素，而是要用处理根节点同样的方法处理右孩子。 123456789101112131415161718192021222324252627282930！！！能AC，但是不推荐import java.util.Stack;import java.util.ArrayList;public class Solution &#123; Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root==null) return list; pre(root); while(stack.size()!=0)&#123; TreeNode right = stack.pop(); pre(right); //right是原来右子树的一部分。 &#125; return list; &#125; public void pre(TreeNode root)&#123; if(root==null) return; while(root!=null)&#123; list.add(root.val); if(root.right!=null)&#123; stack.push(root.right); &#125; root=root.left; &#125; &#125;&#125; 这是我自己想到的思路，不过代码不太优雅。附上一个更加简洁的思路： 非递归方式实现前序遍历 根据此思路改进后的代码： 123456789101112131415161718public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root==null) return new ArrayList&lt;&gt;(); Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); stack.add(root); while(stack.size()!=0)&#123; TreeNode node = stack.pop(); list.add(node.val); if(node.right!=null)&#123; stack.push(node.right); &#125; if(node.left!=null)&#123; stack.push(node.left); &#125; &#125; return list;&#125; 相似题目： 中序遍历二叉树的非递归 中序遍历二叉树的非递归写法 后序遍历二叉树的非递归写法 后序遍历二叉树的非递归写法图解 题5 maximum-depth-of-binary-tree二叉树的最大深度1234567public class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; &#125;&#125; 20200514 晴题1 【待改进】滑动窗口的最大值 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路: 用一个长度为size的数组记录当前的窗口，并为此数组设置一个指针，这个指针指向下一个要替换的元素位置。 每走一步，就重新计算一下这个窗口的最小值。 最基础的思路的代码： 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; if(size&lt;=0|| size&gt;num.length) return new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int window[] = new int [size]; //记录当前滑动窗口的值 int curr = size-1; //下一个替换的指针 for(int i=0;i&lt;size-1;i++)&#123; window[i] = num[i]; &#125; for(int i=size-1;i&lt;num.length;i++)&#123; window[curr]=num[i]; curr=(curr+1)%size; int max=Integer.MIN_VALUE; for(int j = 0; j&lt;size; j++)&#123; //每次重新计算滑动窗口的最小值 if(window[j]&gt;max)&#123; max=window[j]; &#125; &#125; list.add(max); &#125; return list; &#125;&#125; 做完了反思: 这样做多此一举了，还不如直接设置两个指针，在原数组上直接计算，没必要单独为窗口开辟空间。 题2不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 看到题目描述，不用加减乘除运算做加法很可能和位运算有关。 参考了大佬的题解后豁然开朗。 简而言之，如果x &amp; y = 0，说明x+y两个数任意位上都不存在进位，结果就是 x ^ y，如 100+001 = 100 ^ 001 = 101，而如果x &amp; y !=0，那就说明两数相加必有进位。这时候我们依旧是先计算 x ^ y， 作为没有处理进位的加法，再在此基础上考虑进位 : (x&amp;y) 计算出应该进位的位&lt;&lt;1，得到进位结果 再加 不考虑进位的结果x^y ，得到结果。。 12345678910111213141516public class Solution &#123; public int Add(int num1,int num2) &#123; int res = num1 ^ num2; //int carry = 0 ; //表示进位结果 while(true)&#123; res = num1 ^ num2; if((num1 &amp; num2)!=0)&#123; //说明结果应该有进位 num2 = ((num1&amp;num2)&lt;&lt;1); //注意这一行和下一行的位置不能颠倒，这里应该用个提前记录变量比较好，应该用个变量记录num1&amp;num2的结果，代码比较清楚，也不用考虑两行的位置颠倒的问题。 num1 = res; &#125;else&#123; break; &#125; &#125; return res; &#125;&#125; 1234567891011//从评论看到的递归解法，有助于理理思路，写的话还是迭代写法。class Solution &#123;public:int Add(int num1, int num2)&#123; int n=(num1^num2); int m=(num1&amp;num2)&lt;&lt;1; if(m==0)return n; return Add(n,m);&#125;&#125;; 题3对称的二叉树关键是想到先写一个判断两棵树是不是对称的辅助方法。 123456789101112131415161718public class Solution &#123; boolean isSymmetrical(TreeNode node1,TreeNode node2)&#123; //判断以node1和node2为根节点的树是否是镜像的 if(node1==null &amp;&amp; node2==null)&#123; return true; &#125;else if(node1==null || node2 ==null)&#123; //其中一个为空，另一个不为空 return false; &#125;else&#123; //都不为空 return node1.val==node2.val &amp;&amp; isSymmetrical(node1.left,node2.right) &amp;&amp; isSymmetrical(node1.right,node2.left) ; &#125; &#125; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot==null) return true; return isSymmetrical(pRoot.left,pRoot.right); &#125;&#125; 20200513 晴目前进度：48/67 题1 【未完成】二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路： BST要变成排序的双向链表，所以极有可能和中序遍历有关。 题2 【待改进】 孩子们的游戏(圆圈中最后剩下的数)数组实现：代码很不优雅，不过可以正确AC 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n==0)&#123; return -1; &#125; //数组实现 boolean out [] = new boolean[n]; //记录每个人的出列状态 int left = n; //记录当前队列剩余人数 int j = -1; //报数计数器 while(true)&#123; for(int i=0; i&lt;n ;i++)&#123; if(out[i] == false)&#123; j++; //报数 if(j==m-1)&#123; out[i]=true; //此人出列 left--; j=-1; &#125; &#125; &#125; if(left==1)&#123; //只剩余一个人 break; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(out[i]==false)&#123; return i; &#125; &#125; return -1; &#125;&#125; 题3 链表中环的入口结点没啥思路，参照了牛客网大佬的题解图，豁然开朗。 图片说明 1234567891011121314151617181920212223public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead==null || pHead.next==null) return null; ListNode fast=pHead,slow=pHead; while(fast!=null || fast.next!=null)&#123; fast=fast.next.next; slow=slow.next; if(fast==slow)&#123; //fast和slow相遇了 ListNode p = pHead; while(p!=slow)&#123; p=p.next; slow=slow.next; &#125; return slow; &#125; &#125; return null; &#125;&#125; 题4 求1+2+3+…..+n(https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13) 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 1234567public class Solution &#123; public int Sum_Solution(int n) &#123; int res=n; boolean continuee = (res&gt;0) &amp;&amp; ((res+=Sum_Solution(n-1))&gt;0) ; return res; &#125;&#125; 江湖人称：短路求值 20200512 晴题1 二叉搜索树的后序遍历序列 输入一个非空整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路: 写代码前先理清二叉搜索树的后序遍历有什么特征 : 后序遍历的顺序无非就是左-&gt;右-&gt;根。 最后一个遍历的元素是根节点，而由于是BST，所以可以根据和根节点比较来判断其是左子树的一部分还是右子树的一部分。 如下面这棵树的后序遍历结果是132，根据这个序列可知根节点是2，小于2的部分（这里只有1）是左子树，大于2的部分（这里只有3）是右子树。 如何把我们发现的特征转化为代码实现呢： 左边开始一部分小于根节点（也可能是空），属于左子树，一旦出现了一个大于根节点的，就属于右子树（同样也有可能是空），如果后面再次出现了取值小于根节点的取值，说明不可能是二叉搜索树的遍历结果，返回false，如果没有出现过，则在这一次调用没有发现问题，再递归调用其左右子树的序列检查左右子树是否符合要求。 转一个来自牛客网大佬的定义便于理解，一开口就是老递归了： BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。 1234567891011121314151617181920212223public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null|| sequence.length == 0) //因为题目说了是非空序列。 return false; return VerifySquenceOfBST(sequence,0,sequence.length-1); &#125; public boolean VerifySquenceOfBST(int [] a,int begin,int end)&#123; if(begin&gt;=end)&#123; //这个条件可以优化成end-begin&gt;=2，即表示数组序列只有3个以内的元素，可以直接返回真，因为三个即以下元素。 return true; &#125; int i = begin; while(a[i]&lt;a[end])&#123; //说明 下标为begin的元素属于左子树 i++; &#125; //结束循环了，说明此时a[i] &gt; a[end]，从现在开始，后面所有元素都应该大于a[end] int mid = i; //i继续往前走之前，先记录左子树和右子树元素的分界点 for(i=i+1;i&lt;end;i++)&#123; if(a[i]&lt;a[end]) return false; &#125; return VerifySquenceOfBST(a,begin,mid-1) &amp;&amp; VerifySquenceOfBST(a,mid+1,end-1); &#125;&#125; 题2 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 下次做题时的提示编写一个方法：public TreeNode recur(int [] pre,int [] in,int i1,int j1,int i2,int j2) 用求前序序列为pre[i1…j1]、中序序列为in[i2…j2]的根节点 解题思路前序列序：1,2,4,7,3,5,6,8 中序序列：4,7,2,1,5,3,8,6 由于前序遍历序列访问次序是根左右，第一个元素必定是根节点，所以所求树的根节点是1，这时我们再去中序遍历序列中找到根节点1，其左边的所有元素构成了左子树的中序遍历序列，而其右边的所有元素构成了右子树的中序遍历序列，（因为中序遍历次序是左根右，所以根节点在此序列中划分了左右子树）。找到了根节点1，发现了其左子树有3个元素，这个信息又可以帮助确定前序遍历序列中的左子树和右子树。 根据上述分析，我们得到了如下信息： 根节点：1 左子树中序序列：4，7，2；右子树中序序列：5，3，8，6 左子树前序序列：2，4，7；右子树前序序列：3，5，6，8 显然，这时又可以分别用左（右）子树的前序+中序序列求左（右）子树的根节点，构成了一个递归。 123456789101112131415161718192021222324public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return reConstructBinaryTree(pre,in,0,pre.length-1,0,pre.length-1); &#125; public TreeNode reConstructBinaryTree(int [] pre,int [] in,int i1,int j1,int i2,int j2)&#123; //求前序序列为pre[i1...j1]、中序序列为in[i2...j2]的根节点 if(j1-i1 &lt; 0)&#123; return null; &#125; TreeNode root = new TreeNode(pre[i1]); int i; for( i = i2;i&lt;=j2;i++)&#123; if(in[i] == root.val)&#123; break; &#125; &#125; int leftCnt = i-i2;//计算左子树的元素个数 //退出循环时，说明in[i]==root.val(也就是pre[in])，此时i的指向就是中序遍历中左右子树的分界点 root.left = reConstructBinaryTree(pre,in,i1+1,i1+leftCnt,i2,i-1); root.right = reConstructBinaryTree(pre,in,i1+1+leftCnt,j1,i+1,j2); return root; &#125;&#125; 题3 【待改进】旋转数组的最小数字此题之前直接用暴力方法做的，O（n）做的，显然不符合题目考察本意。 题4 数组中只出现一次的数字没什么思路，用HashMap解决的。 1234567891011121314151617181920import java.util.HashMap;import java.util.Iterator;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; HashMap &lt;Integer,Integer&gt; map= new HashMap&lt;&gt;(); for(int i=0;i&lt;array.length;i++)&#123; if(map.containsKey(array[i]))&#123; map.remove(array[i]); &#125; else&#123; map.put(array[i],1); &#125; &#125; //这里要注意！！！！ Iterator &lt;Integer&gt; iterator = map.keySet().iterator(); num1[0]=iterator.next(); num2[0]=iterator.next(); &#125;&#125; 复习点： map.containsKey() 获取set的迭代器 map.keySet().iterator() 20200511 晴题1 【待改进】 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 一开始没啥想法，只能想到最直观的做法： 用两个ArrayList对象分别保存奇数和偶数，然后合并。 时间复杂度：两次循环都是O(n)级别 空间复杂度： 奇数和偶数两个ArrayList占用的空间大小是 O(n) 12345678910111213141516171819202122//最直观的思路，能AC但是不推荐！！！import java.util.ArrayList;public class Solution &#123; public void reOrderArray(int [] array) &#123; ArrayList &lt;Integer&gt; ji = new ArrayList&lt;&gt;(); ArrayList &lt;Integer&gt; ou = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;array.length; i++)&#123; if(array[i]%2==0)&#123; ou.add(array[i]); &#125;else&#123; ji.add(array[i]); &#125; &#125; for(int i=0;i&lt;array.length;i++)&#123; if(i&lt;ji.size())&#123; array[i]=ji.get(i); &#125;else&#123; array[i]=ou.get(i-ji.size()); &#125; &#125; &#125;&#125; 此实现的不足： 代码效率: 这里没必要用ArrayList，Integer的占用空间比int大，毕竟它是一个对象，有对象头等数据。 如果用int[]的话就分配。 编程规范：给“奇数”、“偶数”变量起名的单词： odd number （奇数）， even number.（偶数）。 1234567891011121314151617181920//对上述直观思想的代码改进，效率没有质的提升public class Solution &#123; public void reOrderArray(int [] array) &#123; int res[] = new int[array.length]; int current=0; for(int i = 0;i&lt;array.length; i++)&#123; if(array[i]%2==1)&#123; res[current++] = array[i]; &#125; &#125; for(int i = 0;i&lt;array.length; i++)&#123; if(array[i]%2==0)&#123; res[current++] = array[i]; &#125; &#125; for(int i=0;i&lt;res.length;i++)&#123; array[i]=res[i]; //这里我直接写array=res竟然不行，不解。。 &#125; &#125;&#125; 其实对这种解法还是不太满意，写了这么多只是为了记录思考过程。 我觉得，这道题主要考察的是原地数组元素的交换，开辟新的数组似乎不太合理。 Leetcode相似题:调整数组顺序使奇数位于偶数前面这道题题目是一样的，但是这题中不限制奇数内部、偶数内部的相对顺序。 这题和快排的partition操作类似。 看着很简单， 不过我做的时候经常忽略了边界条件，代码参考了Leetcode题解 12345678910111213class Solution &#123; public int[] exchange(int[] nums) &#123; int i = 0, j = nums.length - 1, tmp; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; (nums[i] &amp; 1) == 1) i++; //判断偶数用位运算提高效率 while(i &lt; j &amp;&amp; (nums[j] &amp; 1) == 0) j--; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; return nums; &#125;&#125; 20200510 晴题1【待熟练】树的子结构123456789101112131415public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root2==null || root1 ==null)&#123; //题目要求的“空树不是任意一个树的子结构”的逻辑在这里完成 return false; &#125; return isSubTree(root1,root2) || HasSubtree(root1.left,root2)|| HasSubtree(root1.right,root2); &#125; public boolean isSubTree(TreeNode r1,TreeNode r2)&#123; if(r2==null) return true; if(r1==null || r1.val!=r2.val) return false; return isSubTree(r1.left,r2.left) &amp;&amp; isSubTree(r1.right,r2.right); &#125;&#125; 此解法参考题解。 下次复习不妨再来做一下吧！https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/ 题2【待改进】二进制中1的个数典型的位运算的题目，记得很久以前做这题，思路是把十进制辗转相除得到二进制的同时计算1的个数，现在想想真是too young。 解决这题的核心就在于： &amp;和&gt;&gt;这两个位运算符的应用。 当我写完自信满满提交了之后，却发现错了！！ 123456789101112131415public class Solution &#123; public int NumberOf1(int n) &#123; int res = 0; while(n!=0)&#123; res = res + (n&amp;1); ////n&amp;1表示n的二进制表示的最后一位是1还是0 n = n &gt;&gt; 1; //n右移1位 &#125; return res; &#125;&#125;错误代码：不通过您的代码已保存运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。case通过率为0.00% 分析一下是为什么：因为负数在右移的时候左边最高位添加的是1，就死循环了。。 做了一点点改动后（对比一下代码找不同，你会发现确实是一点点），就通过了。 12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int res = 0; while(n!=0)&#123; res = res + (n&amp;1); ////n&amp;1表示n的二进制表示的最后一位是1还是0 n = n &gt;&gt;&gt; 1; //n逻辑右移1位 &#125; return res; &#125;&#125; 参考了逻辑右移和算术右移。 这种做法其实有点剑走偏锋的意思，剑指offer介绍的差不多的方法是n不变，flag初始化为1，不断左移flag，计算n&amp;flag来确定每一位是0还是1（思路是一模一样的，有点“运动的相对性”的意思）。不难发现，对于java来说，int是4个字节，32位，这种做法要循环的次数是32次。 书中还介绍了一种循环次数等于二进制数中数字1的个数的优化解法。 待理解 image-20200510021007308 20200508 晴题1 数值的整数次方思路上学期算法课中学过，使用分治法将时间复杂度降低到O(logn)，且采用此方法，空间复杂度也会是O(logn)。 这次用的是快速幂算法，时间复杂度是O(logn)，空间复杂度是O(1)。 接下来介绍一下快速幂的思想： 比如说我们要计算 3的14次方，即base=3,exponent=14,可以这样算： 14的二进制表示是1110， 1110的倒数第一位是0，且此位的权重是2^0=1，则代表了0X3^1 1110的倒数第二位是1，且此位的权重是2^1=2，则代表了1X3^2 1110的倒数第三位是1，且此位的权重是2^2=4，则代表了1X3^4 1110的倒数第四位是1，且此位的权重是2^3=8，则代表了1X3^8 3^14 = (3^2)X(3^4)X(3^8)，我们可以用迭代的方式结合位运算进行快速幂计算。 1234567891011121314151617181920212223242526public class Solution &#123; public double Power(double base, int exponent) &#123; if(exponent&gt;0) return postive(base,exponent); else if(exponent==0) return 1; else return 1/postive(base,-exponent); &#125; public static double postive(double base, int exponent) &#123; int last = 0 ; //末位是0还是1 double res = 1; double temp = base; while(exponent!=0)&#123; last = 1 &amp; exponent; //结果是exponent这个数二进制表示的最低位（1或者0） if(last == 1)&#123; res = res * temp; &#125; exponent = exponent&gt;&gt;1; temp *= temp; &#125; return res; &#125;&#125; 20200507 晴最近停刷了几天题，今天是返校后第一天刷题，愧对“飘风不终朝，骤雨不终日”啊。以后每天都刷，务必在秋招前把牛客网上剑指offer和leetcode精选题刷完。。 题1两个链表的第一个公共节点&lt;%blockquote%&gt;输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;%endblock%&gt; 思路没啥好思路，暴力解决，复杂度O(m*n)，m和n分别为两条链表的长度 1234567891011121314151617public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode p1 = pHead1; ListNode p2 = pHead2; while(p1!=null)&#123; p2 = pHead2; while(p2!=null)&#123; if(p1==p2) return p1; p2=p2.next; &#125; p1=p1.next; &#125; return null; &#125;&#125; 巧妙地利用快慢指针。 改进后的思路：先计算两条链表的长度，然后长链表的指针先走diff步(diff为链表的长度差)，然后两个指针一起走，直到发现相等停止。 20200428 晴题1字符串的排列提示记f(str)方法返回一个ArrayList， 即返回字符串str的所有排列。 求f(str)时，确定第一个字符str[i]（for循环），递归调用f(str-str[i])（表示从str字符串中剔除str[i]字符后获得的子串）以获取后面的字符的排列，for循环内部再写一个foreach遍历子串的所有排列情况，拼接后加入ArrayList，返回。 思路输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 可以用递归解决。先通过演算示例“求字符串s=“abc”的所有排列”，来理解本题中如何使用递归： 分析：“abc”的排列包括了： ( 结果abc , acb ,bac , bca, cab , cba ) a + “bc”的排列 结果：abc , acb “bc”的排列包括了 b+”c”的排列 结果：bc “bc”的排列包括了 c+”b”的排列 结果：cb b + “ac”的排列 结果：bac , bca “ac”的排列包括了 a+”c”的排列 结果：ac “ac”的排列包括了 c+”a”的排列 结果：ca c + “ab”的排列 结果： cab , cba “ab”的排列包括了 a+”b”的排列 结果： ab “ab”的排列包括了 b+”a”的排列 结果： ba 通过上述的分析，可以看到我们把原问题分解成了若干个(实际上是s.length()个，如果不考虑重复字符的话，下文会考虑到有重复的情况)子问题，通过求解子问题并合并子问题的解，就得到原问题的解，其实采用了分治法的思想。 字符串s可以由s[i]和s-s[i]拼接而成，（0&lt;=i&lt;s.length()，其中s[i]表示字符串s中的某个字符，s-s[i]表示字符串s截取掉字符s[i]后生成的字符串）。 如上例“求abc的所有排列”这个原问题的其中一个子问题是求a + “bc”的排列，可以理解为：abc排列结果的第一位确定下来是a，后面2位的排列待定，其实它是长度比原字符串小1的子串（也就是bc，因为a已经排列在第一位了，所以把已经确定位置的字符a从原字符串abc中剔除，得到bc）的排列结果，同理地，求字符串bc这个问题又可以分解成 b+”c”的排列和 c+”b”的排列两个子问题。 我们知道，在分治法的思想中，当子问题规模较大时继续采用递归求解子问题，当子问题规模变小时直接求解，以免持续递归无法终止。在本例中，递归的终止条件就是当求解的子问题的字符串长度为1时，只有其自身一种排列结果，直接返回，无需继续递归。 写代码之前，还需要关注到题目中的两个细节： 排列结果按字典序打印 比如说如果要求字符串”cba”的排列结果，我们可以先对字符串内部的字符排序，变成“abc”，再求结果。 可能有重复字符 比如说要求字符串”aab”的排列结果，按照上述案例的思路分析，如果分解成三个问题：a +”ab”的排列，a+”ab”的排列，b+“aa”的排列，可以发现第一种情况和第二种情况重复了，所以为避免重复，实际上在这只需要分解成两个子问题：a +”ab”的排列，b+“aa”的排列。在编程的时候，用一个HashSet保存第一个字符，来保证不重复。 说了这么多，接下来看看代码怎么写吧。 f(str)=str[0]f(str-)+str[1]f(str-) str- 代码123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.Arrays;import java.util.HashSet;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; if(str == null) return new ArrayList&lt;&gt;(); char [] chars = str.toCharArray(); Arrays.sort(chars); return f(String.valueOf(chars)); &#125; /**此函数用于求字符串str的所有排列 */ public ArrayList &lt;String&gt; f(String str)&#123; ArrayList &lt;String&gt; list = new ArrayList &lt;&gt;(); if(str.length() == 1)&#123; list.add(str); return list; &#125; HashSet &lt;Character&gt; set = new HashSet(); for(int i=0; i&lt; str.length();i++)&#123; boolean success = set.add(str.charAt(i));//表示当前字符是否第一次出现 if(success)&#123; //排列的第一位已确定为str.charAt(i)，递归获得后几位，剔除已确定的第一位的子串的所有排列 ArrayList &lt;String&gt; subList = f(str.substring(0,i)+str.substring(i+1)); for(String sub : subList)&#123; list.add(str.charAt(i)+sub); &#125; &#125; &#125; return list; &#125;&#125; 知识点 String和char[]的转化 char [] chars = str.toCharArray() String.valueOf(chars) boolean success = set.add(str.charAt(i)); set是HashSet类型，插入成功（插入前不存在这个元素），set.add()的返回值才为true substring的用法 str.substring(0,i) 包含str[0]~~str[i-1]，不包含str[i] str.substring(i+1)，包含str[i+1]~~str的末尾 题2 变态跳台阶 &lt;%blockquote%&gt; 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 &lt;%endblockquote%&gt; 提示dp====&gt;数学归纳 思路回顾一下 “跳台阶”这题。 &lt;%blockquote%&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 &lt;%endblockquote%&gt; 一开始不好理解，先按照题意举几个例子： 当n=1， 1种跳法（直接跳1） 当n=2, 2种跳法，（先跳1，再跳1）+(直接跳2级) 当n=3， 第一步先跳1级，剩下2级，有2种跳法（查看上面当n=2的情况=2） 第一步先跳2级，剩下1级，有1种跳法（查上面当n=1的情况=1） 所以说，当n=3，总共有2+1=3种 总结出一个通用的式子：记n阶台阶的跳法有f(n)种，都可以有两种做法： 先跳1级，剩下了n-1级, 【f(n-1)种跳法】 而剩下的n-1级的跳法又有以下两种情况 先跳1级，再跳n-2级 先跳2级，再跳n-3级 先跳2级，剩下了n-2级， 【f(n-2)种跳法】 ​ …………………… 所以f(n)=f(n-1)+f(n-2)，其实这个模型符合斐波那契数列。 回到这题。 先写几个找找规律 当 n = 0, 0种 当 n = 1 ,跳1级 1种 当 n = 2 2种 先跳1，剩1级，1种 先跳2，剩0级，1种 当 n =3 结果：4种 先跳1级，剩2级， f(2) = 2种 先跳2级, 剩1级， f(1) = 1种 先跳3级, 剩0级， 1种 当 n =4 结果：8种 先跳1级，剩3级，f(3) =4种 先跳2级，剩2级，f(2) = 2种 先跳3级，剩1级， f(1) = 1种 先跳4级，剩0级， 1种 可以看出，如下规律 f(n) = f(n-1)+f(n-2) +…f(1)+1，为了让式子看起来和谐一点，我们可以让f(0)=1,则式子可以表示成f(n) = f(n-1)+f(n-2) +…f(1)+f(0)。 不难发现 ，f(n-1) = f(n-2)+f(n-3)+….f(0)，所以f(n) = 2 *f(n-1) 代码123456789101112131415public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=2) return target; int dp[]=new int[target]; // dp[i]表示剩下i级时的跳法 dp[0] = 1; //默认为1，可以表示剩0级的时候有1种跳法 dp[1] = 1; dp[2] = 2; for(int i=3;i&lt;target;i++)&#123; dp[i] = 2*dp[i-1]; &#125; return 2*dp[target-1]; &#125;&#125; 数学归纳后的代码: 1234567public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=0) return target; return (int)Math.pow(2,target-1); &#125;&#125; 反思有了“跳台阶”这题的基础，其实很容易想到上述的归纳。 最开始做这题可能会想到递归–&gt;然后发现递归会多次重复计算，可以动态规划—&gt;贪心–&gt;而又发现这题又可以用公式归纳出来，直接求解。 题3 左旋转字符串思路根据定义求解，一步一个脚印 1234567891011121314public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str==null || str.length()==0 || n&lt;=0) return str; while(n!=0)&#123; char first = str.charAt(0); String sub = str.substring(1); //截取字符串 str = sub+first; n--; &#125; return str; &#125;&#125; 改进后：一步到位 12345678public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str==null || str.length()==0 || n&lt;=0) return str; n = n % str.length(); //把这句注释竟然也可以。 return str.substring(n) + str.substring(0,n); &#125;&#125; 题4 构建乘积数组思路一开始没什么思路。先写一个暴力解决，观察哪里有改进的空间。 12345678910111213141516import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; //暴力解法O(n^2) int [] B = new int [A.length]; for(int i = 0;i &lt; A.length ;i++)&#123; int mul = 1; for(int j = 0; j&lt; A.length;j++ )&#123; if(j!=i) mul*=A[j]; &#125; B[i] = mul; &#125; return B; &#125;&#125; 这种做法完全是使用定义做的，比如说当A[n]=5，则B[3] = A[0]XA[1]XA[2]XA[4]，B[4]=A[0]XA[1]XA[2]XA[3]，可以看到计算B[3]和B[4]时有重叠计算的部分（A[0]XA[1]XA[2]）。要想优化，我们就看看是否可以只计算一次重叠的部分。 确实有这样的优化方法，可以将时间复杂度从O(n^2)优化成O(n)。 image-20200428213947621 上图参考了《剑指Offer》，基于此思路的改进代码如下： 12345678910111213141516171819202122232425import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int left [] = new int [A.length]; //左下角计算的中间结果(含对角线) int right[] = new int [A.length]; //右下角计算的中间结果(含对角线) int B[] = new int [A.length]; //返回结果 for(int i = 0; i &lt; A.length; i++)&#123; if(i==0)&#123; left[i]=1; &#125; else&#123; left[i] = left[i-1] * A[i-1]; &#125; &#125; for(int i = A.length-1; i &gt;=0 ; i--)&#123; if(i==A.length-1)&#123; right[i] = 1; &#125;else&#123; right[i] = right[i+1] * A[i+1]; &#125; B[i] = left [i] *right [i]; //在这个循环就可以直接出B[i]，不用再重新写一个for循环。 &#125; return B; &#125;&#125; 进一步改进 进一步观察，会发现其实没必要设置left、right这两个辅助数组，可以直接在B[]数组上操作。 1234567891011121314151617import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int B[] = new int [A.length]; //返回结果 B[0] = 1; for(int i = 1; i &lt; A.length; i++)&#123; //计算 B[i]左边的乘积（含对角线） B[i] = B[i-1] * A[i-1]; &#125; int temp = 1; //temp记录B[i]右边的乘积 for(int i = A.length-2; i &gt;=0 ; i--)&#123; temp = temp * A[i+1]; B[i] *= temp; &#125; return B; &#125;&#125; 题5 和为S的连续正数序列一开始没啥思路，暴力解决。 123456789101112131415161718192021222324import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; arrayList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); //i=sum是想当然的，可以优化 for(int i = sum; i&gt;=2; i--)&#123; //设i个连续数字，x,x+1,x+2.....x+(i-1)的和为sum， int temp = sum; //可以利用等差数列公式，不用这么麻烦 for(int j = 0; j&lt;i ;j++)&#123; //减去每个数字的常数项，以求出x的取值 temp -= j; // temp-0-1-2-...(i-1)，可以直接算出temp - (i/2)*(i-1),不过写的时候要写temp - i*(i-1)/2,否则i为奇数时就不对了。 &#125; int x = temp/i; if(temp % i == 0 &amp;&amp; x&gt;0)&#123; //temp / i的结果必须是整数，且题目要求是正数 ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j = 0 ; j&lt;i ;j++)&#123; //逐个将x,x+1....x+(i-1)加入list list.add(x+j); &#125; arrayList.add(list); &#125; &#125; return arrayList; &#125; &#125; 使用数学知识（等差数列求和公式变形），对上面的代码改进： 12345678910111213141516171819import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; arrayList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i = (int) Math.sqrt(2 * sum) ; i&gt;=2; i--)&#123; //i表示连续数字的个数 int temp = sum - i*(i-1)/2; //减去常数项 if(temp % i == 0 &amp;&amp; temp/i&gt;0)&#123; int x = temp/i; ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j = 0 ; j&lt;i ;j++)&#123; list.add(x+j); &#125; arrayList.add(list); &#125; &#125; return arrayList; &#125; &#125; 这样做，复杂度变成了O(根号s) 还有一个思路是 双指针，控制滑动窗口，可以试试看。 题6 【待改进-贪心】 剪绳子最近递归的题目做的多，思路挺顺的了，这题没想多久，自然而然就想到了。 12345678910111213141516171819202122public class Solution &#123; public int cutRope(int target) &#123; int max =0; for(int m =2 ;m&lt;=target; m++)&#123; //剪几刀 if(cut(target,m) &gt;max) max = cut(target,m); &#125; return max; &#125; //计算n段绳子剪去m段的最大值 public int cut(int n,int m)&#123; //剪下长度为n的绳子，剪m段,每段最少为1 if(m == 0)&#123; //m=0表示不需要剪了，直接返回 return 1; //这里要是return 0，做乘法后结果就都是0了，不对 &#125; int max = 0; for(int i =1 ;i&lt;= n-(m-1);i++)&#123; //第一刀剪掉i，i最少为1，最多为n-(m-1)以确保后面剩余的m-1刀每次都能剪1 if(i * cut(n-i,m-1) &gt;max) max = i * cut(n-i,m-1); &#125; return max; //返回 i* 的最大值 &#125;&#125; 截至今日结束，进度： 40/67 20200427 晴题1 按之字形顺序打印二叉树思路这题和昨天做的”把二叉树打印成多行“很像。都是用层序遍历的思路，区别就在于当访问行数是偶数，要将该行元素的ArrayList反转。 细节 Collections.reverse(arrayList); import java.util.Collections; arrayList.add() ,queue.offer()。一开始没注意写了arrayList.offer()报错了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;import java.util.Collections;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; if(pRoot == null)&#123; return new ArrayList&lt;&gt;(); &#125; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; rows = new ArrayList&lt;&gt;(); Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(pRoot); ArrayList&lt;Integer&gt; row = new ArrayList&lt;&gt;(); int nextLevelNum = 1; //记录还要访问几个元素可以到下一层，即每层元素的个数，初始化是1 boolean needReverse = false; //记录当前行是否需要反转 while(!queue.isEmpty())&#123; //队首节点出队列 TreeNode node = queue.poll(); //将节点值加入row row.add(node.val); if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; nextLevelNum--; if(nextLevelNum == 0)&#123;//说明该层访问完了 if(needReverse)&#123; Collections.reverse(row); &#125; rows.add(row); row = new ArrayList&lt;&gt;(); //重新设定nextLevelNum和needReverse nextLevelNum = queue.size(); needReverse = !needReverse; &#125; &#125; return rows; &#125;&#125; 顺时针打印矩阵参考 题2 平衡二叉树思路我的思路就是根据平衡二叉树的定义解决：一棵树是平衡二叉树，则其左右子树高度差不大于1且左右子树都是平衡二叉树。这种做法是最直观的，但是效率一般（不过也能AC）。 代码123456789101112131415public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if(root &#x3D;&#x3D; null) return true; int balanceFactor &#x3D; treeHeight(root.left) - treeHeight(root.right); return Math.abs(balanceFactor) &lt;&#x3D; 1 &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right); &#125; public int treeHeight(TreeNode node)&#123; if(node &#x3D;&#x3D; null) return 0; int leftHeight &#x3D; treeHeight(node.left); int rightHeight &#x3D; treeHeight(node.right); return Math.max(leftHeight,rightHeight)+1; &#125;&#125; 分析在计算每个节点的深度的时候，进行了多次的重复计算，这样计算的开销还是比较大的。（类比递归求斐波那契数列的重复计算） 又注意到实际上在计算树高时（上面的treeHeight方法）就要计算左右子树高度，这时候就可以判断是否平衡。 改进参考了博客。 核心：把求树的深度与判断树的平衡融合在一起。 改进思路就是在计算root高度的同时，就判断是否出现过不平衡的节点，使用一个成员变量isBalance存放结果（作为全局变量），一旦出现了不平衡节点，isBalance被置为false,则可以停止后续的递归计算。这样做效率比原思路好，只要调用一次treeHeight(root)即可。 12345678910111213141516171819public class Solution &#123; boolean isBalance; public boolean IsBalanced_Solution(TreeNode root) &#123; //当root=null，返回isBalance=true。 isBalance = true; //默认为true treeHeight(root); return isBalance; &#125; public int treeHeight(TreeNode node)&#123; if(node == null || isBalance == false) //如果isBalance已被置为false，可以直接返回，不用再判断了 return 0; int leftHeight = treeHeight(node.left); int rightHeight = treeHeight(node.right); if(Math.abs(leftHeight-rightHeight) &gt; 1)&#123; //判断root是否不平衡 isBalance = false; &#125; return Math.max(leftHeight,rightHeight)+1; &#125;&#125; 题3矩形覆盖思路其实该模型符合斐波那契数列。 f(n) = f(n-1)+f(n-2)， n=0的时候 0种 n = 1 的时候 只能横着覆盖，一种 n = 2 的时候 可以横着和竖着覆盖，两种 n = 3 的时候 第三级竖着覆盖，用了一级，剩下 n = 2，有两种覆盖方法 第三级横着覆盖，用了两级，剩下 n = 1，有一种覆盖方法 总共有 3 种 n = 4 的时候 第 4 级竖着覆盖，用了一级，剩下 n = 3，有三种覆盖方法 第 4 级横着覆盖，用了两级，剩下 n = 2，有两种覆盖方法 总共有 5 种方法 n = n 的时候 第 n 级竖着覆盖，用了一级，剩下 n = n - 1，所以关注第 n - 1 种有几种覆盖方法 第 n 级横着覆盖，用了两级，剩下 n = n - 2，所以关注第 n - 2 种有几种覆盖方法 总和为两种情况的总和 代码123456789101112public class Solution &#123; public int RectCover(int target) &#123; if(target == 0)&#123; return 0; &#125;else if(target == 1)&#123; return 1; &#125;else if(target == 2)&#123; return 2; &#125; return RectCover(target-1) + RectCover(target-2); &#125;&#125; 第n级横着放 改进递归做会有多次的重复计算，可以考虑空间换时间，动态规划求斐波那契数列。 此处略。 ## 【待解决】题4二进制中1的个数思路题目要求是求整数的补码中的1的个数。 我们知道，对于正数，其补码就是原码。如十进制数9的补码=10的原码=0，1001（首位0是符号位）。 而十进制数-9的原码=1，1001（首位1是符号位），其补码是：1，0111 我一开始想的是先算出补码的二进制表示，再计算1的个数，这种效率太低了，要用位运算，这块知识有些忘了，还要再复习一下。 ## 【待解决】题4 数组中只出现一次的数字思路位运算。 位运算异或（XOR）的特点： 0 ^ 0 = 0 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 1 = 1 a ^ a = 0 ,因为a的二进制^a的二进制每一位异或结果都是0。 a ^ 0 = a , 因为a的二进制的每一位与0的异或结果都是本身 结合上述两点，a ^ b ^ a = b 20200426 晴题1 把二叉树打印成多行思路显然，此题是层序遍历的应用。二叉树的层序遍历很简单，使用队列就能完成，本题要在层序遍历的基础上使用一个变量，来记录下一层的元素个数，每当遍历完了一层，就更新这个值，且换行。 提示 题目给的方法返回值是 ArrayList&lt;ArrayList &gt; ，一开始没反应过来，后来仔细一想，是每行的元素单独保存在一个ArrayList里，再返回所有行的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Queue;import java.util.LinkedList;import java.util.ArrayList;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; if(pRoot==null) return new ArrayList &lt;&gt;(); int nextLevelNum = 1; //记录还要访问几个元素才到下一层,初始值为1,因为第一层肯定只有根节点一个元素 Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(pRoot); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; rows = new ArrayList&lt;&gt;(); ArrayList &lt;Integer&gt; row = new ArrayList&lt;&gt;(); while(!queue.isEmpty())&#123; TreeNode node = queue.poll();//当前队头节点出队列 row.add(node.val); //将节点的元素值加入到row列表 if(node.left!=null)&#123; //并将其非空子节点加入队列 queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; nextLevelNum--; //每访问完了一个节点，nextLevelNum就减1 if(nextLevelNum == 0)&#123; //说明这一层已经访问完了，要重新设置它的取值,它的取值其实就是当前队列的元素个数 nextLevelNum = queue.size(); rows.add(row); row = new ArrayList&lt;&gt;(); &#125; &#125; return rows; &#125; &#125; 细节： 队列操作的API、导入所在包，nextLevelNum这个变量是本题精髓！ if(pRoot==null) return new ArrayList &lt;&gt;(); 一开始写的return null，无法通过！ &lt;!--￼99--&gt; 题3 数组中重复的数字思路HashSet 时间复杂度O(n) 空间复杂度O(n) 参考别人的：重排数组 ：时间复杂度O(n)，空间复杂度O(1)。 12345678910111213141516171819202122232425public class Solution数组中重复的数字 &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers == null)&#123; return false; &#125; HashSet &lt;Integer&gt; set = new HashSet &lt;&gt;(); for (int i = 0; i&lt;numbers.length ; i++)&#123; if(!set.contains(numbers[i]))&#123; set.add(numbers[i]); &#125;else&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false; &#125;&#125; 【待解决】题4 数组中的逆序对思路 暴力求解：从第一个元素开始，判断后面比它小的元素的个数 O(n^2)，不出所料，运行超时，通过50%的用例。 【待学习】提示：归并的改进 20200422题1 二叉搜索树的第k个结点做题前思路给定一棵二叉搜索树，请找出其中的第k小的结点。根据BST中序遍历结果是升序的这一性质，可以中序遍历，直到遍历到第k个结点。 按照此思路的代码：12345678910111213141516171819202122//中序递归，成功ACpublic class Solution &#123; int num; //num表示当前中序遍历已经访问了几个元素 TreeNode node; //node存放结果 TreeNode KthNode(TreeNode pRoot, int k) &#123; inorder(pRoot,k); return this.node; &#125; void inorder(TreeNode node,int k)&#123; if(node==null)&#123; return; &#125; inorder(node.left,k); num++; if(num==k)&#123; this.node=node; return; //结束后续的访问 &#125; inorder(node.right,k); &#125;&#125; 分析：就算找到了Kth结点也会遍历完整个BST。时间复杂度是O(N) 改进：可以考虑非递归实现中序遍历，这样就能在找到Kth结点后结束遍历。 【待解决】题2 字符流中第一个不重复的字符做题前思路hashmap 知识点 LinkedHashMap和HashMap的差别 LinkedHashMap Hashmap遍历方法 题3 统计一个数字在排序数组中出现的次数做题前思路 法1：二分查找定位该数字，再找左边和右边相等的元素个数。 多种方法改进参考文章 最后采用的方法：因为数组中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。 123456789101112131415161718192021222324252627282930313233/** * @Created by hfq on 2020/4/23 * @used to: */public class Solution数字在排序数组中出现的次数 &#123; public int GetNumberOfK(int [] array , int k) &#123; return BinarySearch(array,(float)(k+0.5)) - BinarySearch(array,(float)(k-0.5)); &#125; //返回目标t插入array的位置 public static int BinarySearch(int [] array , float t)&#123; int i = 0; int j = array.length-1; int mid = 0; while(i&lt;=j)&#123; //&lt;= 等号不可遗漏！！ mid = j+(i-j)/2; if(array[mid] &gt; t)&#123; //在左边查找 j = mid-1; &#125;else if(array[mid] &lt; t)&#123; //在右边查找 i = mid+1; &#125;else&#123; //实际上不可能发生，可以和上面的else if合并 &#125; &#125; return i; //array[mid]在array[i]和array[j]中添加 &#125; public static void main(String[] args) &#123;// int [] a = &#123;3,3,3,3&#125;; int [] a = &#123;3,3,3,3&#125;; System.out.println(BinarySearch(a, (float) 2.5)); System.out.println(BinarySearch(a, (float) 3.5)); &#125;&#125; 分析：这种做法在各种情况下效率都比较高。 当数组是：[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]，如果采用法1，效率退化成O(n),而这种方法时间复杂度还是O(lgn)级别的 20200421题1：栈的压入、弹出序列代码：1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA==null||pushA.length==0) return true; int stack [] = new int[pushA.length]; int size = 0; int pushIndex=0; stack[size++] = pushA[pushIndex++]; int current = 0; while(pushIndex&lt;pushA.length) &#123; if(stack[size-1]!=popA[current]) &#123; stack[size++] = pushA[pushIndex++]; &#125;else&#123; size--; current++; &#125; &#125; while (size!=0)&#123; if(stack[size-1]!=popA[current]) &#123; return false; &#125; else &#123; size--; current++; &#125; &#125; if(size==0) return true; return false; &#125;&#125; 解析：以输入{1,2,3,4,5}，{4,5,3,2,1}为例。 借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 我的代码没有用JDK提供的Stack，而是用一个数组+size模拟栈。 题2：二叉树的下一个结点代码1234567891011121314151617181920public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; TreeLinkNode successor = null; //表示后续结点，保存返回结果 //当这个结点有右子树，那么其后续结点必然在其右子树中的最小的元素 if(pNode.right!=null)&#123; successor = pNode.right; while(successor.left!=null)&#123; successor = successor.left; //一直向左走找最小的元素 &#125; &#125;else if(pNode.next != null)&#123; //没有右子树但是有根节点 successor = pNode; while(successor.next != null &amp;&amp; successor == successor.next.right)&#123; successor = successor.next; //当此结点始终是其父节点的右子树的时候，逐级找父节点 &#125; successor = successor.next; &#125; return successor; &#125;&#125; 解析：求二叉树某一结点的后续结点。 image-20200421205013742 根据这个pNode结点的状态，分为三种情况求解: pNode存在右子树，那么其后续结点必然在其右子树中。 这是由中序遍历的定义决定的：若某节点存在右子树，那么访问完这个结点后访问的下一个结点必然是右子树中的某个结点。 返回结果是 pNode.right.left.left.left…. pNode不存在右子树，但存在父节点，那么其后续结点是其祖父结点，或者是null 既不存在右子树，也不存在父节点，返回null 提示： 可以借助二叉树的一种特殊情况——二叉搜索树思考这题，上述代码的注释就是这样做的，表面看我们考虑的是特殊情况，但是实际上这样做对二叉树具有普遍性。 另外提一下，这道题目有点坑的地方是：包含指向父结点的指针的变量名是next，不是parent，注意一下。 【待解决】题3:顺时针打印矩阵被这道题虐了很久。。 一直会忽略某些情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hfq;import java.util.ArrayList;public class Main &#123; public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); addElementToList(matrix,0,matrix.length-1,0,matrix[0].length-1,list); return list; &#125; public static void addElementToList(int [][] matrix,int rowsMin,int rowsMax,int colsMin,int colsMax,ArrayList list) &#123; if(colsMax&lt;0 &amp;&amp; rowsMax&lt;0)&#123; return; &#125; for(int i = colsMin; i&lt;=colsMax ; i++)&#123; //从左往右 list.add(matrix[rowsMin][i]); // System.out.println(matrix[rowsMin][i]); &#125; if(rowsMax&gt;rowsMin)&#123; for(int i = rowsMin+1; i&lt;=rowsMax ; i++)&#123; //从上往下// System.out.println(\"i=\"+i+\",colsMax\"+colsMax); list.add(matrix[i][colsMax]); //System.out.println(matrix[i][colsMax]); &#125; &#125; if(colsMax-1&gt;colsMin)&#123; for(int i = colsMax-1; i&gt;=colsMin ; i--)&#123; //从右往左 list.add(matrix[rowsMax][i]); // System.out.println(matrix[rowsMax][i]); &#125; &#125; if(colsMax-colsMin&gt;=1 &amp;&amp; colsMax &gt; colsMin )&#123; for(int i = rowsMax-1; i&gt;=rowsMin+1 ; i--)&#123; //从下往上 list.add(matrix[i][colsMin]); // System.out.println(matrix[i][colsMin]); &#125; &#125; addElementToList(matrix,rowsMin+1,rowsMax-1,colsMin+1,colsMax-1,list); &#125; public static void main(String[] args) &#123;// int a [][] =&#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;&#125;;// int a [][] =&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;; int a [][] =&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;,&#123;7,8&#125;,&#123;9,10&#125;&#125;; ArrayList&lt;Integer&gt; integers = printMatrix(a); for(Integer integer:integers)&#123; System.out.printf(integer+\",\"); &#125; &#125;&#125; 题4:包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。 思路一开始我的想法很简单，用一个使用一个变量记录当前的最小元素，如果新压入栈的元素更小，就更新它。 但是仔细一想，这种做法有一个问题，假如记录的最小元素出栈了，就没办法以O(1）的时间复杂度获取新的最小元素了，所以在保存最小元素的同时，有必要保存最小元素出栈后次要小的元素，同理，也要保存第三小的元素…. 所以，要用一个辅助栈来保存当前的最小元素以及之前的的最小元素，栈顶就是当前栈的最小元素，栈顶元素的下一个元素就是这个元素出栈后的新的最小元素。 每次压栈时，如果压入的元素小于当前最小元素，则也将其压入辅助栈，否则，则将上一个最小元素压入辅助栈。 每次出栈时，弹出元素的同时也弹出辅助栈的元素。 知识点复习Stack的API peek() size() pop() push() 代码12345678910111213141516171819202122232425262728import java.util.Stack;public class Solution &#123; public Stack &lt;Integer&gt; stack = new Stack&lt;&gt;(); //数据栈 public Stack &lt;Integer&gt; minStack = new Stack&lt;&gt;();; //辅助栈 public void push(int node) &#123; stack.push(node); if(stack.size()==1)&#123; //现在是1，说明压栈前是0。 minStack.push(node); &#125;else&#123; minStack.push(node&lt;minStack.peek() ? node : minStack.peek()); &#125; &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125; 题解关键字 ：最小值辅助栈 题5 把数组排成最小的数没啥思路，借鉴了网上的解法，觉得很妙。 关键字：自定义比较大小的方法。 提示转成字符串，自定义比较器后排序 知识点复习 int类型转成String类型 String.valueOf(i) Integer.toString(i) i+”” 比较字符串大小 拼接字符串 （StringBuilder） sb.append() sb.toString() 代码细节 Arrays.sort() import java.util.Arrays; Comparator import java.util.Comparator; 123456new Comparator&lt;String&gt;() &#123; @Override public int compare(String str1, String str2) &#123; //3 12 312 123 return 0; &#125;&#125; 代码12345678910111213141516171819202122232425262728293031/** * https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993 * @Created by hfq on 2020/4/22 * @used to: * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数， * 打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。 */public class Solution把数组排成最小的数 &#123; public static String PrintMinNumber(int [] numbers) &#123; StringBuilder sb = new StringBuilder(); String numString [] = new String[numbers.length]; for (int i=0; i&lt;numbers.length; i++)&#123; numString[i]=String.valueOf(numbers[i]); //将整数转成字符串 &#125; Arrays.sort(numString, new Comparator&lt;String&gt;() &#123; @Override public int compare(String str1, String str2) &#123; //3 12 312 123 return 0; &#125; &#125;); for (String str : numString)&#123; sb.append(str); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; int[]numbers=&#123;3,32,321&#125;; System.out.println(PrintMinNumber(numbers)); &#125;&#125; 进度：25题/67题。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"置顶文章","slug":"置顶文章","permalink":"http://hfq123.github.io/tags/%E7%BD%AE%E9%A1%B6%E6%96%87%E7%AB%A0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter8","date":"2020-04-21T06:52:00.000Z","path":"2020/04/21/《Head-First-设计模式》读书笔记charpter8/","text":"本篇博客是《Head First 设计模式》第八章的读书笔记。 分享主题是设计模式中的 「模板方法模式(Template Method Pattern)」。 定义模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 具体应用场景从饮品店制作咖啡和茶的制作方法讲起，咖啡和茶的制作流程如下图所示。 咖啡和茶的制作流程 接下来用代码表示咖啡的制作过程： 12345678910111213141516171819202122232425/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的制作流程 */public class Coffee &#123; public void prepareRecipe()&#123; //冲泡咖啡 boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void brewCoffeeGrinds()&#123; System.out.println(\"Dripping Coffee through filter\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addSugarAndMilk()&#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125; 同样的，茶的制作过程代码如下： 123456789101112131415161718192021222324/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea &#123; public void prepareRecipe()&#123; //冲泡茶 boilWater(); steepTeaBag(); pourInCup(); addLemon(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void steepTeaBag()&#123; System.out.println(\"Steeping the tea\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addLemon()&#123; System.out.println(\"Adding lemon\"); &#125;&#125; 可以发现，boilWater()和pourInCup()方法的代码重复了。究其原因，这是因为咖啡和茶的制作流程大致上一样，它们的制作过程都可以用下图的算法表示，1、3步骤是一样的，2、4步骤有差异，所以我们想到用继承的方法重用1、3步骤的代码，将实现1、3步骤的方法抽取到一个父类中，而2、4步骤这两个有差异的步骤在咖啡子类和茶子类中实现。 制作咖啡和制作茶的相同和不同的步骤 基于此想法，我们设置一个咖啡因饮料的父类： 1234567891011121314151617181920212223/** * @Created by hfq on 2020/4/21 * @used to: 咖啡因饮料的父类，是一个抽象类 */abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); addCondiments(); &#125; void boilWater()&#123; //步骤1，共同的操作，由父类实现 System.out.println(\"Bolling water\"); &#125; abstract void brew(); //步骤2，冲泡，由于不同饮料实现有差异，由子类实现 void pourInCup()&#123; //步骤3，共同的操作，由父类实现 System.out.println(\"Pouring into cup\"); &#125; abstract void addCondiments(); //步骤4，添加调料，由于不同饮料实现有差异，由子类实现&#125; 现在咖啡子类和茶子类的代码就变成了： 12345678910111213141516171819202122232425262728293031/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的冲泡流程 */public class Coffee extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Dripping Coffee through filter\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125;/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Steeping the tea\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding Lemon\"); &#125;&#125; 这样，我们就完成了共同代码（prepareRecipe()、boilWater()、pourInCup()三个方法）的重用。其中，prepareRecipe()方法就叫做模板方法。它作为制作咖啡因饮料算法的模板，在这个模板中，每个步骤都被一个方法代表了，其中，制作不同的咖啡因饮料有共同的步骤：就是上文说的步骤1和步骤3，它们可以直接在父类中实现(分别对应于boilWater()和pourInCup()方法)。制作不同的咖啡因饮料也有不同的步骤：步骤2和步骤4，由于子类有不同的实现，所以父类中不实现，设置为抽象方法，由子类实现，这就是模板方法模式中说的“将一些步骤延迟到子类中”。 如果有新的制作流程一致的咖啡因饮料加入，只需要继承父类，并负责实现父类的抽象方法（表示制作步骤中不同的部分）。 UML图模板方法模式的UML建模图如下： 模板方法模式的UML建模图 使用钩子(Hook)在上例中引入一个新的需求：客户可以自行选择是否需要在饮料中加入调料（也就是选择是否执行制作饮料中的步骤4），这时模板方法的钩子就起作用了。 做法很简单：在模板方法中，加入判断，如果判断为真，则执行步骤4，修改后的模板方法类代码如下： 1234567891011121314abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); if(customerWantsCondimentsHook())&#123; addCondiments(); &#125; &#125; ...省略了相同的代码.... boolean customerWantsCondimentsHook()&#123; //这是一个钩子，子类可以选择是否覆盖 return true; &#125;&#125; 这样一来，在子类中可以覆盖customerWantsCondimentsHook()方法来自行选择是否需要执行步骤4，它还可以更灵活地实现钩子：比如接受用户的输入，据此判断是否需要执行该步骤。 在这里，钩子作为条件控制，影响了抽象类的算法流程。 好莱坞原则书中本章引入了一个新的设计原则，称为好莱坞原则： 好莱坞原则（Hollywood Principle）：别打电话给我们，有事我会打电话给你。 好莱坞原则和模板方法之间的连接比较明显，当我们设计模板方法模式时，我们告诉子类，不要调用我们，我们会调用你。让我们再看一下的咖啡因饮料的设计类图： 好莱坞原则和模板方法 Java API中的模板方法书中指出，模板方法模式很常见，因为对于创建框架来说，这个模式简直棒极了。由框架控制如何做事情，而由使用框架的人指定框架算法中的每个步骤的细节。另外，模板方法有多种实现，不一定看起来和上例讲述的设计一致。 书中给出三个java api中的模板方法示例： 类实现comparable接口后可以用Collections.sort Swing Applet 第一个示例归结于模板方法我觉得似乎有些牵强，后两个示例平时开发没使用过，不熟悉。所以讲讲另外一个比较熟悉的示例吧：Servlet类的service()方法就是一个模板方法，定义了算法骨架，doGet()、doPost()方法是这个算法骨架中的具体步骤，子类可以实现自己的doGet()方法和doPost()方法，这样做子类自己的doGet()、doPost()方法就”挂进”了父类service()方法这一模板方法。 与我们上文咖啡因饮料示例不同的是，子类具有不同实现的方法在父类是抽象的，子类必须实现，而Servlet中的doGet()和doPost()有默认实现。 Servlet中的模板方法 Servlet中的模板方法具体实现参考这里。 总结 模板方法模式实际上是封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同实现，从而让固定的流程产生不同的结果。 模板方法封装了有固定结构的算法块，模板类中可以有各个子类具有相同实现的方法，也可以有各个子类具有不同实现的方法，具有相同实现的方法可以直接在父类（模板方法所在的类）中实现，而各个子类具有不同实现的方法由每个子类自行实现，这样做，子类实现的方法就“挂接”进模板方法里。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter7","date":"2020-04-20T14:40:09.000Z","path":"2020/04/20/《Head-First-设计模式》读书笔记charpter7/","text":"本篇博客是《Head First 设计模式》第七章的读书笔记。 分享主题是设计模式中的 「适配器模式(Adapter Pattern)」以及 「外观模式(Facade Pattern)」。 适配器模式由于这两种设计模式都比较好理解，所以先直接从定义讲起。 定义适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 日常生活的类比我们先用日常生活中例子类比来理解适配器模式。如下图，由于接口的差异，美国笔记本电脑插头无法直接插进欧洲插座获电，而使用了中间的接口转换器后，问题就解决了。而值得注意的是，从无法使用到可以使用，我们既没有改变插座，也没有改变插头，唯一的变化就是引入了接口转换器这一适配器。在这里，这个适配器的作用就是将现有的不符合标准的插头接口“转化”成目标接口，这也正是适配器模式做的全部工作。 插头接口转换器的例子 具体应用场景如下图，系统中有两个接口:Duck和Turkey，它们都有fly()方法，这两个接口的差异在于Duck的quack()和Turkey接口的gobble()方法。MallardDuck和WildTurkey分别实现了Duck接口和Turkey接口。 image-20200420231854471 此外，在外部有个testDuck方法，它的参数是一个Duck对象，在方法体内分别调用了这个Duck对象的quack()方法和fly()方法，我们无需关注它的目的是什么，只需要关注要想调用这个方法，需要一个Duck类型的对象作为参数。 1234public static void testDuck(Duck duck)&#123; duck.quack(); duck.fly(); &#125; 接下来看看下面这段代码，testDuck(wildTurkey)这行代码必然会报错，因为wildTurkey 不是 Duck类型的。 123456789public static void main(String[] args) &#123; System.out.println(\"A duck says:\"); Duck mallardDuck =new MallardDuck(); testDuck(mallardDuck); //这行代码可以正常执行 System.out.println(\"A turkey says:\"); Turkey wildTurkey =new WildTurkey(); testDuck(wildTurkey); //这行代码必然会报错，因为wildTurkey 不是 Duck类型的。&#125; 我们用这个例子来类比上文中插头接口转换器的例子，testDuck()这个方法就相当于上例中的插座，它要求一个Duck对象作为参数才可以正常使用（换句话说，它的标准是Duck接口），就相当于欧洲插座要求一个符合欧洲标准的插头才能正常使用，不符合testDuck()标准的wildTurkey对象就相当于上例中的美国插头（类比详见下图）。而如果我们要是想在不改动WildTurkey类代码的基础上，完成testDuck(wildTurkey)这条语句的功能，就要想办法构建一个上例中的适配器。 类比插头接口转换器的例子 构建TurkeyAdapter这个适配器： 123456789101112131415161718192021/** * @Created by hfq on 2020/4/21 * @used to: 为Turkey接口构造适配器，以使得它符合Duck接口这个标准 */public class TurkeyAdapter implements Duck&#123; //适配器要实现目标接口Duck Turkey turkey; //组合了一个Turkey接口的对象 public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; //这里直接调用了turkey的gobble方法，当然，你也可以做点别的 this.turkey.gobble(); &#125; @Override public void fly() &#123; this.turkey.fly(); &#125;&#125; 测试代码： 1234System.out.println(\"A turkey says:\");Turkey wildTurkey =new WildTurkey();TurkeyAdapter wildTurkeyAdapter = new TurkeyAdapter(wildTurkey);testDuck(wildTurkeyAdapter); //完成了接口转化 至此，一个应用适配器模式的demo就写完了。引入了适配器后，在既不修改WildTurkey类代码、又不修改testDuck方法的代码的基础上，我们完成了原本不兼容的工作，看上去就像实现了将一个Turkey接口的对象转化成一个Duck接口的对象。 UML图适配器模式的UML建模图如下，为了便于理解，我结合刚才的例子添加了红字标注出上例中的各个部分分别代表了什么。适配器Adpter实现了目标接口，且其类中组合了一个被适配器Adptee的对象。 p.s 我本篇博客介绍的例子是采用对象组合的方式实现适配器模式，书中还给出了另外一种实现适配器模式的思路——多重继承，简而言之就是Adapter既继承Target，又继承Adaptee，由于java语法不支持多重继承，在此不做过多介绍。 适配器模式的UML图 以上就是适配器模式的全部内容了，是不是很简单！接下来一起来看看更简单的外观模式吧。 外观模式定义外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 具体应用场景书中给出的例子是家庭影院的例子：放映电影需要执行一系列任务，这些任务涉及到了多个对象（以及它们对应的多个方法），这导致了每次需要放映电影都要写上一长串代码。 image-20200421005039865 你需要的正是一个外观：有了外观模式，通过实现一个更合理的接口的外观类，你可以将一个复杂的子系统变的容易使用。所以我们引入一个外观类HomeTheaterFacade，这个类中组合了所有与放映电影相关的对象（爆米花机、投影仪等等），它提供了一些更加友好的方法（每个方法都是一个子系统）以供调用，调用方不用知道方法内部是如何做的，以放映电影为例，调用方只需要提供需要完成放映操作的对象实例化HomeTheaterFacade，再调用它的watchMovie()方法，引入外观模式后的类图如下所示： 家庭影院外观类图 放映电影的内部方法代码和调用放映电影方法的代码见下图： 放映电影方法、调用放映电影方法的代码实现 适配器模式和外观模式总结适配器模式在不修改接口的代码的基础上，提供了将一个接口转成另一个接口的方法，以达到兼容。 外观模式定义了一个高层接口,让子系统更容易使用，接口简单对调用方更友好。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter5","date":"2020-04-18T14:19:15.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter5/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「单件模式(Singleton Pattern)」。 单件模式（也常叫单例模式）可以说是最简单的设计模式了，然而具体实现的还是有些讲究的，本文梳理了四种单例模式的实现方法 。其中前三种是书上给出的，最后一种书上没有提到，以作补充。 单例模式的基本认识 定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。 用来创建只能有一个实例的独一无二对象。 比如说线程池、缓存、对话框、处理偏好设置、注册表、日志对象、打印机等设备的驱动程序的对象。 可以确保只有一个实例会被创建，单件模式给了我们一个全局的访问点，和全局变量一样方便，又没有全局变量的缺点。 单例模式的四种实现方法一、懒汉 实现 私有的构造函数 私有的静态变量表示唯一实例，不初始化 公开的静态方法获取唯一实例 分析 优：延迟实例化(lazy instantiaze) 类加载时不会初始化，用到了才会产生(实例化) 缺：多线程可能引发创建多个实例(在不加synchronized关键字的情况下) 改进：为getInstance()方法加上synchronized关键字 引入了新的问题：降低了性能，为什么？ 因为实际上只有第一次执行此方法时，才真正需要同步，一旦设置了instance变量，就不再需要同步这个方法了。所以说，之后每次调用这个方法，同步都是一种累赘。 1234567891011121314151617/** * @used to: 懒汉实现单例模式，两私有一公开 */public class Singleton &#123; private static Singleton instance; private Singleton()&#123; &#125; public synchronized static Singleton getInstance()&#123; //如果不加synchronized关键字，多线程情况下，此处可能创建多个不同的实例对象 if (instance ==null) instance =new Singleton(); return instance; &#125;&#125; 二、饿汉饿汉单例模式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快。 实现 私有的构造函数 私有的静态变量表示唯一实例，初始化 公开的静态方法获取唯一实例 分析 与懒汉比较：饿汉在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快 优：不会有多线程导致创建了多个实例的问题 缺：即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。 1234567891011121314/** * @used to: 饿汉实现单例模式 */public class Singleton2 &#123; private static Singleton2 instance = new Singleton2(); //类加载时完成初始化 private Singleton2()&#123; &#125; public static Singleton2 getInstance()&#123; return instance; &#125;&#125; 三、双重校验锁DCL【推荐】 目标：是对懒汉中同步性能的优化，实现有更高同步性能的延迟加载。 实现 private static volatile Singleton instance 为什么要volatile？ if (instance == null) 校验1 synchronized (Singleton.class) if (instance == null) 校验2 分析 123456789101112131415161718192021/** * @used to: DCL（双重校验锁）实现单例模式 核心：volatile和两次校验 */public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3()&#123; &#125; public Singleton3 getSingleton()&#123; if (instance == null)&#123; //校验1,仅当singleton为空会进行同步。 synchronized (Singleton3.class)&#123; if(instance == null)&#123; //校验2，防止多线程中，不同线程执行到校验1，然后依次获得多个实例。 instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125;&#125; 四、静态内部类【推荐】 书上没给出这种方法，是从其他博客中学习到的。 1234567891011121314151617/** * @used to:静态内部类实现单例模式 */public class Singleton4 &#123; private static class SingletonHolder&#123; //静态内部类 private static Singleton4 instance = new Singleton4(); &#125; private Singleton4()&#123; &#125; public static Singleton4 getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 分析 它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。 不一样的是，它是在内部类里面去创建对象实例。 这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。 总结评价单例模式的四种实现方法主要从以下两个角度考虑： 是否延迟加载((lazy instantiaze)) ？ 怎么保证线程安全，在保证线程安全的情况下，性能如何 ？","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter4","date":"2020-04-18T08:38:11.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter4/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「工厂模式(Factory Pattern)」。 本读书笔记系列前几篇文章写得比较冗长，耗时也久，大半天才写出一篇博客。从这篇开始，尝试换种风格，尽量写的简洁一点，忽略一些不必要细节，先整体过一遍再来看看有无补充得必要。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter3","date":"2020-04-18T02:12:57.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter3/","text":"本篇博客是《Head First 设计模式》第三章的读书笔记。 分享主题是设计模式中的 「装饰者模式(Decorator Pattern)」。 应用背景——种类繁多的饮料的“类爆炸”背景书中给出的例子是，一家饮品店的饮品种类繁多，且客户可以自行选择在饮品内加入收费的调料（调料当然也有多种）。即使是同一种的饮品，由于加入了不同的调料，价格也会有差异，如何计算饮品的价格就成了一个问题。如下图1，书中给出的第一个尝试是列举所有饮品的可能情况来构成饮品的所有子类，如HouseBlendWithSoy(表示带调料Soy的HouseBlend饮品类)，由于饮品和调料的组合方式很多，这势必会造成”类爆炸”。 图1 但凡有点开发经验的都不会像上面这样做，我们往往都能想到通过继承解决类爆炸的常规思路，而继承解决会带来一些问题，这就需要引出本文的主角装饰者模式了，一起来看看吧。 通过继承解决具体做法是：为饮品父类中添加一些布尔类型的成员变量(如milk、soy等,都是调料名)来表示是否有该调料，和它们对应的成员方法(如hasMilk())。在父类的计算饮品价格方法 cost()中，依次判断是否加入了各调料，也就是判断该调料的变量是否为true，如果是true就在饮品的基础上加上这种调料的价格。如此一来，针对一个带特定调料的饮品对象，只需要设置它的这些成员变量的状态，使用继承自父类的cost()方法就能计算价格了。这种做法很简洁易懂，然而可拓展性不好：如果客户需要在饮品中加入双倍的某种调料，就要修改现有的代码：在饮品的父类中再加入多个成员变量(如milkNum,soyNum)来记录饮品的调料数目，同时，也会修改父类计算饮品价格的cost()方法，因为现在还要乘上调料的数量。 通过装饰者模式解决现在我们还不用着急知道什么是装饰者模式，只需要知道它的基本思路就是：用一种种调料层层“包装”饮品，然后逐级调用cost()方法来获得最终饮品的价格。 下图是用调料层层包装饮品的示例，模拟了加入了两种调料(Mocha和Whip)的DarkRoast饮品。 图2 我们姑且把调料叫做装饰者，把饮品叫做被装饰者。但是，这里有个小细节，调料既可以用来包装饮品（如图上红字标出的调料1对象包装了一个饮品对象），还可以包装其他调料（如图上红字标出的调料2包装了一个调料1对象），也就是说调料1在这里既作为最内层饮品的“装饰者”，又作为外层调料2的“被装饰者”。 为了标记每个装饰者包装的对象是谁，我们有必要在装饰者类（就是调料类）里设置个成员变量warppedObj——一个指向“被装饰者”的引用，那这个成员变量的类型应该是什么呢？这里有点绕，再次强调一下，调料2的“被装饰者”是调料1，其类型是调料，调料1的“被装饰者”是饮品，其类型是饮品，所以说这里怎么设置warppedObj的类型都不对：如果设置成饮品类，那么调料2就无法包装调料1，如果设置成调料类，那么调料1就无法包装饮品。也就是说如果要正确设定warppedObj类型以支持以上情形，就要完成调料类和饮品类的类型统一。书中的做法是让调料类继承饮品类，以达成类型的统一。 搞懂了这个，接下来的事情就好办了，如上图2，我们的目标是：计算有1份Whip、1份Mocha的DarkRoast饮品价格，做法就是先new一个Mocha对象包装DarkRoast对象记作obj1，在new一个Whip对象包装obj1。计算价格的时候调用最外层调料2对象的cost()方法，它的实现是调用其包装了的对象调料1的cost()方法获得调料1对象的价格，再加上自己的价格，而调料1的cost()实现又是调用内层饮品的cost()方法再加上自己的价格，以此类推，计算价格的过程就像上图2标出的6步流程。 如果这个饮品需要加入双倍的Whip调料，只需要再用一层Whip来包装，不用对其他代码改动。 装饰者模式装饰者模式思想在给出装饰者的定义之前，先来谈谈其“主要指导思想”，装饰者模式的指导思想是组合而非继承（在策略模式中也提到过）、开放关闭原则。 组合而非继承 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相关同的行为。然而，如果通过组合的做法扩展对象的行为，就可以在运行时动态地进行拓展。 开放关闭原则 含义：类应该对扩展开放，而对修改关闭。 解读：在不修改任何底层代码的情况下，给你的对象赋予新的职责。 这两条是书中引出装饰者模式的思想，现在理解不了没关系，先通读下文，再来回顾装饰者模式是如何遵循这两条思想的。 装饰者模式定义装饰者模式动态地将责任附加到对象上，若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。 装饰者模式UML图本案例中，使用装饰者模式后，uml图建模如下： 饮品是被装饰者（书中也叫做组件Component），可以被多种调料“包装”，它始终在最内层。 调料是装饰者，用来”包装“饮品，但是需要注意的是，调料同时也可能作为被装饰者，因为它外层可能还有别的调料来包装它。 在uml图中，我们特别需要关注的是饮品类和调料类的关系： 首先，调料子类里组合了饮品的对象。这个其实很好理解，就是记录调料这一装饰者包装了什么饮品（或者是包装了”包装了饮品“的调料）。 其次，调料的父类继承了饮品父类，也就是说调料也是饮品的子类，就像上文说的，它的目的是完成“调料类和饮品类的类型统一”。以我的理解，这里的继承的具体作用有两个:一是让调料类获得饮料类的方法，如cost()方法，二是以便于其它的调料类包装”包装了饮品的调料类“。 实际中的装饰者模式——java.iojava.io包提供的众多输入输出流相关的类，就是应用了装饰者模式。 输入流层层包装，外层流为内层流提供了新的服务。如下图，InputStream是被装饰者类父类,FilterInputStream是一个很多装饰者类的父类，其中有一个InputStream类型的名为in的成员变量。 image-20200418111628569 下面我给出了一个自定义InputStream的装饰类Demo,作用是将输入流字母变成小写。 12345678910111213141516171819202122232425/** * LowerCaseInputStream.class * @Created by hfq on 2020/4/18 * @used to: 编写自己的Java IO装饰者类,负责将输入流字母变成小写 * @return: */public class LowerCaseInputStream extends FilterInputStream &#123; /** * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt; * by assigning the argument &lt;code&gt;in&lt;/code&gt; * to the field &lt;code&gt;this.in&lt;/code&gt; so as * to remember it for later use. * * @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if * this instance is to be created without an underlying stream. */ protected LowerCaseInputStream(InputStream in) &#123; super(in); &#125; public int read() throws IOException &#123; int c = super.read(); return c==-1?c:Character.toLowerCase((char)c); &#125;&#125; 测试代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * JavaIoTest.class * @Created by hfq on 2020/4/18 * @used to: 测试代码 * @return: */public class JavaIoTest &#123; public static void main(String[] args) throws Exception &#123; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(\"designpatternlearning.iml\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"文件不存在！\"); &#125; System.out.println(\"读到的第一个字符是:\"+(char)inputStream.read()); DataInputStream dataInputStream = new DataInputStream(inputStream); //使用DataInputStream包装InputStream System.out.println(\"读到的一行字符是:\"+dataInputStream.readLine()); //使用自定义的DataInputStream包装InputStream LowerCaseInputStream lowerCaseInputStream = new LowerCaseInputStream(dataInputStream); int c = 0; System.out.println(\"剩下的字符【经过自定义IO流过滤大写字母为小写字母处理】：\"); while((c = lowerCaseInputStream.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; inputStream.close(); //长得更像装饰者模式的写法： InputStream in = new LowerCaseInputStream(new DataInputStream(new FileInputStream(\"designpatternlearning.iml\"))); while((c = in.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; in.close(); &#125;&#125; 总结 装饰者模式的UML建模图 如上图所见，装饰者模式的核心就是：装饰者既是一个(is-a)被装饰者，又有一个(has-a)被装饰者。 is-a 装饰者和被装饰者是相同的类型，这样做是为了利用继承达到“类型匹配”而不是为了利用继承“获得行为”。“类型匹配是说”一个装饰类的接口必须与被装饰类的接口保持相同。 has-a 指的是在装饰者的类中组合了一个被装饰者对象。 感悟 首先我觉得，书中这个这个例子其实并不是很好，调料类继承了饮品类，虽然知道它这样做是为了统一类型（使得装饰类既可以包装饮品，也可以包装其他的装饰类），但将调料作为饮品的子类的子类总归很别扭。 另外我觉得理解装饰者模式的核心就是理解”装饰类的接口必须与被装饰类的接口保持相同”，其根本原因是装饰者既要包装被装饰者，也要包装和它同类型的其他装饰者。 装饰者模式通过“层层包装”来装饰内层对象，为最内层的原对象锦上添花，添加新功能，扩展性好。 最后，以书中关于开放关闭原则的描述结尾： 代码应该如同晚霞中的莲花一样关闭（免于改变），如同晨曦中的莲花一样开发（能够扩展）。 这也就是引入装饰者模式的目标吧！","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"cxsj项目-停车位使用情况可视化","date":"2020-04-10T00:53:18.000Z","path":"2020/04/10/cxsj项目-停车位使用情况可视化/","text":"需求分析在智慧停车管理平台(WEB端)项目中，为了清晰地展示当前停车场的车位使用情况，想到把车位的使用状态可视化地展示到室内停车场地图上。效果如下： image-20200410113840534 根据室内地图的车位图标颜色不同，用户可以看到停车场各个车位的使用状态。此外，当用户点击地图内的车位图标时，还能获取当前指定车位的状态（是否占用，如果占用，还会显示车牌号）。 实现技术前端：Jquery (ajax请求数据) 后端：SpringBoot Mybatis (数据库查询数据) 室内地图支持：Esmap （地图展示) 实现方案1. 引入Esmap的室内地图,熟悉其sdk首先，从下载室内地图的示例，以获得示例地图的数据包。我选择的是“基本地图显示”示例。 然后，在html中引入室内地图，这一步Esmap官网的开发文档有详细的流程我就不多介绍了。按照指示引入地图到html后，实现的初始效果如下： image-20200409174547260 示例默认的主题颜色比较单调，可以通过配置参数来修改主题样式（如地图背景颜色等）。 接下来，熟悉Esmap的sdk，本案例中，我们主要关注的就是：如何跟踪点击事件？(用户点击后停车位能够触发操作)，修改图标的颜色（加载车位可视化页面时根据车位的使用状态为车位图标设置不同的颜色），发现这分别对应开发文档中地图事件中的“地图点击返回事件”和常用方法中的“改变房子颜色”的changeModelColor()方法。 接下来我们就研究一下这两个方法。 方法1：地图点击返回事件12345//地图点击返回事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.htmlmap.on('mapClickNode', function(event) &#123; console.log(event); //打印事件&#125; 可以发现，当点击地图的车位图标时，打印的车位对象如下图。 image-20200410095433726 因为点击地图其他图标(比如说楼梯、道路)也会触发地图点击事件，而在本案例中我们只要关注点击车位事件，所以我们可以以地图点击返回事件event中的name属性里是否包含”车位”二字来区分被点击的图标是否为车位，如果判断是车位，才会触发后续的方法changeModelColor()来改变被点击车位的颜色。 方法2：改变房子颜色123456789//改变房子颜色(一定要在地图加载完成事件之后才有效)//id,name二选择一，都可以是数组, fnum可选择，参数color:'#FF0000'//https://www.esmap.cn/escopemap/content/cn/develope/map-fun.htmlmap.changeModelColor(&#123; //id:[1,2], name:'车位1091', //fnum:[1], color:'#FF0000'&#125;) 需要注意开发文档里指出的”一定要在地图加载完成事件之后才有效”。也就是说，changeModelColor()方法要在加载完成事件完成后调用，如下： 12345//地图加载完成事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.html map.on('loadComplete', function () &#123; map.changeModelColor()方法要在此调用！！！&#125;); 至此，我们就完成了地图页面展示，掌握了点击车位图标触发事件的方法和修改车位图标颜色的方法。 2. 创建停车位的数据表和后端api接口在我创建的车位数据表中，有这样几个主要字段： 车位标识id：由于在本案例我们使用的室内地图数据包中，所有车位对象的name属性在“车位1001~车位1102”，为了下一步地图车位对象和数据库记录的绑定，车位id的值也设置在此范围内。 车位所在停车场标识parkinglot_id：由于我的项目涉及到多个停车场，需要此字段，如果只是有一个停车场可以不用此字段。 车位状态标识in_use：若车位是空闲状态，取值0，若占用取1。 车牌号car_id：若车位占用，存车牌号，否则为空。 停车时间park_time：若车位占用，存此车进入车位的时间戳，否则为0。 创建好车位数据表之后，生成一些假数据（我是通过写了一个java类，按照给定格式随机生成记录，然后拼接字符串打印这条记录的insert语句，然后到数据库执行，后来网上了解一下，或许可以尝试使用Python的伪造数据生成器Faker），生成的部分假数据如下图展示。 image-20200410102612112 下一步，写一个Controller，完成车位查询的api接口，响应POST方法，为请求返回json数据，代码如下： 1234567891011121314151617181920212223242526/** * * @param parkinglot_id 停车场ID * @param parking_space_id 车位id * @return * 如果参数parking_space_id 为空，查找所有停车场ID为parkinglot_id的所有车位使用情况 * 如果参数parking_space_id非空，根据停车场id和车位id 查询一条记录。 */ @ResponseBody @PostMapping(\"/parkinglot/&#123;parkinglot_id&#125;/space\") private Object selectAllSpace(@PathVariable(name = \"parkinglot_id\") Integer parkinglot_id, @RequestParam(name = \"parking_space_id\",required = false) Integer parking_space_id )&#123; ParkingSpaceExample example = new ParkingSpaceExample(); if(parking_space_id!=null)&#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id) .andIdEqualTo(parking_space_id); &#125; else &#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id); &#125; List&lt;ParkingSpace&gt; parkingSpaces = parkingSpaceMapper.selectByExample(example); return parkingSpaces; &#125; 如果请求时携带了parking_space_id参数，就只查询车位id等于parking_space_id的那条车位记录，否则，查询该停车场的全部车位记录。请求参数携带车位标识和不携带车位标识这两种请求应用场景分别是：加载页面时，需要查询全部车位的车位状态，而用户点击地图的某个车位图标时，只需要查询这一个车位状态。 当不携带车位标识时，某次请求响应的部分json数据如下图展示。 image-20200410104637275 至此，我们就完成了车位数据表的建立和查询。 3. 将地图显示和数据库“绑定”这一步我们就完成可视化的任务，具体需要完成的功能有两个：功能一是加载车位详情页面的时候，查询车位数据表，根据车位状态为地图的车位图标“上色”（空位占用则红，车位空闲则为绿）；功能二是当用户点击车位图标时，查询数据库该车位的当前状态并显示出来（如果车位占用还会显示出当前的车牌号）。 有了步骤1、2的基础后，这一步就很简单了，简单地说，就是用步骤2的数据填充到步骤1的方法内。具体做法是在javascript脚本中使用ajax请求获取后端的车位数据，然后对这些数据按指定格式处理，作为调用Esmap sdk的配置参数。 以功能一的实现为例： 使用ajax向步骤2中编写好的用于查询车位的api接口发送请求，获得请求后的json数据后，遍历每条数据（对应车位数据表的一条记录），根据数据的inUse属性的取值来标识车位是占用还是空闲状态，然后拼接“车位”二字到数据的id属性的取值，就获得了这条记录对应在地图上车位图标对象的name属性（也就是说，数据库中的车位id为1001的车位记录对应地图上name=”车位1001”的地图对象)。设置js数组inUseNameList和notInUseNameList，它们分别是全部占用车位对应的地图车位图标的name属性数组、全部空闲车位对应的地图车位图标的name属性数组。调用 map.changeModelColor()方法设置地图车位图标的颜色时，指定name参数为inUseNameList，颜色设置成红色，指定name参数为notInUseNameList，颜色设置成绿色。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 完成功能一：当地图加载完成时，设置停车位的颜色 */function loadSpace() &#123; var inUseNameList = new Array(); //全部的占用车位对应的地图车位图标的name属性数组 var notInUseNameList = new Array(); //全部的空闲车位对应的地图车位图标的name属性数组 var pathname = window.location.pathname; var parkinglot_id = pathname.charAt(pathname.length-1); console.log(pathname); $.ajax(&#123; //使用ajax请求数据 method: \"POST\", url: \"/parkinglot/\"+parkinglot_id+\"/space\", &#125;) .done(function( spaceList ) &#123; // console.log(spaceList); //打印全部车位信息 $.each(spaceList,function(i,space)&#123; var spaceName = \"车位\"+space.id; if(space.inUse==1)&#123; //表示车位被使用了 inUseNameList.push(spaceName); &#125;else &#123; notInUseNameList.push(spaceName); &#125; &#125;); map.changeModelColor(&#123; //占用车位设置成绿色 name: inUseNameList, color: '#FF0000'&#125; ); map.changeModelColor(&#123; //空闲车位设置成绿色 name: notInUseNameList, color: '#00FF00'&#125; ); &#125;);&#125;","tags":[{"name":"项目","slug":"项目","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://hfq123.github.io/tags/JavaWeb/"}]},{"title":"《Head-First-设计模式》读书笔记charpter2","date":"2020-04-06T14:26:09.000Z","path":"2020/04/06/《Head-First-设计模式》读书笔记charpter2/","text":"本篇博客是《Head First 设计模式》第二章的读书笔记。 分享主题是设计模式中的 「观察者模式(Observer Pattern)」。 1、应用场景—气象监测应用书中给出的例子是：公司要建立一个气象监测应用，如下图，WeatherData对象会从气象检测站获取实时更新的气象数据（湿度、温度、气压），WeatherData对象要做的就是将这些数据及时“分发”到多个布告板，使得每个布告板能使用最新的气象数据以更新它的显示情况。除此之外，附加的需求是系统必须可扩展，能够让用户随心所欲地添加或删除布告板，也就是说，目前系统有“目前状况”、“气象统计”、“天气预报”三个布告板，以后可能会删除某个或者新增别的布告板，言外之意就是说，WeatherData对象要随时准备好停止向现有的布告板分发最新数据以及随时准备好向新的布告板分发最新数据。 image-20200406223021520 2 实现思路2.1 错误示范我们先来看一个很容易想到的思路，然而这被书中称之为“错误示范”（这也是我学习观察者模式之前的思路）。首先我们先约定：一旦气象站测量的气象数据更新，WeatherData类的measurementsChanged()方法就会被调用，在本文，我们不用关心它是怎么做的，只要知道在此方法下，我们要做的就是将这些数据及时“分发”到多个布告板类。 接下来我们就一起来看看这个简单自然但是错误的示例吧，如下图，在WeatherData类的中measurementsChanged()方法里，做的事情很简单，就是获得最新的气象数据，然后以此作为参数各个布告板类的更新方法。 image-20200406223736428 看似完全能实现我们的需求：当气象站检测到新的数据，measurementsChanged()被调用：获得最新的气象数据，然后分别调用各个不同的布告板的update()方法（在这个方法里，布告板会根据自己的需求使用最新数据来改变显示板，我们无需关注update()方法里究竟做了什么，只要知道它需要获得WeatherData类的最新气象数据，供它们更新自己的数据以改变显示屏）。 这样实现究竟有哪些错误呢？ 各个布告板类之间是独立的，没有一个共同的接口，是典型的“针对实现而非针对接口编程”的错误。 每当添加或删除新的布告板，我们都不得不修改方法体内的代码。比如说设计了一个新的testDisplay布告板，我们就要加上一行testDisplay.update(temp,humdity,pressure)，当testDisplay不再需要获取最新的气象状态，就要删除这行代码。 也正是因为每当添加或删除新的布告板，我们都不得不修改方法体内的代码，所以我们无法在运行时动态地增加或者删除布告板。 2.2 观察者模式引入观察者模式就能解决上述实现带来的问题。 先简单介绍一下什么是观察者模式，在观察者模式中，有两个主角，分别是主题(Subject)和观察者(Observer)，书上用了“出版者”和“订阅者”来类比观察者模式中的主题和观察者。出版者一旦出版新的报纸，他就要负责将新报纸分发到各个订阅者手中，而那些没有订阅报纸的人就不会收到，就和这里的例子一样，WeatherData类一旦获得新的气象数据，就要负责分发到各个布告板类中。观察者模式的概念是：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 借助下图，能够让我们清楚地看到观察者模式的“一对多依赖”。 image-20200406230651346 观察者模式为主题和观察者都创建了各自的接口。在主题接口中，定义了注册观察者(registerObserver)方法、撤销观察者(removeObserver)方法、更新所有观察者状态方法（notifyObservers,一旦主题状态改变会触发）；在观察者接口中，定义了更新观察者状态的方法(update)。 image-20200407002547510 我们再把目光转移到应用场景，前面我们已经分析了思路1实现带来的问题，接下来就要好好考虑怎么解决： 首先，我们可以考虑需要为所有布告板类创建一个观察者接口，因为在WeatherData类中，WeatherData不关心布告板是叫currentConditionDisplay还是叫statisticsDisplay，只关心它是否需要在气象数据更新时获得自己的最新气象数据，如果它实现了观察者接口并且注册了主题（相当于订报人完成了订阅动作），那么当WeatherData类的数据更新时，它就是分发数据的目标之一。 然后，我们可以在WeatherData类中维护一个所有观察者组成的列表，这样做能让WeatherData类轻松地获取所有观察者（布告板）。有了观察者列表之后，每当WeatherData类的数据更新，就遍历列表内的所有布告板，调用它们的update()方法即可，WeatherData类不用再关注有几个观察者布告板，它们叫什么名字。当需要添加或删除新的布告板的时候，只需要对列表做增删操作，而不用像思路1中那样改动measurementsChanged()方法体内的代码，同时，这也解决了不能运行时动态地增删布告板的问题，因为运行时可以动态的修改列表的元素（比如说系统运行了十分钟后将currentConditionDisplay公告板从观察者列表中移除）。 想到这些，引入观察者模式之后的模型就呼之欲出了。引入观察者模式之后，本气象站应用的的类图就如下图所示，WeatherData和各布告板分别实现主题接口和观察者接口。 image-20200407002514351 接下来我们从代码的层面上来考虑一下主题的方法是如何实现的。 registerObserver(Observer o)：将观察者对象o加入到WeatherData维护的观察者列表。 removeObserver(Observer o)：将观察者对象o从WeatherData维护的观察者列表中删除。 notifyObservers():遍历WeatherData维护的观察者列表，在循环体内调用每个观察者对象的update()方法。 对比思路1和思路2，可以发现，通过引入观察者模式，我们不仅能方便地实现布告板的增删：当有了新的布告板对象o要“监听”WeatherData的最新数据，就调用registerObserver(o)，当它不再需要获取最新气象数据，就调用removeObserver(o)，还能在运行时动态地增删布告板：，比如说为布告板对象o设置一个“监听”时间10分钟，在10分钟内，它需要监听主题的状态变化，10分钟以后，它就不需要再监听，那么就可以通过在到达10分钟的时候调用removeObserver(o)将其从观察者列表移除即可。 3、总结与思考从观察者模式的两个主角来看，主题拥有自己的一些状态(参考例子中WeatherData对象的天气数据)，而多个观察者想要获知这些状态来改变自身的状态，从而构成了一对多依赖。主题向全体观察者通知，观察者可以随时决定取消监听主题。 如果我们仔细体会本例中一下思路1到思路2的转变，会发现实现了一个松耦合的过程，在思路1中，主题需要关注观察者是谁，而引入观察者模式后，主题不需要知道观察者的具体类是谁，只知道观察者实现了某个接口，有新的观察者出现时，主题的代码不需要修改，二者并非紧耦合。改变主题或观察者其中一方，不会影响另外一方。 最后，本文以一条设计原则结尾。为了交互对象之间的松耦合设计而努力。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"20200406 算法题2则","date":"2020-04-06T14:21:31.000Z","path":"2020/04/06/20200406算法题2则/","text":"今天在牛客网刷了两道剑指offer关于二叉树的题，都比较简单，都可用分治法的思路解决。 题1：二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 我的解答12345678910public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); int max=leftDepth&gt;rightDepth?leftDepth:rightDepth; return max+1; &#125;&#125; 解析：略 题2：二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 &#x2F; \\ 6 10 &#x2F; \\ &#x2F; \\ 5 7 9 11 镜像二叉树 8 &#x2F; \\ 10 6 &#x2F; \\ &#x2F; \\ 11 9 7 5 我的解答：1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 解析：这里需要注意必须交换左子树根节点和右子树根节点的引用而非交换取值。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://hfq123.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"《Head First 设计模式》读书笔记charpter1","date":"2020-04-05T07:10:41.000Z","path":"2020/04/05/《Head-First-设计模式》读书笔记charpter1/","text":"本篇博客是《Head First 设计模式》第一章的读书笔记。 分享主题是设计模式中的 「策略模式(Strategy Pattern)」。 1、应用场景—一群鸭子引发的故事。书中给了这样一个例子作为应用场景引入：某公司有一套模拟鸭子游戏，游戏中会出现各种各样的鸭子，这些鸭子有一些动作：呱呱叫、戏水。按照面向对象的思想，系统设计为鸭子这一对象设计了一个名为Duck的超类，在这个类中，为实现动作呱呱叫、戏水分别设置了quack()、swim()方法，而各种不同种类的鸭子通过继承这一超类获得这些描述鸭子动作的方法。 接下来问题来了，系统引入了一个新的需求：让鸭子飞起来。开发人员需要为鸭子类加入描述飞行动作的方法，书中也是以实现此需求展开来引入策略模式的。 2、解决思路—继承还是接口 ？2.1 通过继承实现首先,我们很自然地想到，可以在超类Duck中加入一个fly()方法（就像quack()、swim()方法一样），子类通过继承获取描述鸭子飞的方法。 分析： 因为所有子类都会继承超类Duck的方法，即使是一些不能飞的鸭子如橡胶鸭也会继承fly()方法，这样做我们不得不在子类橡胶鸭中重写fly()方法以覆盖继承的方法，比如说，将其子类中不会飞的鸭子的fly()方法体修改成什么都不做。同理，如果有不会叫的鸭子，又需要在该子类中重写quack()方法。 评价：这种思路是最容易想到的,主要利用了面向对象的继承、多态（体现在重写方法）特性。在代码重用上有一定效果，因为子类可以重用父类的fly()方法，但是也存在了一些缺点： (ps:这四个缺点是书中的一道多选题，只给出了答案，具体解读为自己的想法，如有不对，欢迎指正)。 代码在多个子类中重复：假设鸭子有多种飞行方式，那么我们无法仅通过继承超类的fly()方法来描述所有鸭子的飞行方式。我们必须为所有与超类中fly()实现的飞行方式不一致的鸭子子类编写fly()的覆盖方法，而具有相同的飞行方式但不同于超类中fly()给出的飞行方式的众多鸭子子类的覆盖方法将会是一样的，导致代码重复。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们需要看完Duck超类的fly()方法和全部的鸭子子类覆盖的fly()方法才能知道鸭子全部的飞行方式。 运行时的行为不容易改变：通过继承实现，每一个特定的Duck对象的飞行方式都是确定的，这是因为在它的 fly()方法是写死的，每个Duck对象的飞行方式已经在其创建的时候确定了，也就是说，鸭子不能中途切换飞行方式。 改变会牵一发而动全身，造成其他鸭子不想要的改变：这是指如果修改了超类的fly()方法，会影响到其子类。 下文可以看到，通过使用策略模式能有效解决这些问题。 2.2 通过接口实现上面的解读以fly()举例，其实其他方法也可能存在类似的问题，比如说如果不同类的鸭子叫法不同，继承的quark()方法也会存在上述问题，有的鸭子这样飞、叫，有的鸭子那样飞、叫，有的鸭子不飞不叫。这时，我们就想到了将fly()、quark()从超类中取出来放进一个接口。如下图，以fly()为例，将其放进一个名为Flyable的接口。 image文件夹 *分析 *：这样一来，如果一个鸭子子类会飞则实现Flyable接口，将其fly()方法写到子类的方法体，如果不会飞则无需实现。 评价：从超类中分离出有些子类不需要的fly()、quack()方法，这样避免了部分子类继承它压根不需要的方法的情况。然而这样做的缺点也很明显，每次编写一个会飞的新的鸭子子类，都必须在子类中单独实现fly()方法（即使有和它飞行方式一样的其他子类），导致代码根本无法重用，所以这种方法非常不可取。 2.3 策略模式如何弥补思路1、2的缺陷，这就需要引入策略模式这一设计模式，讲策略模式之前，先引入2条设计原则。 设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 在本案例中，我们假设容易变化的方法是fly()和quack()，而每个鸭子的游泳方式是一样的，即swim()方法是不需要变化的。所以设法将fly()和quack()方法从超类中抽取出来建立一组新的结构来代表每个行为，而swim()方法继续保留在Duck超类中。 设计原则2：针对接口编程，而不是针对实现编程。 我们可以利用接口代表每个行为，比如说，引入接口FlyBehavior与QuackBehavior分别代表了飞行、呱呱叫的行为，通过实现FlyBehavior接口的fly()方法，建立各种各样飞行的行为类，来描述不同飞行方式。与思路2通过接口实现的区别在于，我们不再是直接在Duck或者是它的子类中实现不同的fly()方法，而是再另外引入一个实现了FlyBehavior接口的行为类来实现fly()方法。本系统中，每个飞行的行为类都实现了FlyBehavior接口，而在Duck类中，我们定义一个FlyBehavior接口型的成员变量，来保存其对应的行为类的指针，以调用其飞行方法。 image-20200406005221237 这样做就是策略模式的思路。使用策略模式后，本系统的全局类图如下图展示， 不变的方法swim()仍然在Duck超类中实现，而经常改变的fly()、quack()方法被抽离成为接口，再用具体的行为类去实现这些接口，在Duck超类中，保存对应的行为类一个对象的指针以确定该类鸭子的对应的fly、quack行为。 image-20200406003932396 为什么说引入了策略模式会解决上述继承的四个问题呢？ 代码在多个子类中重复：如果使用继承，如果鸭子的飞行方式与超类中给定的的不一致，即使是有同样飞行方式的鸭子子类，也不能重用代码，因为它们都要在各自的类里重写fly()方法。而引入策略模式后，只需要为有同样飞行方式的鸭子子类编写一个实现了FlyBehavior的行为类。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们只需要关注实现了FlyBehavior接口的所有类的fly()方法就能知道鸭子的全部行为。 运行时的行为不容易改变：通过改变Duck或其子类对象的行为类的指针，就可以实现运行时切换飞行方式，也就是说，在Duck类中创建一个setFlyBehavior()方法，就可以随时改变鸭子的行为。 改变会牵一发而动全身，造成其他鸭子不想要的改变：如果某种鸭子的飞行方式有所改变，只需要改变其行为类的引用，不影响其他鸭子子类。 3、总结与思考 image-20200406014158325 是时候给出策略模式的概念了（像本文一样，书中在本章节的最后才给出其概念，也就是讲完了所有细节再告诉你你已经不知不觉地学会了策略模式，我个人觉得这种学习方法比较适合人认识新事物的规律，否则，如果开头就先抛出这个晦涩的概念就能把人吓跑了！）： 策略（Strategy）模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 本项目中，我们可以把鸭子飞行的方式看作是策略，描述不同鸭子飞行方式的代码就构成了策略的算法族。之所以说策略模式让使“算法的变化独立于使用算法的客户”，是因为使用策略模式可以方便地更改客户正在使用的策略（通过更改Context类中对策略的引用）。如果认为使用思路1的继承方法，不厌其烦地在子类中编写fly()的覆盖方法、多写上几行重复代码是可以接受的话，那么，能够随时方便地为类替换策略这个优点就是你无法拒绝策略模式的理由。 这里也就引出了组合和继承(有一个VS是一个)的关系：使用策略模式之后 ，在Duck的子类中通过FlyBehavior、QuickBehavior接口间接地组合了飞行、呱呱叫的行为类，这是“有一个”的关系，理解成Duck的某个子类“有一个“飞行策略。而如果使用继承，则是”是一个“的关系，Duck的子类继承了父类的fly()方法或者重写后获得了自己的fly()方法，不能做到在运行时候动态地改变行为。在使用策略模式后，策略是以”行为类“的方式存在的，而如果使用继承，策略是以方法的形式写死在类里。使用策略模式后，当类的策略在运行时需要发生改变，只需要改变”有一个“的状态，由有一个策略A变成一个策略B，只需要修改其接口的引用（就像修改任何一个普通成员变量一样）。而如果使用继承，想要修改某个鸭子的飞行方式，需要通过修改其fly()方法的代码，当然也就做不到动态地完成改变行为了。综上对组合和继承的讲述，引出了一条新的设计原则： 设计原则3：多用组合，少用继承。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"我的第一篇博客","date":"2020-04-04T13:03:27.000Z","path":"2020/04/04/我的第一篇博客/","text":"引言我正在尝试使用Hexo搭建博客,其实早就有搭建博客的想法 ,然而一直没有去实现,今天刚做完一个SpringBoot项目。闲着无事心血来潮就开始了,完工后才发现原来搭建一个自己的博客这么简单且高效，有点相见恨晚的感觉。这第一篇博客就来简单记录一下我本次搭建博客的路线，以作纪念。以后我会更多地在此分享自己的学习内容，记录开发遇到的问题。 搭建环境本次博客搭建使用到的工具有 Hexo + Github。 Hexo是一个博客框架，让我们从渲染前端页面、部署JavaWeb开发环境中解脱出来，把更多的精力放在写博客这件事情本身上，如其官网介绍： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo的灵活性体现在其大部分前端显示内容都是通过参数来配置的，包括整个博客的主题、模板都可通过配置完成（下文会讲搭建好博客后如何更换主题）。 1586022290377 Github大家都比较熟悉，这里主要用到了它的Github Pages的功能来提供远端访问的支持，不使用Github，只使用Hexo工具也能搭建博客，不过只能在本地端口访问。 搭建步骤1 、安装Hexo 2、关联Github的库 3、更换自己喜欢的博客主题 本打算重做以详细记录一下这几个步骤，但是想想这次部署之后以后也没有必要重新部署了，再加上网上已经有很很详细的教程了，重新做一次对自己提升不大，就不浪费时间，所以直接贴教程：手把手教你用Hexo+Github 搭建属于自己的博客 遇到问题特别要注意在修改配置文件_config.xml中的配置项时的格式，正确格式形如：”属性: 空格 值”，如”title: 然后就的博客”。如果冒号和值之前没有空格隔开执行hexo命令时会报错。 以上就是本篇博客的全部内容了，没什么干货，差不多是简单的流水账，仅是为了纪念第一篇博客，以后争取只写高质量的博客！！！","tags":[{"name":"工具","slug":"工具","permalink":"http://hfq123.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","date":"2020-04-04T12:24:26.585Z","path":"2020/04/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]