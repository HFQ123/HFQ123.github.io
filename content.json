[{"title":"数据结构与算法—二叉堆学习笔记","date":"2020-05-22T04:36:36.000Z","path":"2020/05/22/数据结构与算法—二叉堆学习笔记/","text":"本篇博客是我学习数据结构与算法的笔记，分享主题是「二叉堆」。 引入二叉堆是什么？以下给出一些二叉堆的定义： 堆（Heap）是一种树状的数据结构，它有一个重要性质：任意节点的值总是大于等于或小于等于子节点的值。 如果任意节点的值总是大于等于子节点的值，称为最大堆。 如果任意节点的值总是小于等于子节点的值，称为最小堆。 而二叉堆的逻辑结构就是一颗完全二叉树，由于完全二叉树的一些性质，代码实现时可以用数组存储，下文会详细介绍。 为什么要引入二叉堆这个数据结构？ 想象这样一个场景：我们要设计一种数据结构，用来存放未知数量的整数，我们可以随时向其添加任意整数，在使用时,我们特别关注它的最大值，而不关心其他值, 除了添加元素操作之外，还有两个操作分别是：获取当前这个数据结构的最大值、删除最大值。 这个数据结构可以采用线性表、BBST（如AVL、RBT）实现，它们的时间复杂度分析如下表： 数据结构 获取最大值时间复杂度 删除最大值时间复杂度 添加元素时间复杂度 有序的动态数组 O（1） O(1) O(n) 红黑树 O(logN) O(logN) O(logN) 针对此需求，有没有更优的数据结构？ 我们发现，无论是维护元素顺序的动态数组还是红黑树都考虑了整个数据结构的顺序。有序数组不用多说，至于红黑树，构建时也间接维护了每个元素之间大小关系，其中序遍历结果是有序的。 而在需求中，我们重点关注对象的是这个数据结构的最大值，不在乎其他元素的大小顺序，维护整个数据结构的顺序显得有些“杀鸡用牛刀”的感觉。 实际上，这一需求就能用最大堆来实现，使获取最大值、添加元素、删除最大值这三个操作都有不错的效率： 获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn)。 代码实现此部分以最大堆为例，给出代码实现。 在写代码前，先研究一下二叉堆的特性，前面已经提到了二叉堆的逻辑结构就是一棵完全二叉树，完全二叉树的结构可以存储在数组里，根据索引的关系就能计算出每个结点的父结点、子结点： 二叉堆的特性 在二叉堆的接口设计中：重点关注这三个操作：获取最大值、添加元素、删除最大值。 获取最大值这一操作很简单，根据最大堆的定义，任意节点的值总是大于等于子节点的值，所以根节点的值就是最大值，也就是说，数组的首元素就是最大值。 添加元素时，直接添加到最大堆的最后，但是这可能会破坏最大堆的结构，所以需要上浮(sift up)操作：如果插入的结点元素值比父节点元素值大，就要交换两者位置，循环直到插入结点的元素值不大于父节点的值或者插入结点已经上浮成为根节点（也就是说此节点没有父节点了）退出循环。 12345678910111213141516171819202122232425262728293031/** * 添加元素到最大堆 * @param element 要插入的元素值 */void add (E element)&#123; elements[size]=element; //插入到数组的最后 siftUp(size); //对刚才添加的元素执行“上浮”操作 size++;&#125;/** * 上浮操作，调整插入元素的位置 * @param index 需要上浮操作的数组元素的索引 */void siftUp(int index)&#123; int pIndex = 0; //父节点的索引 E value = elements[index],pValue; //自己的元素值和父节点的元素值 while (index&gt;0)&#123; //只要还有父节点，就循环 pIndex = (index-1)/2; //父节点的索引 pValue = elements[pIndex]; //父节点的元素值 if(cmp(value,pValue)&lt;=0)&#123; //cmp函数用于比较两个元素的大小 break; &#125; //如果大于父结点，就交换。 //E tmp = elements[index]; ---标注1 elements[index] = elements[pIndex]; //elements[pIndex] = tmp; ---标注2 index = pIndex; &#125; elements[index] = value; //----标注3&#125; 在上述代码，处理上浮操作的时候有一个小细节：在循环中，如果插入结点元素值比父节点要大，就要交换当前结点和父节点的位置，按理说交换操作应该是三步走：临时变量保存本结点的元素值（代码中标注1），本结点元素值=父节点元素值，父节点元素值=临时值（代码中标注2），然而这里由于每次比较的都是父节点和待插入结点的值，所以可以将新添加节点备份，确定最终位置才摆放上去（代码中标注3）。 删除最大值时，并不是直接删除根节点，而是先用最后一个结点的值覆盖根节点的值，然后再删除最后一个结点。 最后一个结点的值覆盖根节点的值这可能又会破坏最大堆的结构，所以需要下沉(sift down)操作。 12345678910111213141516171819202122232425262728293031323334353637/** * 移除最大值（也就是数组的首个元素） */void remove()&#123; if(size==0) &#123; return; &#125; elements[0] = elements[size-1]; //用最后一个元素值覆盖首结点的元素值 elements[size-1] = null; //真正移除的是最后一个元素 size--; siftDown(0);&#125;/** * 下沉操作，删除最大值后调用 * @param index */void siftDown(int index)&#123; int leftChild; int bigChild; //记录左右孩子中较大的那个的索引 E value = elements[index]; while(index&lt;size/2)&#123; //只要还有子结点 也就是左孩子索引2i+1&lt;size，也就是i&lt;(size-1)/2 leftChild = 2*index+1;//左孩子索引 bigChild = leftChild; //大孩子默认为左孩子（因为右孩子可能不存在） if(leftChild+1&lt;size &amp;&amp; cmp(elements[leftChild+1],elements[leftChild])&gt;0)&#123; //第一个条件表示右孩子存在，第二个条件表示右孩子比左孩子大 bigChild = leftChild +1; &#125; if(cmp(elements[bigChild],value)&lt;=0)&#123; break; &#125; //如果大孩子的值比自己大，才进行后续操作 elements[index] = elements[bigChild]; index = bigChild; &#125; //退出循环时，要么就是该节点已经下沉到最底了(没有子结点了)，要么就是该节点已经到了大于等于所有子结点的位置 elements[index] = value;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之树学习小结","date":"2020-05-20T05:33:29.000Z","path":"2020/05/20/数据结构与算法—树学习笔记/","text":"此系列是我数据结构的学习笔记，观看视频课程，网上有很全面的笔记了，节约时间，细节没有再展开。 本篇博客分享主题：「树」，简单总结一下近期学的二叉搜索树、平衡二叉搜索树、红黑树，重点介绍二叉搜索树。 基本认识二叉搜索树(Binary Search Tree),又叫做二叉查找树、二叉排序树。 任意一个节点的值都大于其左子树所有节点的值。 任意一个节点的值都小于其右子树所有节点的值。 它的左右子树也是一颗二叉搜索树。 一棵二叉搜索树（BST） 为什么要引入二叉搜索树，需求是什么？ 在乱序数组中插入元素，搜索操作平均时间复杂度O(n)，插入操作复杂度O(1) 排好序的数组，二分搜索，最坏时间复杂度O(logn),但插入、删除操作平均复杂度是O(n) 使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)））（更准确得说是O(h),h为树高） 而后面学到的平衡二叉搜索树（AVL）、红黑树（Red Black tree）都是特殊的二叉搜索树，它们主要是为了解决BST太不平衡时效率退化的问题，只不过为了维持二叉树的(相对)平衡，它们有各自附加的要求。总的来说，添加、删除节点这两个基本操作都是一样的，只不过对于AVL和RBT来说，在添加或删除元素之后，可能会破坏树原来的性质，所以需要一些额外的操作（对于AVL来说是旋转，对于RBT来说是着色和旋转）来维持树的性质，以达到更好的性能。 退化成链表的二叉搜索树时间复杂度就变成了O(n)，那么AVL和RBT是怎么优化的呢？AVL树的节点除了维护节点的左右父节点的指针之外，还会维护此节点的高度，AVL树规定每个节点的平衡因子只可能是1，0，-1，否则，称之为失衡。添加和删除节点后可能会导致失衡，我们就做一些额外的操作让它重复恢复平衡就行,具体又分为LL、RR和LR、RL的旋转情况，本文不再展开。 上面那棵BST等价的AVL树 而红黑树的节点除了维护节点的左右父节点的指针之外，还会维护此节点的颜色,红黑树的性质比起AVL更加复杂： 1、节点是RED或者BLACK2、根节点是BLACK3、叶子节点（外部节点，空节点）都是BLACK4、RED节点的子节点都是BLACK RED节点的parent都是BLACK 从根节点到叶子节点的所有路径上不能有2个连续的RED节点 5、从任意节点到叶子节点的所有路径都包含相同数目的BLACK节点。 上面那棵BST等价的红黑树 BST的插入删除操作插入操作比较简单，只需要不断将要插入结点的值和当前工作节点比较，如果待插入节点的值比当前节点的值大，就往左走，否则就往右走，直到工作节点为空，就确定了插入位置。 查找的操作也类似。 删除需要考虑三种情况：度为0、1、2。 度为2： 令后继结点的元素值覆盖删除结点，然后删除后继节点，后继节点的度必为0/1，所以就转化成了下面的两种情况 (ps.取前驱节点替代也可以）度为1： 使删除结点的父节点指向删除结点的子结点，注意删除的是根节点的特殊情况度为0： 直接删除，注意删除的是根节点的特殊情况 常用方法遍历(适用所有二叉树) 前序遍历(Preorder)，访问顺序： 根节点 -&gt; 前序遍历左子树 -&gt; 前序遍历右子树递归实现。 中序遍历(Inorder)，访问顺序：中序遍历左子树 -&gt; 根节点 -&gt; 中序遍历右子树 中序遍历的结果是有序的，因为根据BST的定义，左&lt;中&lt;右。 后序遍历(Postorder)，访问顺序：后序遍历左子树 -&gt; 后序遍历右子树 -&gt; 根节点 层序遍历(Level Order)，访问顺序：从上到下，从左到右依次访问节点。 对于前中后序遍历来说，既可以用递归实现，还可以非递归实现(栈)。 参考我的其他博客： 前序遍历的非递归实现 后序遍历的非递归实现 一棵二叉树的遍历结果 求前驱节点和后续节点一个节点的前驱节点和后续节点分别指的是树的中序遍历结果中这个节点的前一个结点和后一个结点，计算前驱节点的思路如下： 如果此节点有左子树，必定有前驱节点，前驱节点=node.left.right…right 如果此节点没有左子树，但是有根节点，则可能有前驱节点，前驱节点=node.parent.parent…直到当前结点是父节点的左孩子。 否则，返回null 后续节点同理。 设计思想这一部分，简单谈一谈设计BST类代码时候的设计模式，可供参考，把代码写的优雅一点。 策略模式从二叉搜索树的定义来看，涉及到比较操作，所以二叉搜索树存储的元素必须具备可比较性。 一方面，我们可以规定节点元素必须是可比较的，也就是使节点元素的类实现Comparable接口，里面实现compareTo方法，又可以在BST类中加入一个外部比较器，可以让调用者自行决定使用什么比较方法来比较元素大小。详情不再展开，参考比较器comparable与comparator的使用 模板方法模式BST类是父类，AVL和RBT是子类。我们前面说了，在BST中的插入删除方法，只需要做基本操作，而AVL和RBT的插入删除操作之后，还需要做一些额外操作来维持树的性质，所以在设计BST这一个父类的时候，将add()和remove()方法（分别用于插入和删除结点）作为模板方法，在两个方法的最后调用afterAdd()和afterRemove()作为“钩子”，在BST类中，afterAdd()和afterRemove()这两个方法里什么都不做，而AVL和RBT子类重写它们，里面写插入/删除节点后维持树性质的代码。 这样一来，AVL和RBT这两个子类，就可以重用基本操作部分的代码。 性能比较参考动态查找树比较。 BST效率总结： 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)，和高度相关O(h)。 插入删除操作算法简单，时间复杂度与查找差不多。 AVL效率总结： 查找的时间复杂度维持在O(logN)，不会出现最差情况 AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。 AVL树在执行删除时代价稍大，可能造成O(logN)次旋转，执行每个删除操作的时间复杂度需要O(2logN)。 红黑树效率总结： 查找效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些（因为树高可能比AVL高），但也远远好于BST。 插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。 AVL树和红黑树性能对比以及选择图解 个人总结BST和AVL树和红黑树的基础，在理想情况下，它的查找、插入、删除的时间复杂度是O(logN)，但是在一些情况下，其时间复杂度会退化，极端情况下退化成链表，总的来说，BST查找、插入、删除的时间复杂度是和其整体高度正相关的。所以，AVL为了不让BST由于高度失衡而导致时间复杂度退化，就规定了平衡因子的概念，它的查找操作完全和BST一样，插入删除操作之后如果导致树失衡会做旋转操作使得恢复平衡，这样就严格控制了其平衡性（也就是控制了树的高度），所以查找、插入、删除三个操作的时间复杂度都能稳定维持在O(logN）。这里我们还有必要了解一些AVL插入和删除节点的细节:在AVL树插入节点只会造成1次旋转（单旋或双旋），而在AVL树删除节点可能会造成O(logN)次旋转（删除后，父节点失衡调整后导致其祖父节点直到根节点都失衡，都需要旋转）。 而红黑树相较于AVL树来说，对于树的平衡要求没有AVL那么高（所以说，拥有同样多节点的树，红黑树可能比AVL树的树高更大），虽然在红黑树节点定义中，并没有看到关于高度的定义，只有颜色的定义，但是实际上只要满足了其五条要求（在插入删除节点后可能会破坏红黑树要求，所以要进行染色和旋转操作），最后构建出来的红黑树的高度就不会像BST那样有高度严重失衡的坏情况，事实上，红黑树的最长路径长度不超过最短路径长度的2倍，所以说其查找代价还是能基本维持在O(logN)，有时查找性能或许比AVL略逊色一点（因为其高度可能比AVL大），但是其RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。 推荐阅读以下博文的笔记很详细，给出链接供查阅。 小码哥《恋上数据结构与算法》笔记（八）：二叉搜索树 小码哥《恋上数据结构与算法》笔记（九）：平衡二叉搜索树（AVL） 小码哥《恋上数据结构与算法》笔记（十）：B树 小码哥《恋上数据结构与算法》笔记（十一）：红黑树 为什么HashMap使用红黑树而不使用AVL树 另外，推荐一个可以模拟各种树构建、删除过程的网页： 构建各种树的可视化网页工具","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"synchronized和ReentrantLock的对比","date":"2020-05-19T09:35:08.000Z","path":"2020/05/19/synchronized和ReentrantLock的对比/","text":"","tags":[]},{"title":"Mybatis错误排查-多表联合查询时两张表字段相同造成的记录缺失的问题","date":"2020-05-13T14:37:43.000Z","path":"2020/05/13/Mybatis错误排查-多表联合查询时两张表字段相同造成的记录缺失的问题/","text":"问题背景这是在学习Mybatis框架做学习demo时遇到的问题，特此记录。 现有用户表和账户表，规定：一个用户可以有多个账户，一个账户对应确定的一个用户，即对于账户记录来说，是一对一的关系。 两张表的记录如下： image-20200513224038566 现需要使用Mybatis查询出账户表的所有记录，并且需要查询此账户记录对应的用户（利用外键uid）。 sql语句和查询结果如下： 123456789# 一个简单的内连接查询select a.id,a.uid,a.money,u.* from account a,user u where a.uid =u.id;# 此条sql语句执行的结果：1 41 1000 41 张三 2000-02-27 17:47:08 男 杭州市西湖区3 41 2000 41 张三 2000-02-27 17:47:08 男 杭州市西湖区2 45 1000 45 小胡 1999-03-04 12:04:06 男 杭州市杭州电子科技大学 账户类对应的Mapper的xml部分配置如下： 1234567891011121314151617181920 &lt;resultMap id=\"accountMap\" type=\"Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 在Account类中，组合了一个User对象 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;!-- 查询所有账户记录（含用户信息） --&gt; &lt;select id=\"findAll\" resultMap=\"accountMap\" &gt; select a.id,a.uid,a.money,u.* from account a,user u where a.uid =u.id; &lt;/select&gt; 按照此配置测试，发现结果有两个问题： 1、只查询出两条记录信息，而实际上账户数据表中有三条账户记录。 2、账户id结果有误，两条账户记录的正确id应该分别是id=1和id=2，而不是下图中的41和45。 测试结果截图（有两处错误） 排查解决排查思路：其实根据上面执行结果出现的第二个问题就大致定位到了问题所在：账户id打印的是用户id，原因很有可能是因为这两张表的字段id重复，导致无法区分。 解决思路：为其中的一个id字段起别名，以便区分开来。 1234567891011121314151617&lt;resultMap id=\"accountMap\" type=\"Account\"&gt; ！注意此处的column修改了 &lt;id property=\"id\" column=\"accountId\"&gt;&lt;/id&gt; ....此部分和修改前一样，故省略 &lt;association property=\"user\" column=\"uid\" javaType=\"User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; ....此部分和修改前一样，故省略 &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAll\" resultMap=\"accountMap\" &gt; ！注意此处为acocount表的id 起了别名accountId。 select u.*,a.id as accountId,a.uid,a.money from account a,user u where a.uid =u.id;&lt;/select&gt; 果然，修改后，解决了，得到了正确查询结果。 修改后的正确测试结果截图 总结在使用mybatis进行多表联合查询时，如果两张表中的字段名称形同，会出现无法正常映射的问题。 问题解决办法：在SQL查询语句中时，给重复的字段 起别名，然后在column属性使用别名进行映射。","tags":[{"name":"错误排查","slug":"错误排查","permalink":"http://hfq123.github.io/tags/%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"}]},{"title":"Java基础查漏补缺之泛型","date":"2020-05-12T16:54:42.000Z","path":"2020/05/13/Java基础查漏补缺之泛型/","text":"便于在编译阶段发现发现类型不匹配的问题。 泛型只在编译阶段有效，在编译之后程序会采取去泛型化的措施。 泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 泛型类。 https://blog.csdn.net/s10461/article/details/53941091","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://hfq123.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java基础查漏补缺之反射","date":"2020-05-12T08:17:45.000Z","path":"2020/05/12/Java基础查漏补缺之反射/","text":"反射的原理反射是什么? JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 为什么要学习反射？ “反射是框架设计的灵魂。” 大三上初学Spring框架时，就听过这句话，看了介绍反射的知识点云里雾里，完全是硬着头皮跟着做，现在学了JVM类加载过程之后，这块知识还是比较好理解的。 首先回顾一下类加载过程：加载-&gt;连接-&gt;初始化 其中加载这一步骤要做三件事： 通过类的全限定名获取此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的访问入口。 我们需要重点关注，生成的Class对象描述了这个对象的所有信息，比如都有哪些构造方法，都有哪些成员方法，都有哪些字段等，在反射中就要利用到Class对象。 反射的使用使用反射要关注以下2个重点问题。 如何获取类的Class对象?有以下3种获取类的Class对象的方法: 12345678910111213//方法1：调用类的一个实例的getClass方法Dog dog = new Dog();Class&lt;Dog&gt; dogClass = dog.getClass();//方法2：类的字面量Class&lt;Dog&gt; dogClass1 = Dog.class;//方法3：推荐！利用Class类的静态方法forName()，其参数是需要获取的类的全限定类名，需处理ClassNotFoundException异常try &#123; Class&lt;Dog&gt; dogClass2 = (Class&lt;Dog&gt;) Class.forName(\"reflect.Dog\");&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 对这三种获取Class对象的方式的理解：每个对象的对象头里存了该对象所在类的Class对象的引用（这块知识点在JVM中有详细介绍），所以从原理上看，可以直接根据对象获取Class对象，如方法1，实际上getClass()是Object类的方法,所以自然所有对象都会有这个方法了。 获得Class对象之后有什么用？当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取该类中的构造方法、成员变量、方法等信息，类的这一个个组成部分会被映射成一个个对象,比如说利用反射获得类的构造器对象，然后就可以利用这个类的构造器对象构造一个这个类的实例，总的来说,利用反射能做的事情有： 获取构造方法，用此构造方法创建对象 aClass.getConstructor(); newInstance() 获取成员变量 getFiled(“filedName”) getFileds() getDeclaredFileds() 获取成员方法，并执行此成员方法 getMethod() getDeclaredMethod() invoke() 反射的应用 修改私有成员变量的值 执行私有成员方法 反射妙用：通过反射运行配置文件内容 我利用反射+代理模式写了个demo，用来计算任意类的无参方法的执行时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package reflect;import java.lang.reflect.Method;/** * @Created by hfq on 2020/5/12 * @used to: 用于计算任意类的任意无参方法的执行时间 */public class TimeProxy &#123; String className; String methodName; public TimeProxy()&#123; &#125; public TimeProxy(String className, String methodName) &#123; this.className = className; this.methodName = methodName; &#125; public Long exeucte() throws Exception &#123; Class&lt;?&gt; aClass = Class.forName(className); Long start = System.currentTimeMillis(); Method method = aClass.getDeclaredMethod(methodName,null); method.setAccessible(true); method.invoke(aClass.newInstance(),null); return System.currentTimeMillis()-start; &#125; public static void main(String[] args) throws Exception &#123; TimeProxy timeProxy = new TimeProxy(\"reflect.Person\",\"eat\"); System.out.println(\"人吃饭，吃了:\"+timeProxy.exeucte()+\" ms\"); TimeProxy timeProxy2 = new TimeProxy(\"reflect.Brid\",\"fly\"); System.out.println(\"鸟飞行，飞了:\"+timeProxy2.exeucte()+\" ms\");// 测试系统Math类的random()方法，报java.lang.IllegalAccessException// TimeProxy println = new TimeProxy(\"java.lang.Math\", \"random\"); // System.out.println(\"Math执行random方法，执行了\"+println.exeucte()+\" ms\"); &#125;&#125;class Person&#123; private void eat() throws InterruptedException &#123; Thread.sleep(1000); //人吃饭三秒 &#125;&#125;class Brid&#123; private void fly() throws InterruptedException &#123; Thread.sleep(3000); //鸟飞翔三秒 &#125;&#125;/*打印结果如下：人吃饭，吃了:1001 ms鸟飞行，飞了:3001 msProcess finished with exit code 0*/ 更多内容我就不在此展开了，参考如下文章，案例比较全面： 原文链接：https://blog.csdn.net/sinat_38259539/article/details/71799078","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://hfq123.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java基础查漏补缺系列前言","date":"2020-05-12T06:13:44.000Z","path":"2020/05/12/Java基础/","text":"当初大一下初学Java课程的时候，教学重点是基础语法和面向对象的设计思想。而基础的高级部分只涉及到了I/O、极少量的多线程知识、异常处理，而且也是非考试重点，当时的学习程度比较浅显，很多知识如泛型、反射等知识都是后面现用现学，没有系统地学习，导致整个知识面不怎么清晰。以至于到现在框架都学了，然而Java语言本身的了解程度还不够，有点本末倒置的意思，所以推出这个系列文章，记录一些Java基础的进阶部分学习笔记，作为查漏补缺。 分为以下几个部分： 反射 异常 泛型 注解 I/O 正则表达式","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://hfq123.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"java并发编程-等待/通知机制","date":"2020-05-09T09:01:04.000Z","path":"2020/05/09/java并发编程-等待-通知机制/","text":"https://www.cnblogs.com/powercto/p/10848825.html#a%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E8%AF%B4wait-%E8%A6%81%E6%94%BE%E5%9C%A8while%E9%87%8C%E9%9D%A2%EF%BC%9F while的作用 标志的作用： 即使唤醒线程先执行了，也正常。","tags":[{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"cxsj项目-服务端主动推送数据到客户端","date":"2020-05-07T05:20:09.000Z","path":"2020/05/07/cxsj项目-服务端主动推送数据到客户端/","text":"需求分析在智慧停车管理平台(WEB端)项目的公告发布模块中，管理员发布公告后，车主用户可以评论公告（这可以作为用户提问的一种途径），为了让管理员及时看到用户对公告的评论，以便及时回复，需增加一个通知提醒功能，就和大多数WEB应用一样，页面顶部有一个通知图标，如果有通知，就高亮显示起到提醒的作用。 目标实现效果当没有任何通知的时候（在我这个案例中，也就是没有用户回复公告的提醒），显示通知图标。 没有通知的时候页面顶部状态栏 当有通知时，高亮显示未读通知的数目，当用户点击页面顶部“通知”按钮的时候，根据时间降序显示出所有通知，并且重点标注出哪些通知是未读的。 image-20200508134511709 实现思路基本思路接下来介绍一下本案例中是怎么实现通知回复功能的。 当用户进行评论公告操作后，先将用户的评论插入到数据库的评论表中，如果插入成功，生成一条对应的通知记录，在数据库设计时，通知表(notification)包含了如下字段： 字段名 作用 id 通知表的主键 notifier 通知发起者id，外键，关联用户表 receiver 通知接收者id，外键，关联用户表 outerId 公告id，外键，关联公告表，表示notifier在编号为outId的公告下回复了receiver gmt_create 通知创建的时间戳，bigint类型 status 通知的阅读状态（对于接收者而言），0标识未读，1标识已读 结合具体场景对数据表各个字段的解读： 用户A成功回复了管理员发布的公告，则生成一条通知记录，其中，notifier字段存用户A的id，recevier字段存管理员的id，outId存被回复的公告的id，gmt_create保存系统当前的时间戳，以记录通知生成的时间，status初始化为0表示通知接收者还未读。 持久化通知记录到数据库之后，我们就可以获得每个用户的未读通知数目和全部历史通知数据： 12345#查询某用户未读通知的数目select count(1) from notification where receiver = 用户ID and status = 0#查询某用户的全部通知select * from notification where receiver = 用户ID 至此就很明朗了：加载WEB页面时，先查询当前用户的未读通知的数目，如果是0，则显示通知图标，如果大于0，则高亮显示未读通知的数目。这个流程可以通过ajax调用后端查询接口实现，代码就不展开了。 现在问题来了，这样做的缺点是什么？ 1、实时性差，每次需要手动刷新当前页面或者点击别的页面，重新加载后，才会获得当前实时的未读通知数目。 2、效率不高，每进入一个新的页面，都会查询当前的未读通知数目，即使距离上一次查询的一段时间内，未读通知数并没有更新，也会查询。 改进思路针对上述这两个问题，有一些改进思路： ”假装实时“的客户端轮询机制首先，为了解决实时性差的问题，我们可以想到：客户端每隔一小段时间，就使用ajax调用查询接口，获取当前用户未读通知的数目，获取结果后局部刷新到顶部栏通知框内。 这样做一定程度上实现了”实时“通知：比如说，每隔2秒，客户端就发起一次查询当前通知未读数的请求，服务器返回结果，如果不考虑网络等因素的延时，网页顶部的通知状态栏中的数字始终是2s内的未读通知数，对于普通WEB应用来说，这样的实时性是可以接受的。 轮询机制的代码实现（每隔2000ms调用一次查询方法并更新）： 123setInterval(function()&#123; 此处写ajax查询的代码&#125;,2000) 接下来，我们来分析一下这种机制的性能： 轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。 这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。 注:此段描述摘自于此博客。 总的来说，轮询机制似乎确实在一定程度上能解决实时性的问题，但是效率很差。 由于轮询有一定的时间差，所以我在标题上说是”假装实时“。 真正实时的WebSocket概念之所以轮询机制的效率低，是因为，客户端无法得知后台数据什么时候发生了更新，所以每次发送请求时只能”抱着试一试“的态度，请求当前后台某个数据的值，以尽可能获取最近一段时间内的该数据的最新值，概括地说，和普通客户端请求一样，轮询机制是由客户端发起请求。而理想的模型是在服务器端数据有了变化后，可以主动推送给客户端,这种”主动型”服务器是解决这类问题的很好的方案。Web Socket就是这样的方案。 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 注:此段描述摘自于菜鸟教程。 简而言之，WebSocket 拓展了客户端获取后台数据的方式，普通情况下，只能由客户端主动拉取(pull)，而用了WebSocket之后，可以通过服务器主动推送（push），客户端被动获取数据。 讲到这里，终于呼应上本文的标题了。 由于我还没系统学过java的网络编程，之前也没接触过WebSocket，于是采用了号称“让websocket更简单”的解决方案——GoEasy API，结果证明，使用起来确实极其简单。 理解GoEasy的工作原理很简单，浏览器订阅channel，服务端后客户端都可以向channel发布消息，消息被发布 到channel后，所有订阅了该channel的客户端都可以获得channel里的消息。 GoEasy的推送机制 图源自GoEasy的工作原理。 使用这里就简单地介绍一下GoEasy的使用过程吧。 1、注册并登录GoEasy账号后，首先注册一个应用，选免费版即可。 2、后端推送数据到channel 首先，在maven项目的pom.xml中添加如下依赖: 12345678910111213141516 &lt;dependencies&gt; ........... &lt;!-- GoEasy的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.goeasy&lt;/groupId&gt; &lt;artifactId&gt;goeasy-sdk&lt;/artifactId&gt; &lt;version&gt;0.3.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这是gson的依赖，一开始没有加，报错ClassNotFound了 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12GoEasy goEasy = new GoEasy( \"这里填写第一步注册应用完成后获取到的Common key\");goEasy.publish(\"my_channel\", String.valueOf(replyNum)); //replyNum是我项目中生成新通知后，更新后的\"通知未读数目\" 3、前端从channel中获得消息 首先，下载js文件，引入到thymeleaf的html模板中。 编写获取channel中数据的前端代码： 1234567891011121314151617/** * 订阅channel，获取最新的未读通知数目 */function subscribleReplyNum() &#123; var goEasy = new GoEasy(&#123; host:'hangzhou.goeasy.io', //应用所在的区域地址: 【hangzhou.goeasy.io |singapore.goeasy.io】 appkey: 这里依旧填写第一步注册应用完成后获取到的Common key &#125;); goEasy.subscribe(&#123; channel: \"my_channel\", //“my_channel”对应于发布时的channel名 onMessage: function (message) &#123; console.log(\"Channel:\" + message.channel + \" content:\" + message.content); $(\"#not_read_count\").text(message.content); //更新“通知状态栏”的未读通知数目的span的值 &#125; &#125;);&#125; 至此，就可以正常使用了，完成如下效果： image-20200508174335930","tags":[{"name":"项目 JavaWeb","slug":"项目-JavaWeb","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE-JavaWeb/"}]},{"title":"再谈单例模式","date":"2020-05-06T15:20:09.000Z","path":"2020/05/06/再谈单例模式/","text":"之前，学设计模式的时候，接触了单例模式的四种实现方法，那个时候还不怎么理解，糊里糊涂地整理了笔记。 现在学了JVM和并发编程后，对单例模式的实现细节有了更好的掌握。借此机会回顾一下DCL(Double Check Lock，即双重检查锁)实现单例和静态内部类实现单例。 DCL单例模式经典懒汉单例模式的实现123456789101112public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public synchronized static Singleton getInstance()&#123; if(instance==null) return new Singleton(); return instance; &#125;&#125; 在此代码，重点关注synchronized关键字，它修饰了获取单例的静态方法。 之所以在这里要用synchronized，是因为防止多线程情况下，如果多个线程同时执行到了if(instance==null)，判断都是true，将会导致在多个不同的线程创建了多个不同实例，违背了单例模式的目标，所以需要使用synchronized保证这块代码的原子性，也就是在一个线程创建实例的时候避免其他线程的干扰。 一步步改进我们知道，synchronized关键字修饰静态方法，就相当于修饰了所在类.Class对象，所以上述代码等价于如下代码: 1234567891011121314public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; synchronized (Singleton.class)&#123; if(instance==null) return new Singleton(); &#125; return instance; &#125;&#125; 这种方法虽然实现了懒惰实例化，需要用到单例时才会创建，而且也保证了线程安全。 但是性能上存在缺陷： 原因是，在此实现中，每次进入getInstance方法获取单例时，都要进入先synchronized修饰的同步代码块。但实际上只有在首次创建单例（第一次调用getInstance方法）的时候，有线程安全的问题，一旦创建了单例后，多个线程获取单例不会有线程安全的问题，而synchronized加锁是有性能开销的，这样做就相当于把一部分不需要加锁的情况，也加了锁。 根据此思路，我们对这段代码改进，就会得到DCL单例模式的初步实现： 12345678910111213141516public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; if(instance==null)&#123; //根据分析，只有首次创建（也就是当前instance为空）时，需要进入同步代码块 synchronized (Singleton.class)&#123; if(instance==null) return new Singleton(); &#125; &#125; return instance; &#125;&#125; 在此实现中，先后两次对instance进行是否为空的判断，这也是“double check“这个名字的由来。 细心的读者会看到上文我说，这一种是DCL的”初步实现“，看似完美的实现有什么不足呢？ 这就要从字节码的角度分析了。 指令重排。 先调用构造方法再内存指向，先内存指向再调用构造方法都有可能！！。 其他线程执行第一个检查的时候，判断instance==null的条件不成立，直接返回了instance对象，而对比经典的单例模式实现中，synchronized关键字修饰了，只有获得了对象监视器的线程可以访问instance 。 不会影响本线程，但是可能影响其他线程 说了这么多，如何解决呢？ ​ private static volatile Singleton instance; 饿汉：类加载时就会创建单例对象。（静态成员变量会初始化阶段赋值） 懒汉：类加载时不会导致单例对象被创建，而是首次使用该对象才会创建。","tags":[{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"推荐阅读","slug":"推荐阅读","permalink":"http://hfq123.github.io/tags/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/"}]},{"title":"JVM-虚拟机性能监控与故障处理实战","date":"2020-05-04T09:53:58.000Z","path":"2020/05/04/JVM-虚拟机性能监控与故障处理实战/","text":"本文主要介绍如何应用一些虚拟机的性能监控和分析的命令。 jdk命令行工具jps image-20200504175625119 jps可以查看当前jvm运行的进程名和它们对应的虚拟机进程号。查到进程号后方便结合后续的很多其他命令。 jstatjstat用于监视虚拟机各种运行状态信息，显示类装载、内存、垃圾收集、JIT编译等运行数据。 image-20200504175926715 表示分析进程 id 为 8608 的 gc 情况，每隔 1000ms 打印一次记录，不停止。 jinfojinfo用于实时查看和调整虚拟机各项参数。 image-20200504180217340 带参数的jinfo image-20200504180250530 jmap用于生成堆转储快照。 image-20200504180359885 jhat用于分析堆转储快照。使用jhat，用户可以在浏览器上查看分析结果。 image-20200504180455772 进入localhost:7070: image-20200504180509345 jstack用于生成虚拟机当前时刻的线程快照。 主要目的是定位线程出现长时间停顿的原因， 如死锁、死循环、请求外部资源长时间等待….. 持续等待用户输入造成停顿时间过长 jstack定位死锁 可视化工具jconsole可以在cmd窗口打开jconsole图形化工具，然后连接到本地进程或远程进程。 image-20200504181849691 VisualVM强大的运行监视和故障处理程序，可以在cmd窗口输入jvisualvm打开此图形化工具。 image-20200504183707463 转储后分析内存","tags":[{"name":"JVM","slug":"JVM","permalink":"http://hfq123.github.io/tags/JVM/"}]},{"title":"JVM学习笔记-垃圾回收","date":"2020-05-04T08:03:13.000Z","path":"2020/05/04/JVM学习笔记-垃圾回收/","text":"主要参考材料是《深入理解Java虚拟机》第二版。 根据学习内容，制作了思维导图。 image-20200504160356910","tags":[{"name":"JVM,笔记","slug":"JVM-笔记","permalink":"http://hfq123.github.io/tags/JVM-%E7%AC%94%E8%AE%B0/"}]},{"title":"Java并发编程笔记1-基本概念","date":"2020-04-30T16:51:39.000Z","path":"2020/05/01/Java并发编程笔记1-基本概念/","text":"JVM已经学的差不多了，今天开始学习Java并发编程，记录学习笔记。 多线程的基本概念首先还是从基本概念讲起。 进程VS线程进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载到CPU，把数据加载至内存。在指令运行过程中还需要用到用到磁盘、网络等设备，进程就是用来加载指令、管理内存、管理IO的。 当一个程序运行，从磁盘加载这个程序的代码到内存，这时就开启了一个进程。 进程可以视作程序的一个运行实例，大部分程序可以同时运行多个实例进程，有些只能启动一个实例进程。 程序是静态的，而进程是动态的。 线程 一个线程就是一个指令流，将指令流中的一条条指令以一定顺序交给CPU执行。 线程是最小的CPU调度单位。进程作为资源分配的最小单位，在windows中是不活动的，只是作为线程的容器。 对比 独立性：进程之间基本上是互相独立的，而同一个进程内可能有多个线程，它们之间相互协作完成进程。 资源角度：进程拥有共享资源，如内存空间，供其内部的线程共享。 通信方式： 进程通信：同一计算机的进程之前通信称为IPC(Inter-process communication)，不同计算机之间的进程通信，需要通过网络，并且遵守共同的协议，如HTTP。 线程通信：线程通信相对简单，因为它们共享进程内的内存。 线程更轻量，线程上下文切换成本一般比进程上下文切换低。 并发VS并行推荐阅读 单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，一般会将这种 线程轮流使用 CPU 的做法称为并发（concurrent）。多核 cpu下，每个核(core) 都可以调度运行线程，这时候线程可以是并行(parallel)的。 关于并发和并行的概念辨析，这里引用Go语言创始人Rob pike的描述： &lt;%blockqoute%&gt; “Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once” &lt;%endblockqoute%&gt; 并发是一段时间内应对多个任务的能力(某个时间片内执行一个任务的一部分，下一个时间片可能执行其它任务的一部分，多个任务轮流时间片，通过不同任务之间切换，切换后的任务从上次停止的地方继续)，而并行是一个时间点上同时处理多个任务的能力。 并发是一段时间内某个系统或单元的各个组成部分通过相互配合来处理大量的任务，强调结构和调度，并行是某一时刻多个单元同时在做各自的任务， 强调执行。 多线程的应用 异步调用。 无需等待方法调用。 利用CPU多核优势并行 Java线程创建并启动线程创建线程的3种方式。 在Java中，创建线程主要是用到Thread类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @Created by hfq on 2020/5/1 * @used to: 创建线程的3种方式 */@Slf4j(topic = \"c.Test1\")public class Test1 &#123; /** * 创建线程方式1 */ public static void test1()&#123; Thread t1 = new Thread(\"myThread1\")&#123; @Override public void run()&#123; log.debug(\"thread 1 start........\"); &#125; &#125;; t1.start(); &#125; /** * 创建线程方式2 */ public static void test2()&#123; Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; log.debug(\"thread 2 start........\"); &#125; &#125;,\"myThread2\"); //Thread t2 = new Thread(() -&gt; log.debug(\"thread 2 start........\"),\"myThread2\"); t2.start(); &#125; /** * 创建线程方式3 */ public static void test3()&#123; FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; log.debug(\"thread 3 start........\"); return null; &#125; &#125;); Thread t3 = new Thread(integerFutureTask, \"myThread3\"); t3.start(); &#125; public static void main(String[] args) &#123; test1(); test2(); test3(); log.debug(\"main thread start........\"); &#125;&#125; ！！！ 【拓展阅读—Java创建涉及的设计模式】 Thread类涉及到的两种设计模式 线程类的模板方法设计模式 多线程策略模式 查看进程和线程的方法windows：tasklist、taskkill linux: ps、top、kill java: jps、jstack、jconsole Java操作线程的常见方法start&amp;run如果在主函数中直接调用线程的 run方法 是在主线程中执行了 run，没有启动新的线程使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码 sleep 与 yield调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 调节线程优先级setPriority()。Thread.MIN_PRIORITY ：1，Thread.MAX_PRIORITY：10 join方法Thread中，join()方法的作用是调用线程等待该线程完成后，才能继续往下运行。 join()方法还有一个重载方法join(long n) ，等待线程运行结束,最多等待 n毫秒。 interrupt方法打断 sleep，wait，join 的线程 给受阻塞的线程发出一个中断信号，这样受阻线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。 待理解 两阶段终止模式 守护线程默认新创建的线程是非守护线程，java进程中主线程和所有非守护线程都结束了才会结束。 设置为守护线程：setDaemon(true)。 垃圾回收器：守护线程 线程状态在操作系统课本上，我们学的是线程有五种状态。 而在Java语言中，一个线程的状态有六种。从jdk Thread类的源码中就可以看到，定义在名称为State枚举中： image-20200516184955190 线程安全问题多线程对静态变量进行相同次数的自增自减。 thread1 thread2 a++; a–; a++:取a，计算a+1，写回内存 a–:取a，计算a-1，写回内存","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"JVM学习笔记-JVM内存区域","date":"2020-04-29T16:38:18.000Z","path":"2020/04/30/JVM学习笔记-JVM内存区域/","text":"学习JVM有一段时间了，消化后整理了此笔记便于自己复习，此系列定位为“笔记”，一些地方就写得比较精简了，适合已经系统学习过JVM的读者翻阅。 主要参考材料是《深入理解Java虚拟机》第二版。 JVM内存区域运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，每个区域有各自的用途。 根据该区域是否是线程私有，可以分为线程私有的区域和线程共享的区域。 线程私有的内存区域程序计数器它的作用是指示当前线程要执行的字节码的行号（字节码指令的地址）。 java多线程是通过线程轮流切换实现的，线程被挂起后下次需要恢复到正确的执行位置，所以每个线程都需要一个独立的程序计数器。 除了线程私有，程序计数器区域的另一个特点是占用内存空间很小，唯一的一个不会OOM的区域。 Java虚拟机栈既然它是栈，那么栈元素是什么呢？答案是栈帧。栈帧用于存放局部变量表、操作数栈 、动态链接、方法出口等信息。每调用一个Java方法，与之对应的一个栈帧入栈，执行完成，出栈。 此区域有两种内存溢出的情形： StackoverflowError 栈中加入的元素（栈帧）过多造成栈溢出，也就是调用的方法过多，一直没有返回），比如说持续递归会造成这种情况 。 OutOfMemoryError 如果虚拟机栈支持动态扩展，扩展时无法申请足够的内存，就会出现此情况OOM。 本地方法栈这一内存区域与 Java虚拟机栈类似，不过其服务的对象是本地方法（一般是由C/C++实现的）而非Java方法。 线程共享的内存区域堆此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也就变得不那么绝对了。 如果从垃圾回收的角度考虑，由于大部分JVM实现都采用了分代收集的回收算法，把堆空间进一步划分成新生代和老年代,其中新生代包括了Eden空间，From Survivor空间，To Survivor空间。 方法区方法区存放已被虚拟机加载的类的元数据（类信息、常量、静态变量、编译后的代码等等）。 永久代、元空间、方法区 三者关系 方法区是内存区域的一种规范，永久代和元空间都是方法区的一种实现。JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 运行时常量池是方法区的一部分 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用），类加载后Class文件中的常量池信息就进入了方法区的运行时常量池。 HotSpot虚拟机对象探秘《深入理解Java虚拟机》书中详细地介绍在HotSpot虚拟机在堆中对象分配、布局和访问的全过程。 对象的创建对象的创建总体上有这几个步骤： 类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 为新生对象分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 初始化为零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 对象头的设置 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行init方法 把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。 Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志等等,被官方称作Mark Word，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 对象的大小必须是 8 字节的整数倍。 对象的访问建立对象就是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种。 这两种对象访问方式各有优势，使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 。。。此处待上图。。。 实战:OutOfMemoryError异常上面讲的都是理论，在实战中，可能会遇到OOM的问题，我们开发人员要做的就是快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常该如何处理。 内存溢出区域 报错信息 可能的原因 解决方法 堆 OOM java heap space 调节堆大小(-Xms,-Xmx)检查代码对象的生命周期是否合理 栈 StackoverflowError OutOfMemoryError 方法区","tags":[{"name":"JVM","slug":"JVM","permalink":"http://hfq123.github.io/tags/JVM/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter9","date":"2020-04-26T02:22:51.000Z","path":"2020/04/26/《Head-First-设计模式》读书笔记charpter9/","text":"本篇博客是《Head First 设计模式》第九章的读书笔记。 分享主题是设计模式中的 「迭代器模式(Iterator Pattern)」以及 「组合模式(Composite Pattern)」。 迭代器模式场景:菜单合并有一家早餐馆和一家饭馆合并了，我们需要合并2张菜单，由于以前它们底层实现的数据结构不同，早餐菜单是由AarryList实现的，而正餐菜单是由数组实现的，现在要打印合并后的菜单。注意：这里说的“合并”不要求底层实现的数据结构的统一，产生一个新的菜单，而只需要打印格式统一就行了，供服务员类菜单统一打印菜单。 思路1：依次打印两张菜单实现P.S.为了便于阅读，本文只给出了部分核心代码，完整代码见GitHub。 pancakeHouseMenu类和DinerMenu类分别是早餐菜单和正餐菜单，代码略。 服务员类代码： 123456789101112131415161718192021public class Waitress&#123; //服务员类，主要工作:打印菜单(包含早餐菜单和正餐菜单) PancakeHouseMenu pancakeHouseMenu; //早餐菜单对象，ArrayList实现 DinerMenu dinerMenu; //正餐菜单对象，数组实现 ..... public void printMenu()&#123; //思路1 System.out.println(\"早餐--烙饼专场:\"); ArrayList&lt;MenuItem&gt; arrayList = pancakeHouseMenu.getArrayList(); for(MenuItem item : arrayList)&#123; System.out.println(item.toString()); &#125; System.out.println(\"正餐--套餐饭专场：\"); MenuItem[] menuItems = dinerMenu.getMenuItems(); for(int i = 0; i&lt;menuItems.length; i++)&#123; if(menuItems[i] == null) return; System.out.println(menuItems[i].toString()); &#125; &#125; .....&#125; 如上代码，这种思路是依次打印早餐菜单和正餐菜单： 用一个ArrayList对象接收早餐菜单，遍历这个ArrayList对象，打印每个早餐菜单项。 用一个数组对象接收正餐菜单，遍历这个数组对象，打印每个正餐菜单项。 分析 这种方法需要服务员类清楚地知道各个菜单的内部实现是怎么样的，这样才能分别使用正确的数据类型接收各菜单。 如果有新的菜单需要合并（比如这家餐厅又并入了一个咖啡馆），毫无疑问，我们要修改服务员类的printMenu()方法：根据新的菜单的数据结构接收菜单，再遍历这个集合。 总结前面两点，也就是说，如果有第三张菜单的出现，那么就会需要三个循环，服务员类需要清楚地知道这三张菜单各自的底层数据结构，数组？ArrayList ？HashTable？…… 思路2：使用迭代器模式经过对思路1的分析，我们发现，对于服务员类来说，其实没有必要关注菜单实现的细节：不需要知道每张菜单的各个菜单项是存放在什么类型的集合中的，它只需要关注如何依次获得每个菜单项对象。为此，改进思路是设计原则中的封装变化的部分：在这里，需要封装由不同集合类型所造成的遍历。 使用迭代器之后以正餐菜单为例，设计迭代器： 123456789101112131415161718192021222324252627282930313233public class DinerMenu implements IMenu &#123; //正餐菜单 static int MAX_ITEMS = 10 ; int numberOfItems = 0 ; MenuItem [] menuItems; ..........................//省略了初始化代码 @Override public Iterator createIterator() &#123; return new DinerMenuIterator(this.getMenuItems()); //获得迭代器 &#125;&#125;public class DinerMenuIterator implements Iterator &#123; //正餐菜单的迭代器 MenuItem [] items; //正餐菜单的数据结构是数组 int postion = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if(postion&gt;=items.length || items[postion]==null) return false; return true; &#125; @Override public MenuItem next() &#123; return items[postion++]; &#125;&#125; 服务员类中打印整张菜单的方法： 123456789101112131415public void printMenuWithIterator()&#123; //使用迭代器后，打印整张合并后的菜单 System.out.println(\"早餐--烙饼专场:\"); // printMenu(pancakeHouseMenu.createIterator()); printMenu(pancakeHouseMenu.getArrayList().iterator()); //pancakeHouseMenu的菜单项组织的数据结构是ArrayList，所以可以直接获得ArrayList内置的迭代器 System.out.println(); System.out.println(\"正餐--套餐饭专场：\"); printMenu(dinerMenu.createIterator());&#125;public void printMenu(Iterator iterator)&#123; //遍历某个菜单迭代器可访问的全部菜单项 while (iterator.hasNext())&#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.toString()); &#125;&#125; 可以看到，服务员类中，只需要调用各个菜单迭代器的hasNext()和next()来获得每个菜单项，无需关注其数据结构，只有在迭代器内部才需要关注具体的数据结构。 进一步改进：如上服务员类的代码，服务员类中分别组合了早餐菜单和午餐菜单两个对象，为了提高可拓展性，可以用一个ArrayList保存所有菜单，便于今后加入新的菜单或者删除现有菜单。 改进后更加优雅的服务员类代码: 12345678910111213141516171819202122232425262728/** * @Created by hfq on 2020/4/26 * @used to: 更加优雅的服务员 */public class WaitressImproved &#123; ArrayList menuList; //保存各个菜单 public WaitressImproved(ArrayList menuList) &#123; this.menuList = menuList; &#125; public void printMenu()&#123; Iterator menuIterator = menuList.iterator(); while (menuIterator.hasNext())&#123; IMenu menu = (IMenu) menuIterator.next(); //遍历各个菜单 printMenu(menu.createIterator()); //调用printMenu方法依次遍历并打印该菜单的每个菜单项 System.out.println(); &#125; &#125; public void printMenu(Iterator iterator)&#123; //遍历某个菜单迭代器可访问的全部菜单项 while (iterator.hasNext())&#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.toString()); &#125; &#125;&#125; 可以看到，这样做的好处在于，如果有新的菜单（需要实现createIterator()方法，获得这个菜单的迭代器）加入，不需要修改服务员类的代码，就能直接调用打印整个菜单的功能。 定义接下来我们来看看迭代器模式的定义： 迭代器模式提供一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 结合上例解读迭代器模式：服务员类不需要知道各个菜单内部究竟是用数组表示的还是ArrayList表示的，它只需要获得菜单的迭代器，由迭代器告诉服务员类还有没有没有遍历到的对象( hasNext() )、下一个遍历的对象是谁)( next() )，来遍历其中的每个对象。 设计原则 一个类应该只有一个引起变化的原因 java的Iterator接口迭代器模式在平时开发中经常用到。 hasNext() next() 组合模式场景引入组合模式的场景仍然是上例中菜单的例子，现在餐厅菜单引入了新的需求：上例的正餐菜单里需要嵌套一个甜品菜单，支持嵌套菜单后，整张菜单应该长这样： 支持嵌套子菜单的菜单结构 重点关注上图的“正餐菜单”，在这个菜单集合中，其集合项既可以是它的子菜单（图上的甜品菜单），又可以是普通菜品。 在代码中，我们也需要某种树形结构，可以在一个菜单下同时容纳子菜单和菜品。 引入组合模式没错，我们要引入组合模式来解决这个问题，先来看看组合模式是什么吧： &lt;%blockquote%&gt;组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象以及对象组合。&lt;%endblockquote%&gt; 有了场景的铺垫，很容易配合其定义解读，解读之前，再来规定一下案例中涉及到的几个业务概念，避免混淆。 菜单：作为一个整体菜单独立存在，比如上图的正餐菜单，在代码中独立以一个集合的形式存在。 菜品：菜单下具体的一道菜，比如，上图鸡腿饭是正餐菜单的一道菜品，是形成树形结构的“叶子节点”。 子菜单：某张菜单下嵌套的下级菜单，比如，上图甜品菜单是正餐菜单的一个子菜单，是形成树形结构的“子树”。 菜单项：在菜单概念中，提到了菜单是以一个集合的形式独立存在的，菜单项则就是菜单集合的集合项了，本案例中，菜品和子菜单都可以作为菜单项。 绕了这么多，让我们结合组合模式的定义分析：在本例中，“整体”对应菜单，“部分”对应菜单项，“个别对象”对应菜品，“对象组合”对应子菜单。因为菜单项既可以是菜品，也可以是子菜单，就构成了有层级关系的树形结构，而我们引入组合模式的目标就是希望能够以统一的方式地处理菜单下级的菜品和子菜单这两种不同结构，而不用关注它到底有没有、有几个子菜单，甚至在子菜单中也能再嵌套子菜单。写出简单的代码，就能够对整个菜单结构应用相同的操作，可以忽略对象组合（子菜单）和个别对象（菜品）的差别。 组合模式的UML图如下，接下来我们就要根据这个类图来编写本案例引入组合模式的代码，我已在图上红字标出本例中涉及到的类分别对应的组合模式角色。 组合模式的UML图 代码第一步，编写菜单项这一抽象父类代码再次强调，菜品可以作为菜单项，子菜单也可以作为菜单项，所以作为菜品和子菜单的共同接口，菜单项既要规定菜品有的方法，也要规定子菜单有的方法。 对于子菜单，它需要的方法有：添加菜单项、删除菜单项等。 对于菜品，它需要的方法有：获取菜品名、获取价格等。 子菜单需要的全体方法+菜品需要的全体方法就构成了菜单项抽象类的方法了。 123456789101112131415161718192021222324252627282930313233343536package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/26 * @used to: 菜单项（子菜单+菜品）的共同接口，抽象类实现 * 其中，有部分方法只针对子菜单有意义，有部分方法只针对菜品有意义，有部分方法对于它们都有意义，提供统一操作 */public abstract class MenuComponent &#123; public void add(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; public void remove(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; public MenuComponent getChild(int i)&#123; throw new UnsupportedOperationException(); &#125; public String getName()&#123; throw new UnsupportedOperationException(); &#125; public String getDescription()&#123; throw new UnsupportedOperationException(); &#125; public double getPrice()&#123; throw new UnsupportedOperationException(); &#125; public boolean isVergetarian()&#123; //是否是蔬菜 throw new UnsupportedOperationException(); &#125; public void print()&#123; throw new UnsupportedOperationException(); &#125;&#125; 在这个抽象类接口中，我们要注意，有些方法，比如说add()、remove()，只针对子菜单这一菜单项有意义而菜品这一菜单项不需要，而有些方法，比如说getPrice()，只针对菜品这一菜单项有意义而子菜单这一菜单项不需要， 正是因为子类菜品不需要其中的某些方法，而子菜单不需要另外一些方法，所以在抽象类的默认实现中，都抛出了异常。 而print()方法是一个”操作方法“，则可看作菜品和菜单项两者共同的操作。 至此，就完成了就是菜单项父类代码的编写（对应上面UML建模图中的Component角色），接下来就来完成其子类的代码，其子类包括菜品（对应Leaf角色）和子菜单（对应Composite角色）。 第二步，编写菜单项的两个子类代码菜品类和子菜单类只要挑选抽象父类中自己感兴趣的、有意义的方法实现即可。 菜品类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/30 * @used to: 菜单项的子类之一--菜品类 */public class MenuItem extends MenuComponent &#123; String name; //名称 String desc; //描述 boolean vegetarian; //是否为蔬菜 double price; //价格 public MenuItem(String name, String desc, boolean vegetarian, double price) &#123; this.name = name; this.desc = desc; this.vegetarian = vegetarian; this.price = price; &#125; public String getName()&#123; return name; &#125; public String getDescription() &#123; return desc; &#125; public double getPrice() &#123; return price; &#125; public boolean isVergetarian() &#123; return vegetarian; &#125; public void print() &#123; String item = \"MenuItem&#123;\" + \"name='\" + name + '\\'' + \", desc='\" + desc + '\\'' + \", vegetarian=\" + vegetarian + \", price=\" + price + '&#125;'; System.out.println(item); &#125;&#125; 子菜单类： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hfq.headfirstjava.charpter9.composite;import java.util.ArrayList;/** * @Created by hfq on 2020/4/30 * @used to: 子菜单类 */public class Menu extends MenuComponent&#123; ArrayList menuComponents = new ArrayList(); //组合了一个ArrayList对象来保存子菜单的所有菜单项 String name; String description; public Menu(String name, String description) &#123; this.name = name; this.description = description; &#125; public void add(MenuComponent menuComponent)&#123; menuComponents.add(menuComponent); &#125; public void remove(MenuComponent menuComponent)&#123; menuComponent.remove(menuComponent); &#125; public MenuComponent getChild(int i)&#123; return (MenuComponent) menuComponents.get(i); &#125; public String getName()&#123; return name; &#125; public String getDescription()&#123; return description; &#125; public void print()&#123; //难点 System.out.println(name+\"(\"+description+\")\"); System.out.println(\"--------------------------------\"); Iterator iterator = menuComponents.iterator(); while (iterator.hasNext())&#123; MenuComponent menuComponent = (MenuComponent) iterator.next(); menuComponent.print(); //递归调用子菜单的所有菜单项print方法 &#125; &#125;&#125; 第三步，编写服务员类的代码服务员类对应上面UML建模图中的Client客户角色。 12345678910111213141516171819202122232425262728293031323334353637package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/30 * @used to: 引入组合模式后的服务员类，是菜单的客户(UML类图中的Client) */public class Waitress &#123; MenuComponent allMenus; public Waitress(MenuComponent allMenus) &#123; this.allMenus = allMenus; &#125; public void printMenu()&#123; allMenus.print(); &#125; //测试代码 public static void main(String[] args) &#123; MenuComponent totalMenu = new Menu(\"总菜单\",\"存放所有分菜单\"); MenuComponent breakfastMenu = new Menu(\"早餐菜单\",\"含有各种早餐\"); breakfastMenu.add(new MenuItem(\"肉包子\",\"有猪肉的包子\",false,2.0)); breakfastMenu.add(new MenuItem(\"菜包子\",\"有香菇的包子\",true,1.0)); breakfastMenu.add(new MenuItem(\"烙饼\",\"荤素搭配的烙饼\",false,3.0)); MenuComponent dinnerMenu = new Menu(\"正餐菜单\",\"含有各种饭,还包含了一个甜品菜单\"); dinnerMenu.add(new MenuItem(\"鸡腿饭\",\"有红烧鸡腿\",false,10.0)); dinnerMenu.add(new MenuItem(\"牛肉饭\",\"有香辣牛肉\",false,15.0)); MenuComponent dessertMenu = new Menu(\"甜品菜单\",\"包含多种甜品\"); dessertMenu.add(new MenuItem(\"烧仙草\",\"美味的烧仙草\",false,3.0)); dessertMenu.add(new MenuItem(\"绿豆汤\",\"清爽的绿豆汤\",true,1.0)); dinnerMenu.add(dessertMenu); totalMenu.add(breakfastMenu); totalMenu.add(dinnerMenu); Waitress waitress = new Waitress(totalMenu); waitress.printMenu(); &#125;&#125; 上述测试代码打印菜单的结果如下所示，成功达到我们的目标： 测试打印整张菜单的结果 为了让显示效果好一点，看得出菜单嵌套的层级效果，我又对上面的代码做了略微的改动，print()方法加了一个String类型的前缀，具体实现请移步Github。如下图，改动后，能在打印结果看出来甜品菜单是正餐菜单的子菜单。 改动后的显示效果具有层次 总结组合模式中让组件接口（对应于本例中的菜单项的抽象类）同时包含一些管理子节点（子菜单）和叶子节点（菜单项）的操作，客户(Client)就可以将组合和叶节点一视同仁，也就是说，一个元素究竟是组合还是叶节点，对用户是透明的，在案例中，即使是用户不知道一个菜单项究竟是子菜单还是普通菜品的情况下，也能调用统一的print方法打印。 然而，组合模式这种做法失去了一些“安全性”，这是因为客户有机会对一个元素做不恰当或者是没有意义的操作(列入本例中试图调用一个菜品对象的add方法，菜品类继承了菜单项抽象类，所以它有add方法，但是这个add方法实际上是为子菜单类服务的，而对菜品类无意义)。假如我们将菜品和子菜单各自需要的方法区分开来放到不同的接口里，客户代码就必须用条件语句和instanceof操作符来区别对待不同类型的节点(菜品和子菜单)。 所以说，使用组合模式是便利性和违背涉及原则折衷的一个选择。 组合迭代器分别学完了迭代器模式和组合模式之后，来看看它们共同作用会什么样的火花吧，亲密无间的配合也是它们放在同一个章节的原因。 我们可以这样理解，在上文介绍迭代器模式时的场景中，菜单集合是一维的，因为其集合元素都是菜品，而组合模式中的案例场景中，菜单结构是有嵌套层次的。针对一个元素全都是菜品对象的普通的菜单集合，构建它的迭代器很简单，而对于构建像这一树形层次结构的集合的迭代器又该如何做呢？","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"密码测试文章","date":"2020-04-25T16:52:33.000Z","path":"2020/04/26/密码测试文章/","text":"我的名字（全小写）？26370213ec222ab70d5b0a28fe3afc58ad364a9a8e644a0f27472f05678679b7b447aa193cd5f8e634c1f8a6c2f3768287d7d05195b8437b8f646f274a57e68d8ef79fdcd15cfb3b7b027b1c73e04d51","tags":[{"name":"日常","slug":"日常","permalink":"http://hfq123.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"【每日更新】算法题","date":"2020-04-21T12:17:21.000Z","path":"2020/04/21/【每日更新】算法题/","text":"20200522截止昨日，剑指Offer刷题进度：55/67，Leetcode 9/148 ，已坚持每天刷3题的天数：9。 20200521 阴截止昨日，剑指Offer刷题进度：54/67，Leetcode 18/148 ，已坚持每天刷3题的天数：9。 题1 【待改进】二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 我的想法比较简单：先把中序遍历结果存放在ArrayList里（存节点而不是值），然后在这个list里调整指针的指向，最后返回list中的第一个节点。 能AC，不过应该不是出题者的用意，待改进。 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;public class Solution &#123; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree ==null) return null; ArrayList &lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); inorder(pRootOfTree,list); //此时，list中保存了中序遍历的结果 for(int i = 0;i&lt;list.size();i++)&#123; TreeNode node = list.get(i); if(i==0)&#123; node.left = null; &#125;else&#123; node.left = list.get(i-1); &#125; if(i==list.size()-1)&#123; node.right = null; &#125;else&#123; node.right = list.get(i+1); &#125; &#125; return list.get(0); &#125; public void inorder(TreeNode root,ArrayList list)&#123; if(root==null) return; inorder(root.left,list); list.add(root); inorder(root.right,list); &#125;&#125; 题2 two sum 给出一个整数数组，请在数组中找出两个加起来等于目标值的数， 你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的 假设给出的数组中只存在唯一解 例如： 给出的数组为 {2, 7, 11, 15},目标值为9输出 ndex1=1, index2=2 思路：题目知识点打了个哈希标签。于是用了哈希表，把数组的值作为key，把数组的索引（下标）作为value，因为HashMap的查找时间复杂度平均是O(1)，所以这样做用空间换时间是合理的。 写代码的时候要注意题目要求下标是从1开始的，另外就是要注意map.put(target-numbers[i],i+1); 这一行与澳方在判断的后面，否则比如说 测试用例是：[1,0,2,4]，2 ， 正确结果应该是返回[1，2]（0+2=2），而如果先添加再判断，返回结果就变成了[1,1]。 12345678910111213141516171819202122import java.util.HashMap;public class Solution &#123; /** * * @param numbers int整型一维数组 * @param target int整型 * @return int整型一维数组 */ public int[] twoSum (int[] numbers, int target) &#123; // write code here int res [] = new int [2];//存放返回结果 HashMap &lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i&lt;numbers.length; i++)&#123; if(map.containsKey(numbers[i]))&#123; res[0] = map.get(numbers[i]); res[1] = i+1;//记得这里要加1，因为下表要加1 &#125; map.put(target-numbers[i],i+1); //存放自己期待的数(能够和自己相加得到target的数)和自己的下标（从1开始） &#125; return res; &#125;&#125; 题3 右旋转链表 将给定的链表向右转动k个位置，k是非负数。例如：给定1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null ， k=2，返回4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;null。 写时感觉代码写的不怎么优雅，有些凌乱，不过竟然一次过了。做这种题最重要的是先理解题目的意思，用实例演算一下，来帮助判断代码中的边界条件 实例演算： 原链表==12345右移1==51234右移2==45123右移3==34512右移4==23451右移5==12345 （复原） 演算几个例子就会发现是有迹可循的，可以定位到节点后一步到位地完成旋转，没必要在循环里一步步旋转。具体说来，思路是： 1.末尾节点指向头结点 2.倒数第k个元素为头结点 3.倒数第k+1个元素指向null（也就是第2步的前一个结点） 所以我的代码中设置了好几个节点的引用：末尾节点、工作节点p（用来定位尾节点以及倒数第k个节点）、结果节点，反思了一下：我在求倒数第k个节点的时候是先求链表的总长度，再求差值定位，这里可以用快慢指针。 PS 后面又想了想，这里还是有必要求处链表的长度，因为在取余操作也要用到。 题目本身不难，下一次解答此题的关注点放在怎么写出优美易懂的代码 12345678910111213141516171819202122232425public class Solution &#123; public ListNode rotateRight (ListNode head, int k) &#123; if(head==null) return null; int len = 0; ListNode p = head,tail=head; while(p!=null)&#123; len++; tail=p; p=p.next; &#125; k%=len; //取余操作，把链表的最后k%len个元素拿到链表前面来 int cnt = 0; p=head; while(cnt&lt;len-k-1)&#123; cnt++; p=p.next; &#125; tail.next = head; ListNode res = p.next; //复查代码的时候发现这个res引用没必要，可以直接用head p.next = null; return res; &#125;&#125; 20200520 晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 15/148 ，已坚持每天刷3题的天数：8。 题1自底向上的层序遍历 给定一个二叉树，返回该二叉树由底层到顶层的层序遍历，（从左向右，从叶子节点到根节点，一层一层的遍历） 我这里还是按照层序遍历的普通思路，然后调用Collections.reverse(result)，反转ArrayList。还有一个思路是result.add(0,list)，也就是说每次插入都插入到最前面，但是这个方法的时间复杂度太高了（数组头插，其他元素都要后移）。也可以考虑使用LinkedList头插，然后通过ArrayList arrayList = new ArrayList(linkedList);转换成ArrayList ，加到result中。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Queue; import java.util.LinkedList;import java.util.Collections;public class Solution &#123; /** * * @param root TreeNode类 * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt; */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom (TreeNode root) &#123; // write code here if(root==null) return new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int leftNumToNextLevel = 1; //到达下一层需要访问的剩余元素个数 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); //出队列 list.add(node.val); leftNumToNextLevel--; if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; if(leftNumToNextLevel==0)&#123; //已遍历完了一层 result.add(list); list=new ArrayList&lt;&gt;(); leftNumToNextLevel=queue.size(); &#125; &#125; Collections.reverse(result); return result; &#125;&#125; 题2 【待完善】指定区间内的链表反转 将一个链表m位置到n位置之间的区间反转，要求使用原地算法，并且在一次扫描之内完成反转。 例如： 给出的链表为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 ，n = 4, 返回1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. 注意： 给出的m，n满足以下条件： 1 ≤ m ≤ n ≤ 链表长度 之前我做反转链表的时候用到了栈，需要O(n)级别的空间复杂度，今天刚听说并学了原地反转链表（意味着O（1）级别的空间复杂度）的思路，核心是使用3个移动指针p1、p2、p3和一个定指针tail。 一开始，做这题要考虑的特殊情况很多（比如说是否只有0、1、2个元素，分别做不同处理），根据错误测试用例调整了许久，结果还是只能AC45%： 看题解，很简洁地求解了这个问题，果然，如果发现自己代码中的特殊情况很多，很可能是代码写的不好。 附上我的45%代码，以供日后修正： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; /** * * @param head ListNode类 * @param m int整型 * @param n int整型 * @return ListNode类 */ public ListNode reverseBetween (ListNode head, int m, int n) &#123; // write code here if(head==null || head.next==null) //为空或者只有一个元素 return head; if(head.next.next==null)&#123;//只有两个元素 if(m==1 &amp;&amp; n==2)&#123; //这种情况才会有元素需要反转 ListNode node = head.next; node.next = head; head.next = null; return node; &#125; return head; &#125; ListNode dummy = new ListNode(0); dummy.next=head; ListNode p1=dummy,p2=p1.next,p3=p2.next,tail=dummy; int cur=0; while(cur&lt;m &amp;&amp; p3!=null)&#123; //此循环的目的是定位tail、p1、p2、p3 cur++; tail=p1; //记录下tail的位置 p1=p1.next; p2=p1.next; p3=p2.next; &#125;//退出循环时，cur=m，说明要开始反转动作了 while(cur&lt;n &amp;&amp; p3!=null )&#123; //以下三步用于完成反转操作 tail.next=p2; p1.next=p3; p2.next=p1; //以下三步用于p1、p2、p3前移 p1=p1.next; p2=p2.next; p3=p3.next; cur++; &#125; return dummy.next; &#125;&#125; 题3 二叉树的层序遍历这道题就是今天做的题1的简单版。直接在其基础上复制了，今天学习时间太长，有点累了，不过每天三题还是要保证的，层序遍历已经很熟悉了，就算是偷个小懒。 题4 之字形二叉树层序遍历同上，今天AC的这几题都是一个系列的，今天算是水一下任务。 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; /** * * @param root TreeNode类 * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt; */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder (TreeNode root) &#123; // write code here if(root==null) return new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int leftNumToNextLevel = 1; //到达下一层需要访问的剩余元素个数 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); boolean leftToRight = true; while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); //出队列 list.add(node.val); leftNumToNextLevel--; if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; if(leftNumToNextLevel==0)&#123; //已遍历完了一层 if(!leftToRight)&#123; //如果不是从左向右，说明要反转 Collections.reverse(list); &#125; result.add(list); list=new ArrayList&lt;&gt;(); leftNumToNextLevel=queue.size(); leftToRight^=true; //leftToRight取反 &#125; &#125; return result; &#125;&#125; 20200519 晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 12/148 ，已坚持每天刷3题的天数：7。 rotate-image顺时针旋转矩阵 给出一个用二维矩阵表示的图像 返回该图像顺时针旋转90度的结果 扩展： 你能使用原地算法解决这个问题么？ 旋转前后 题1 有序链表合并 将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。 这题想了很久才理清思路，实在不应该。 思路 12345678910111213141516171819202122public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; if(l2==null) return l1; ListNode m = l1; //这两个变量没必要，可以直接使用l1、l2 ListNode n = l2; ListNode res = new ListNode(0); //先随便指定一个无意义的头节点（以遍后续代码统一） ListNode tail = res; //尾结点 while(m!=null &amp;&amp; n!=null)&#123; if(m.val&gt;n.val)&#123; //l2的当前结点比较小 tail.next=n; n=n.next; &#125;else&#123; //l1的当前结点比较小 tail.next=m; m=m.next; &#125; tail=tail.next; &#125; tail.next=(m==null?n:m); return res.next; //记得返回的是res.next。 &#125;&#125; 题2 查找二维数组中的数 请写出一个高效的在m*n矩阵中判断目标值是否存在的算法，矩阵具有如下特征： 每一行的数字都从左到右排序, 每一行的第一个数字都比上一行最后一个数字大 1234567891011121314151617public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix==null || matrix[0]==null) return false; //思路：从左下角开始找 int curI=matrix.length-1,curJ=0; //分别表示当前数字的纵坐标和横坐标 while(curI&gt;=0 &amp;&amp; curJ&lt;=matrix[0].length-1)&#123; if(target&lt;matrix[curI][curJ])&#123; curI--; //当前数字要变小，往上走 &#125;else if(target&gt;matrix[curI][curJ])&#123; curJ++; //当前数字要变大，往右走 &#125;else return true; &#125; return false; &#125;&#125; 题3 两链表的数相加 给定两个代表非负数的链表，数字在链表中是反向存储的（链表头结点处的数字是个位数，第二个结点上的数字是百位数…），求这个两个数的和，结果也用链表表示。 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出： 7 -&gt; 0 -&gt; 8 题目本身不难，考虑得全面一点就好了。 1234567891011121314151617181920212223242526public class Solution &#123; //需要考虑：诸如5+5的情况，正确结果应该是01 //需要考虑: l1和l2长度不一样的情况,我这里的处理方式是空时也放在循环内，+0 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0);//无意义的头节点 ListNode tail = head; int carry = 0; //下次计算的进位 while(l1!=null || l2!=null)&#123; int temp = (l1==null?0:l1.val)+(l2==null?0:l2.val)+carry; //这一位的相加结果 if(temp&gt;=10)&#123; temp-=10; carry=1; &#125;else&#123; carry=0; &#125; tail.next = new ListNode(temp); tail=tail.next; l1=(l1==null?l1:l1.next); l2=(l2==null?l2:l2.next); &#125; if(carry==1)&#123; //如果最后还有进位，末尾再加一个1 tail.next = new ListNode(1); &#125; return head.next; &#125;&#125; 20200518 晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 6/148 ，已坚持每天刷3题的天数：6。 题1 非递归二叉树后序遍历1234567891011121314151617181920212223242526import java.util.Stack;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if(root==null) return new ArrayList&lt;&gt;(); Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); stack.push(root); //先加入根节点 while(!stack.isEmpty())&#123; TreeNode node = stack.peek(); if(node.left==null &amp;&amp; node.right==null)&#123; list.add(stack.pop().val); &#125;else&#123; if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); node.right=null; node.left=null; &#125; &#125; return list; &#125;&#125; 分析：用栈实现，后序访问次序是左右根，所以按照根、右、左的次序依次加入栈，比如说求root的后序序列，就是先将root结点压栈，再将root.right压栈，再将root.left压栈（当left和right都非空的情况下），最后将root.left压栈这一步也就是压入了左子树的根节点，此时再检查栈顶节点是否是叶子结点（也就是判断是否还有孩子），如果是叶子节点，就出栈加到list中，如果不是，就依旧按照右孩子、左孩子的次序压栈，且把栈顶的该结点的right和left都置为空，这样的话下次再访问该栈顶元素，第一个if条件成立,就加入list了。 这个做法是前几天我学了非递归前序遍历后想出来的，可以AC，不过稍加分析，有明显缺陷： 1234node.right&#x3D;null;node.left&#x3D;null;这两行代码破坏了原二叉树的结构。 后序遍历二叉树的非递归写法图解 根据上图思路，改进后： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.Stack;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if(root==null) return new ArrayList&lt;&gt;(); Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); //TreeNode node = root; stack.push(root); //先加入根节点 TreeNode frontNode=root; //初始化为root，如果初始化为null会有问题。 while(!stack.isEmpty())&#123; TreeNode node = stack.peek(); if((node.left==null &amp;&amp; node.right==null) || frontNode==node.left||frontNode==node.right )&#123; frontNode = stack.pop(); list.add(frontNode.val); &#125;else&#123; if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); &#125; &#125; return list; &#125;&#125; 题2二叉树路径和 给定一个二叉树和一个值sum，判断是否有从根节点到叶子节点的节点值之和等于sum的路径。 递归实现，体现了分治法的策略。 12345678910public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root==null) return false; if(root.left==null &amp;&amp; root.right==null)&#123; //是叶子结点 return sum==root.val; &#125; return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val); &#125;&#125; 题3 【未解决】 有序单链表转平衡BST题4 平衡二叉树判断 判断给定的二叉树是否是平衡的 在这个问题中，定义平衡二叉树为每个节点的左右两个子树高度差的绝对值不超过1的二叉树. 123456789101112131415161718public class Solution &#123; private boolean flag=true; public boolean isBalanced(TreeNode root) &#123; getHeight(root); return flag; &#125; public int getHeight(TreeNode root)&#123; if(root==null || !flag) //如果flag已经是false，就没必要算了 return 0; int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); int diff = leftHeight - rightHeight; if(Math.abs(diff)&gt;1)&#123; //递归计算高度的同时进行平衡判断 flag=false; &#125; return 1+Math.max(leftHeight,rightHeight); &#125;&#125; 递归解法，用了成员变量作为标志，不太优雅。。 20200517 雨转晴截止昨日，剑指Offer刷题进度：54/67，Leetcode 6/148 ，已坚持每天刷3题的天数：5。 换个策略，按照通过率从高到低刷题。 假设你有一个数组，其中第i个元素表示某只股票在第i天的价格。设计一个算法来寻找最大的利润。你可以完成任意数量的交易(例如，多次购买和出售股票的一股)。但是，你不能同时进行多个交易(即，你必须在再次购买之前卖出之前买的股票)。 思路：每天都考虑是否要买。有赚就买，亏损则不买。 题1 买卖股票的最佳时间2123456789101112public class Solution &#123; public int maxProfit(int[] prices) &#123; //每天都考虑是否要卖出 int res=0; for(int i=0;i&lt;prices.length-1;i++)&#123; int diff = prices[i+1]-prices[i]; //计算本日与昨日的盈利额 if(diff&gt;0) res+=diff; &#125; return res; &#125;&#125; 题2 container-with-most-water 盛放最多水的容器这题有印象，之前好像在leetcode做过。本来一直在按照动态规划的思路做，后来才意识到，这是一道双指针的题。而且两边的指针要从中间开始向两边，而不是从两边开始。 public class Solution { public int maxArea(int[] height) { if(height==null||height.length==1) return 0; int dp [] = new int[height.length]; //dp[i]表示以height[i]结束的容器的最大盛水量 int tempMax = height[0]; //记录当前最高的下标（因为要计算长度），也就是height[i]之前的最大值 for(int i=1;i&lt;dp.length;i++){ if(height[i-1]&gt;tempMax){ tempMax=height[i-1]; } dp[i]=dp[i]*Math.max(height[]); } }} 题3 [same-tree] 给出两个二叉树，请写出一个判断两个二叉树是否相等的函数。 判断两个二叉树相等的条件是：两个二叉树的结构相同，并且相同的节点上具有相同的值。 最简单的递归了， 面试遇到这个题能笑出声。 123456789public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null) return true; else if(p==null || q==null) return false; return p.val==q.val &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); &#125;&#125; 二分查找 给出一个有序的数组和一个目标值，如果数组中存在该目标值，则返回该目标值的下标。如果数组中不存在该目标值，则返回如果将该目标值插入这个数组应该插入的位置的下标假设数组中没有重复项。下面给出几个样例：[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 12345678910111213141516public class Solution &#123; public int searchInsert(int[] A, int target) &#123; int l = 0,r=A.length-1,m; //分别表示left，right,mid while(l&lt;=r)&#123; m = (r-l)/2+l; if(A[m]==target)&#123; return m; &#125;else if(A[m]&gt;target)&#123; //说明要在左边找 r=m-1; &#125;else&#123; l=m+1; &#125; &#125; return l; &#125;&#125; 20200516 多云截止昨日，剑指Offer刷题进度：54/67，Leetcode 3/148 ，已坚持每天刷3题的天数：4。 题1 判断链表有环思路：快慢指针都从链表的头节点出发，然后快指针每次走两步，慢指针每次走一步，如果有环，它们迟早会相遇。 之前，剑指Offer做过比这难的，还要求求出进入环的那个结点，做了那题在做这题就是小意思了。 12345678910111213public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head, slow=head; while(fast!=null&amp;&amp;fast.next!=null)&#123; fast=fast.next.next; //每次走两步 slow=slow.next; //每次走一步 if(fast==slow)&#123; return true; &#125; &#125; return false; &#125;&#125; 题2single-number 现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。 注意： 你需要给出一个线性时间复杂度的算法，你能在不使用额外内存空间的情况下解决这个问题么？ 思路：位运算。 a ^ a = 0，0 ^ x = x 12345678910public class Solution &#123; public int singleNumber(int[] A) &#123; int res = 0; for(int i = 0;i&lt;A.length;i++)&#123; res^=A[i]; &#125; return res; &#125;&#125; 题3 深拷贝带随机指针的链表 现在有一个这样的链表：链表的每一个节点都附加了一个随机指针，随机指针可能指向链表中的任意一个节点或者指向空。 请对这个链表进行深拷贝。 剑指Offer做过，权当是复习了。 分三步骤： 第一次遍历，在原链表原地复制每个结点（在原链表的每个结点之后插入它的复制结点），先不用例会它的随机指针。 第二次遍历，为新复制的结点指定random指针。 第三次遍历，分离原链表和复制链表。 思路很正确，一直卡在了一个点。注意随机指针可能是空。题目还特意提示了，我一直没考虑到这一点，早点看题目就能发现了，然而我一直盯着代码找bug所以一直没想到。 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; RandomListNode p = head; while(p != null)&#123; RandomListNode copyNode = new RandomListNode(p.label); copyNode.next = p.next; p.next = copyNode; p = copyNode.next; &#125; p = head; RandomListNode q = head; while(p!=null &amp;&amp; p.next!=null)&#123; q = p.next; if(p.random != null)&#123; q.random = p.random.next; &#125;else&#123; q.random = null; &#125; p = p.next.next; &#125; p = head; q = head.next; RandomListNode res = q; while(q!=null&amp;&amp;q.next!=null)&#123; p.next = p.next.next; q.next = q.next.next; p = p.next; q = q.next; &#125; return res; &#125;&#125; 20200515 雨截止昨日，剑指Offer刷题进度：54/67 ，已坚持每天刷3题的天数：3。 从今天开始，开始刷牛客网上的Leetcode精选题，剑指Offer剩下的13题都没啥思路，先放一放，回头说不定会有想法。 题1 二叉树的最小深度 求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量。 思路： 迭代的方法：层序遍历二叉树，记录层数，一旦发现了叶子结点，返回当前记录的层数。 递归的方法：略。 1234567891011121314151617## 先提供一种错误解法！！！错误解法public class Solution &#123; public int run(TreeNode root) &#123; return minHeight(root); &#125; public int minHeight(TreeNode root)&#123; if(root==null) return 0; if(root.left==null &amp;&amp; root.right==null) return 1; return 1+Math.min(minHeight(root.left),minHeight(root.right)); &#125;&#125; 比如说树是 1 2 这样做，会认为最小深度是 mimHeight(1) = 1+min&#123;minHeight(2)，minHeight(null)&#125;,结果是1，实际上结果是2 层序遍历实现。成功AC。 12345678910111213141516171819202122232425262728293031import java.util.Queue;import java.util.LinkedList;public class Solution &#123; public int run(TreeNode root) &#123; if(root==null) return 0; Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int leftNumToNextLevel = 1; //到下一层的剩余数,(再层序访问leftNumToNextLevel个结点到达下一层) int cnt = 1; //最小层数 while(queue.size()!=0)&#123; TreeNode node = queue.poll(); leftNumToNextLevel--; if(node.left==null &amp;&amp; node.right==null)&#123; break; &#125; if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; if(leftNumToNextLevel==0)&#123; leftNumToNextLevel = queue.size(); cnt++; &#125; &#125; return cnt; &#125;&#125; 题2 evaluate-reverse-polish-notation题1 计算逆波兰式（后缀表达式）的值 运算符仅包含”+”,”-“,”*”和”/“，被操作数可能是整数或其他表达式 例如： 题3 max-points-on-a-line 对于给定的n个位于同一二维平面上的点，求最多能有多少个点位于同一直线上 题4 二叉树的前序遍历（非递归方法）思路： 首先打印根结点，然后打印左子树的根节点，若右子树不为空，把右子树的根节点压入栈。注意右子树可能还有孩子，所以不能直接遍历栈的元素，而是要用处理根节点同样的方法处理右孩子。 123456789101112131415161718192021222324252627282930！！！能AC，但是不推荐import java.util.Stack;import java.util.ArrayList;public class Solution &#123; Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root==null) return list; pre(root); while(stack.size()!=0)&#123; TreeNode right = stack.pop(); pre(right); //right是原来右子树的一部分。 &#125; return list; &#125; public void pre(TreeNode root)&#123; if(root==null) return; while(root!=null)&#123; list.add(root.val); if(root.right!=null)&#123; stack.push(root.right); &#125; root=root.left; &#125; &#125;&#125; 这是我自己想到的思路，不过代码不太优雅。附上一个更加简洁的思路： 非递归方式实现前序遍历 根据此思路改进后的代码： 123456789101112131415161718public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root==null) return new ArrayList&lt;&gt;(); Stack &lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); stack.add(root); while(stack.size()!=0)&#123; TreeNode node = stack.pop(); list.add(node.val); if(node.right!=null)&#123; stack.push(node.right); &#125; if(node.left!=null)&#123; stack.push(node.left); &#125; &#125; return list;&#125; 相似题目： 中序遍历二叉树的非递归 中序遍历二叉树的非递归写法 后序遍历二叉树的非递归写法 后序遍历二叉树的非递归写法图解 题5 maximum-depth-of-binary-tree二叉树的最大深度1234567public class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; &#125;&#125; 20200514 晴题1 【待改进】滑动窗口的最大值 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路: 用一个长度为size的数组记录当前的窗口，并为此数组设置一个指针，这个指针指向下一个要替换的元素位置。 每走一步，就重新计算一下这个窗口的最小值。 最基础的思路的代码： 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; if(size&lt;=0|| size&gt;num.length) return new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int window[] = new int [size]; //记录当前滑动窗口的值 int curr = size-1; //下一个替换的指针 for(int i=0;i&lt;size-1;i++)&#123; window[i] = num[i]; &#125; for(int i=size-1;i&lt;num.length;i++)&#123; window[curr]=num[i]; curr=(curr+1)%size; int max=Integer.MIN_VALUE; for(int j = 0; j&lt;size; j++)&#123; //每次重新计算滑动窗口的最小值 if(window[j]&gt;max)&#123; max=window[j]; &#125; &#125; list.add(max); &#125; return list; &#125;&#125; 做完了反思: 这样做多此一举了，还不如直接设置两个指针，在原数组上直接计算，没必要单独为窗口开辟空间。 题2不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 看到题目描述，不用加减乘除运算做加法很可能和位运算有关。 参考了大佬的题解后豁然开朗。 简而言之，如果x &amp; y = 0，说明x+y两个数任意位上都不存在进位，结果就是 x ^ y，如 100+001 = 100 ^ 001 = 101，而如果x &amp; y !=0，那就说明两数相加必有进位。这时候我们依旧是先计算 x ^ y， 作为没有处理进位的加法，再在此基础上考虑进位 : (x&amp;y) 计算出应该进位的位&lt;&lt;1，得到进位结果 再加 不考虑进位的结果x^y ，得到结果。。 12345678910111213141516public class Solution &#123; public int Add(int num1,int num2) &#123; int res = num1 ^ num2; //int carry = 0 ; //表示进位结果 while(true)&#123; res = num1 ^ num2; if((num1 &amp; num2)!=0)&#123; //说明结果应该有进位 num2 = ((num1&amp;num2)&lt;&lt;1); //注意这一行和下一行的位置不能颠倒，这里应该用个提前记录变量比较好，应该用个变量记录num1&amp;num2的结果，代码比较清楚，也不用考虑两行的位置颠倒的问题。 num1 = res; &#125;else&#123; break; &#125; &#125; return res; &#125;&#125; 1234567891011//从评论看到的递归解法，有助于理理思路，写的话还是迭代写法。class Solution &#123;public:int Add(int num1, int num2)&#123; int n=(num1^num2); int m=(num1&amp;num2)&lt;&lt;1; if(m==0)return n; return Add(n,m);&#125;&#125;; 题3对称的二叉树关键是想到先写一个判断两棵树是不是对称的辅助方法。 123456789101112131415161718public class Solution &#123; boolean isSymmetrical(TreeNode node1,TreeNode node2)&#123; //判断以node1和node2为根节点的树是否是镜像的 if(node1==null &amp;&amp; node2==null)&#123; return true; &#125;else if(node1==null || node2 ==null)&#123; //其中一个为空，另一个不为空 return false; &#125;else&#123; //都不为空 return node1.val==node2.val &amp;&amp; isSymmetrical(node1.left,node2.right) &amp;&amp; isSymmetrical(node1.right,node2.left) ; &#125; &#125; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot==null) return true; return isSymmetrical(pRoot.left,pRoot.right); &#125;&#125; 20200513 晴目前进度：48/67 题1 【未完成】二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路： BST要变成排序的双向链表，所以极有可能和中序遍历有关。 题2 【待改进】 孩子们的游戏(圆圈中最后剩下的数)数组实现：代码很不优雅，不过可以正确AC 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n==0)&#123; return -1; &#125; //数组实现 boolean out [] = new boolean[n]; //记录每个人的出列状态 int left = n; //记录当前队列剩余人数 int j = -1; //报数计数器 while(true)&#123; for(int i=0; i&lt;n ;i++)&#123; if(out[i] == false)&#123; j++; //报数 if(j==m-1)&#123; out[i]=true; //此人出列 left--; j=-1; &#125; &#125; &#125; if(left==1)&#123; //只剩余一个人 break; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(out[i]==false)&#123; return i; &#125; &#125; return -1; &#125;&#125; 题3 链表中环的入口结点没啥思路，参照了牛客网大佬的题解图，豁然开朗。 图片说明 1234567891011121314151617181920212223public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead==null || pHead.next==null) return null; ListNode fast=pHead,slow=pHead; while(fast!=null || fast.next!=null)&#123; fast=fast.next.next; slow=slow.next; if(fast==slow)&#123; //fast和slow相遇了 ListNode p = pHead; while(p!=slow)&#123; p=p.next; slow=slow.next; &#125; return slow; &#125; &#125; return null; &#125;&#125; 题4 求1+2+3+…..+n(https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13) 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 1234567public class Solution &#123; public int Sum_Solution(int n) &#123; int res=n; boolean continuee = (res&gt;0) &amp;&amp; ((res+=Sum_Solution(n-1))&gt;0) ; return res; &#125;&#125; 江湖人称：短路求值 20200512 晴题1 二叉搜索树的后序遍历序列 输入一个非空整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路: 写代码前先理清二叉搜索树的后序遍历有什么特征 : 后序遍历的顺序无非就是左-&gt;右-&gt;根。 最后一个遍历的元素是根节点，而由于是BST，所以可以根据和根节点比较来判断其是左子树的一部分还是右子树的一部分。 如下面这棵树的后序遍历结果是132，根据这个序列可知根节点是2，小于2的部分（这里只有1）是左子树，大于2的部分（这里只有3）是右子树。 如何把我们发现的特征转化为代码实现呢： 左边开始一部分小于根节点（也可能是空），属于左子树，一旦出现了一个大于根节点的，就属于右子树（同样也有可能是空），如果后面再次出现了取值小于根节点的取值，说明不可能是二叉搜索树的遍历结果，返回false，如果没有出现过，则在这一次调用没有发现问题，再递归调用其左右子树的序列检查左右子树是否符合要求。 转一个来自牛客网大佬的定义便于理解，一开口就是老递归了： BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。 1234567891011121314151617181920212223public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null|| sequence.length == 0) //因为题目说了是非空序列。 return false; return VerifySquenceOfBST(sequence,0,sequence.length-1); &#125; public boolean VerifySquenceOfBST(int [] a,int begin,int end)&#123; if(begin&gt;=end)&#123; //这个条件可以优化成end-begin&gt;=2，即表示数组序列只有3个以内的元素，可以直接返回真，因为三个即以下元素。 return true; &#125; int i = begin; while(a[i]&lt;a[end])&#123; //说明 下标为begin的元素属于左子树 i++; &#125; //结束循环了，说明此时a[i] &gt; a[end]，从现在开始，后面所有元素都应该大于a[end] int mid = i; //i继续往前走之前，先记录左子树和右子树元素的分界点 for(i=i+1;i&lt;end;i++)&#123; if(a[i]&lt;a[end]) return false; &#125; return VerifySquenceOfBST(a,begin,mid-1) &amp;&amp; VerifySquenceOfBST(a,mid+1,end-1); &#125;&#125; 题2 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 下次做题时的提示编写一个方法：public TreeNode recur(int [] pre,int [] in,int i1,int j1,int i2,int j2) 用求前序序列为pre[i1…j1]、中序序列为in[i2…j2]的根节点 解题思路前序列序：1,2,4,7,3,5,6,8 中序序列：4,7,2,1,5,3,8,6 由于前序遍历序列访问次序是根左右，第一个元素必定是根节点，所以所求树的根节点是1，这时我们再去中序遍历序列中找到根节点1，其左边的所有元素构成了左子树的中序遍历序列，而其右边的所有元素构成了右子树的中序遍历序列，（因为中序遍历次序是左根右，所以根节点在此序列中划分了左右子树）。找到了根节点1，发现了其左子树有3个元素，这个信息又可以帮助确定前序遍历序列中的左子树和右子树。 根据上述分析，我们得到了如下信息： 根节点：1 左子树中序序列：4，7，2；右子树中序序列：5，3，8，6 左子树前序序列：2，4，7；右子树前序序列：3，5，6，8 显然，这时又可以分别用左（右）子树的前序+中序序列求左（右）子树的根节点，构成了一个递归。 123456789101112131415161718192021222324public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return reConstructBinaryTree(pre,in,0,pre.length-1,0,pre.length-1); &#125; public TreeNode reConstructBinaryTree(int [] pre,int [] in,int i1,int j1,int i2,int j2)&#123; //求前序序列为pre[i1...j1]、中序序列为in[i2...j2]的根节点 if(j1-i1 &lt; 0)&#123; return null; &#125; TreeNode root = new TreeNode(pre[i1]); int i; for( i = i2;i&lt;=j2;i++)&#123; if(in[i] == root.val)&#123; break; &#125; &#125; int leftCnt = i-i2;//计算左子树的元素个数 //退出循环时，说明in[i]==root.val(也就是pre[in])，此时i的指向就是中序遍历中左右子树的分界点 root.left = reConstructBinaryTree(pre,in,i1+1,i1+leftCnt,i2,i-1); root.right = reConstructBinaryTree(pre,in,i1+1+leftCnt,j1,i+1,j2); return root; &#125;&#125; 题3 【待改进】旋转数组的最小数字此题之前直接用暴力方法做的，O（n）做的，显然不符合题目考察本意。 题4 数组中只出现一次的数字没什么思路，用HashMap解决的。 1234567891011121314151617181920import java.util.HashMap;import java.util.Iterator;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; HashMap &lt;Integer,Integer&gt; map= new HashMap&lt;&gt;(); for(int i=0;i&lt;array.length;i++)&#123; if(map.containsKey(array[i]))&#123; map.remove(array[i]); &#125; else&#123; map.put(array[i],1); &#125; &#125; //这里要注意！！！！ Iterator &lt;Integer&gt; iterator = map.keySet().iterator(); num1[0]=iterator.next(); num2[0]=iterator.next(); &#125;&#125; 复习点： map.containsKey() 获取set的迭代器 map.keySet().iterator() 20200511 晴题1 【待改进】 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 一开始没啥想法，只能想到最直观的做法： 用两个ArrayList对象分别保存奇数和偶数，然后合并。 时间复杂度：两次循环都是O(n)级别 空间复杂度： 奇数和偶数两个ArrayList占用的空间大小是 O(n) 12345678910111213141516171819202122//最直观的思路，能AC但是不推荐！！！import java.util.ArrayList;public class Solution &#123; public void reOrderArray(int [] array) &#123; ArrayList &lt;Integer&gt; ji = new ArrayList&lt;&gt;(); ArrayList &lt;Integer&gt; ou = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;array.length; i++)&#123; if(array[i]%2==0)&#123; ou.add(array[i]); &#125;else&#123; ji.add(array[i]); &#125; &#125; for(int i=0;i&lt;array.length;i++)&#123; if(i&lt;ji.size())&#123; array[i]=ji.get(i); &#125;else&#123; array[i]=ou.get(i-ji.size()); &#125; &#125; &#125;&#125; 此实现的不足： 代码效率: 这里没必要用ArrayList，Integer的占用空间比int大，毕竟它是一个对象，有对象头等数据。 如果用int[]的话就分配。 编程规范：给“奇数”、“偶数”变量起名的单词： odd number （奇数）， even number.（偶数）。 1234567891011121314151617181920//对上述直观思想的代码改进，效率没有质的提升public class Solution &#123; public void reOrderArray(int [] array) &#123; int res[] = new int[array.length]; int current=0; for(int i = 0;i&lt;array.length; i++)&#123; if(array[i]%2==1)&#123; res[current++] = array[i]; &#125; &#125; for(int i = 0;i&lt;array.length; i++)&#123; if(array[i]%2==0)&#123; res[current++] = array[i]; &#125; &#125; for(int i=0;i&lt;res.length;i++)&#123; array[i]=res[i]; //这里我直接写array=res竟然不行，不解。。 &#125; &#125;&#125; 其实对这种解法还是不太满意，写了这么多只是为了记录思考过程。 我觉得，这道题主要考察的是原地数组元素的交换，开辟新的数组似乎不太合理。 Leetcode相似题:调整数组顺序使奇数位于偶数前面这道题题目是一样的，但是这题中不限制奇数内部、偶数内部的相对顺序。 这题和快排的partition操作类似。 看着很简单， 不过我做的时候经常忽略了边界条件，代码参考了Leetcode题解 12345678910111213class Solution &#123; public int[] exchange(int[] nums) &#123; int i = 0, j = nums.length - 1, tmp; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; (nums[i] &amp; 1) == 1) i++; //判断偶数用位运算提高效率 while(i &lt; j &amp;&amp; (nums[j] &amp; 1) == 0) j--; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; return nums; &#125;&#125; 20200510 晴题1【待熟练】树的子结构123456789101112131415public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root2==null || root1 ==null)&#123; //题目要求的“空树不是任意一个树的子结构”的逻辑在这里完成 return false; &#125; return isSubTree(root1,root2) || HasSubtree(root1.left,root2)|| HasSubtree(root1.right,root2); &#125; public boolean isSubTree(TreeNode r1,TreeNode r2)&#123; if(r2==null) return true; if(r1==null || r1.val!=r2.val) return false; return isSubTree(r1.left,r2.left) &amp;&amp; isSubTree(r1.right,r2.right); &#125;&#125; 此解法参考题解。 下次复习不妨再来做一下吧！https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/ 题2【待改进】二进制中1的个数典型的位运算的题目，记得很久以前做这题，思路是把十进制辗转相除得到二进制的同时计算1的个数，现在想想真是too young。 解决这题的核心就在于： &amp;和&gt;&gt;这两个位运算符的应用。 当我写完自信满满提交了之后，却发现错了！！ 123456789101112131415public class Solution &#123; public int NumberOf1(int n) &#123; int res = 0; while(n!=0)&#123; res = res + (n&amp;1); ////n&amp;1表示n的二进制表示的最后一位是1还是0 n = n &gt;&gt; 1; //n右移1位 &#125; return res; &#125;&#125;错误代码：不通过您的代码已保存运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。case通过率为0.00% 分析一下是为什么：因为负数在右移的时候左边最高位添加的是1，就死循环了。。 做了一点点改动后（对比一下代码找不同，你会发现确实是一点点），就通过了。 12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int res = 0; while(n!=0)&#123; res = res + (n&amp;1); ////n&amp;1表示n的二进制表示的最后一位是1还是0 n = n &gt;&gt;&gt; 1; //n逻辑右移1位 &#125; return res; &#125;&#125; 参考了逻辑右移和算术右移。 这种做法其实有点剑走偏锋的意思，剑指offer介绍的差不多的方法是n不变，flag初始化为1，不断左移flag，计算n&amp;flag来确定每一位是0还是1（思路是一模一样的，有点“运动的相对性”的意思）。不难发现，对于java来说，int是4个字节，32位，这种做法要循环的次数是32次。 书中还介绍了一种循环次数等于二进制数中数字1的个数的优化解法。 待理解 image-20200510021007308 20200508 晴题1 数值的整数次方思路上学期算法课中学过，使用分治法将时间复杂度降低到O(logn)，且采用此方法，空间复杂度也会是O(logn)。 这次用的是快速幂算法，时间复杂度是O(logn)，空间复杂度是O(1)。 接下来介绍一下快速幂的思想： 比如说我们要计算 3的14次方，即base=3,exponent=14,可以这样算： 14的二进制表示是1110， 1110的倒数第一位是0，且此位的权重是2^0=1，则代表了0X3^1 1110的倒数第二位是1，且此位的权重是2^1=2，则代表了1X3^2 1110的倒数第三位是1，且此位的权重是2^2=4，则代表了1X3^4 1110的倒数第四位是1，且此位的权重是2^3=8，则代表了1X3^8 3^14 = (3^2)X(3^4)X(3^8)，我们可以用迭代的方式结合位运算进行快速幂计算。 1234567891011121314151617181920212223242526public class Solution &#123; public double Power(double base, int exponent) &#123; if(exponent&gt;0) return postive(base,exponent); else if(exponent==0) return 1; else return 1/postive(base,-exponent); &#125; public static double postive(double base, int exponent) &#123; int last = 0 ; //末位是0还是1 double res = 1; double temp = base; while(exponent!=0)&#123; last = 1 &amp; exponent; //结果是exponent这个数二进制表示的最低位（1或者0） if(last == 1)&#123; res = res * temp; &#125; exponent = exponent&gt;&gt;1; temp *= temp; &#125; return res; &#125;&#125; 20200507 晴最近停刷了几天题，今天是返校后第一天刷题，愧对“飘风不终朝，骤雨不终日”啊。以后每天都刷，务必在秋招前把牛客网上剑指offer和leetcode精选题刷完。。 题1两个链表的第一个公共节点&lt;%blockquote%&gt;输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;%endblock%&gt; 思路没啥好思路，暴力解决，复杂度O(m*n)，m和n分别为两条链表的长度 1234567891011121314151617public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode p1 = pHead1; ListNode p2 = pHead2; while(p1!=null)&#123; p2 = pHead2; while(p2!=null)&#123; if(p1==p2) return p1; p2=p2.next; &#125; p1=p1.next; &#125; return null; &#125;&#125; 巧妙地利用快慢指针。 改进后的思路：先计算两条链表的长度，然后长链表的指针先走diff步(diff为链表的长度差)，然后两个指针一起走，直到发现相等停止。 20200428 晴题1字符串的排列提示记f(str)方法返回一个ArrayList， 即返回字符串str的所有排列。 求f(str)时，确定第一个字符str[i]（for循环），递归调用f(str-str[i])（表示从str字符串中剔除str[i]字符后获得的子串）以获取后面的字符的排列，for循环内部再写一个foreach遍历子串的所有排列情况，拼接后加入ArrayList，返回。 思路输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 可以用递归解决。先通过演算示例“求字符串s=“abc”的所有排列”，来理解本题中如何使用递归： 分析：“abc”的排列包括了： ( 结果abc , acb ,bac , bca, cab , cba ) a + “bc”的排列 结果：abc , acb “bc”的排列包括了 b+”c”的排列 结果：bc “bc”的排列包括了 c+”b”的排列 结果：cb b + “ac”的排列 结果：bac , bca “ac”的排列包括了 a+”c”的排列 结果：ac “ac”的排列包括了 c+”a”的排列 结果：ca c + “ab”的排列 结果： cab , cba “ab”的排列包括了 a+”b”的排列 结果： ab “ab”的排列包括了 b+”a”的排列 结果： ba 通过上述的分析，可以看到我们把原问题分解成了若干个(实际上是s.length()个，如果不考虑重复字符的话，下文会考虑到有重复的情况)子问题，通过求解子问题并合并子问题的解，就得到原问题的解，其实采用了分治法的思想。 字符串s可以由s[i]和s-s[i]拼接而成，（0&lt;=i&lt;s.length()，其中s[i]表示字符串s中的某个字符，s-s[i]表示字符串s截取掉字符s[i]后生成的字符串）。 如上例“求abc的所有排列”这个原问题的其中一个子问题是求a + “bc”的排列，可以理解为：abc排列结果的第一位确定下来是a，后面2位的排列待定，其实它是长度比原字符串小1的子串（也就是bc，因为a已经排列在第一位了，所以把已经确定位置的字符a从原字符串abc中剔除，得到bc）的排列结果，同理地，求字符串bc这个问题又可以分解成 b+”c”的排列和 c+”b”的排列两个子问题。 我们知道，在分治法的思想中，当子问题规模较大时继续采用递归求解子问题，当子问题规模变小时直接求解，以免持续递归无法终止。在本例中，递归的终止条件就是当求解的子问题的字符串长度为1时，只有其自身一种排列结果，直接返回，无需继续递归。 写代码之前，还需要关注到题目中的两个细节： 排列结果按字典序打印 比如说如果要求字符串”cba”的排列结果，我们可以先对字符串内部的字符排序，变成“abc”，再求结果。 可能有重复字符 比如说要求字符串”aab”的排列结果，按照上述案例的思路分析，如果分解成三个问题：a +”ab”的排列，a+”ab”的排列，b+“aa”的排列，可以发现第一种情况和第二种情况重复了，所以为避免重复，实际上在这只需要分解成两个子问题：a +”ab”的排列，b+“aa”的排列。在编程的时候，用一个HashSet保存第一个字符，来保证不重复。 说了这么多，接下来看看代码怎么写吧。 f(str)=str[0]f(str-)+str[1]f(str-) str- 代码123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.Arrays;import java.util.HashSet;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; if(str == null) return new ArrayList&lt;&gt;(); char [] chars = str.toCharArray(); Arrays.sort(chars); return f(String.valueOf(chars)); &#125; /**此函数用于求字符串str的所有排列 */ public ArrayList &lt;String&gt; f(String str)&#123; ArrayList &lt;String&gt; list = new ArrayList &lt;&gt;(); if(str.length() == 1)&#123; list.add(str); return list; &#125; HashSet &lt;Character&gt; set = new HashSet(); for(int i=0; i&lt; str.length();i++)&#123; boolean success = set.add(str.charAt(i));//表示当前字符是否第一次出现 if(success)&#123; //排列的第一位已确定为str.charAt(i)，递归获得后几位，剔除已确定的第一位的子串的所有排列 ArrayList &lt;String&gt; subList = f(str.substring(0,i)+str.substring(i+1)); for(String sub : subList)&#123; list.add(str.charAt(i)+sub); &#125; &#125; &#125; return list; &#125;&#125; 知识点 String和char[]的转化 char [] chars = str.toCharArray() String.valueOf(chars) boolean success = set.add(str.charAt(i)); set是HashSet类型，插入成功（插入前不存在这个元素），set.add()的返回值才为true substring的用法 str.substring(0,i) 包含str[0]~~str[i-1]，不包含str[i] str.substring(i+1)，包含str[i+1]~~str的末尾 题2 变态跳台阶 &lt;%blockquote%&gt; 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 &lt;%endblockquote%&gt; 提示dp====&gt;数学归纳 思路回顾一下 “跳台阶”这题。 &lt;%blockquote%&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 &lt;%endblockquote%&gt; 一开始不好理解，先按照题意举几个例子： 当n=1， 1种跳法（直接跳1） 当n=2, 2种跳法，（先跳1，再跳1）+(直接跳2级) 当n=3， 第一步先跳1级，剩下2级，有2种跳法（查看上面当n=2的情况=2） 第一步先跳2级，剩下1级，有1种跳法（查上面当n=1的情况=1） 所以说，当n=3，总共有2+1=3种 总结出一个通用的式子：记n阶台阶的跳法有f(n)种，都可以有两种做法： 先跳1级，剩下了n-1级, 【f(n-1)种跳法】 而剩下的n-1级的跳法又有以下两种情况 先跳1级，再跳n-2级 先跳2级，再跳n-3级 先跳2级，剩下了n-2级， 【f(n-2)种跳法】 ​ …………………… 所以f(n)=f(n-1)+f(n-2)，其实这个模型符合斐波那契数列。 回到这题。 先写几个找找规律 当 n = 0, 0种 当 n = 1 ,跳1级 1种 当 n = 2 2种 先跳1，剩1级，1种 先跳2，剩0级，1种 当 n =3 结果：4种 先跳1级，剩2级， f(2) = 2种 先跳2级, 剩1级， f(1) = 1种 先跳3级, 剩0级， 1种 当 n =4 结果：8种 先跳1级，剩3级，f(3) =4种 先跳2级，剩2级，f(2) = 2种 先跳3级，剩1级， f(1) = 1种 先跳4级，剩0级， 1种 可以看出，如下规律 f(n) = f(n-1)+f(n-2) +…f(1)+1，为了让式子看起来和谐一点，我们可以让f(0)=1,则式子可以表示成f(n) = f(n-1)+f(n-2) +…f(1)+f(0)。 不难发现 ，f(n-1) = f(n-2)+f(n-3)+….f(0)，所以f(n) = 2 *f(n-1) 代码123456789101112131415public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=2) return target; int dp[]=new int[target]; // dp[i]表示剩下i级时的跳法 dp[0] = 1; //默认为1，可以表示剩0级的时候有1种跳法 dp[1] = 1; dp[2] = 2; for(int i=3;i&lt;target;i++)&#123; dp[i] = 2*dp[i-1]; &#125; return 2*dp[target-1]; &#125;&#125; 数学归纳后的代码: 1234567public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=0) return target; return (int)Math.pow(2,target-1); &#125;&#125; 反思有了“跳台阶”这题的基础，其实很容易想到上述的归纳。 最开始做这题可能会想到递归–&gt;然后发现递归会多次重复计算，可以动态规划—&gt;贪心–&gt;而又发现这题又可以用公式归纳出来，直接求解。 题3 左旋转字符串思路根据定义求解，一步一个脚印 1234567891011121314public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str==null || str.length()==0 || n&lt;=0) return str; while(n!=0)&#123; char first = str.charAt(0); String sub = str.substring(1); //截取字符串 str = sub+first; n--; &#125; return str; &#125;&#125; 改进后：一步到位 12345678public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str==null || str.length()==0 || n&lt;=0) return str; n = n % str.length(); //把这句注释竟然也可以。 return str.substring(n) + str.substring(0,n); &#125;&#125; 题4 构建乘积数组思路一开始没什么思路。先写一个暴力解决，观察哪里有改进的空间。 12345678910111213141516import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; //暴力解法O(n^2) int [] B = new int [A.length]; for(int i = 0;i &lt; A.length ;i++)&#123; int mul = 1; for(int j = 0; j&lt; A.length;j++ )&#123; if(j!=i) mul*=A[j]; &#125; B[i] = mul; &#125; return B; &#125;&#125; 这种做法完全是使用定义做的，比如说当A[n]=5，则B[3] = A[0]XA[1]XA[2]XA[4]，B[4]=A[0]XA[1]XA[2]XA[3]，可以看到计算B[3]和B[4]时有重叠计算的部分（A[0]XA[1]XA[2]）。要想优化，我们就看看是否可以只计算一次重叠的部分。 确实有这样的优化方法，可以将时间复杂度从O(n^2)优化成O(n)。 image-20200428213947621 上图参考了《剑指Offer》，基于此思路的改进代码如下： 12345678910111213141516171819202122232425import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int left [] = new int [A.length]; //左下角计算的中间结果(含对角线) int right[] = new int [A.length]; //右下角计算的中间结果(含对角线) int B[] = new int [A.length]; //返回结果 for(int i = 0; i &lt; A.length; i++)&#123; if(i==0)&#123; left[i]=1; &#125; else&#123; left[i] = left[i-1] * A[i-1]; &#125; &#125; for(int i = A.length-1; i &gt;=0 ; i--)&#123; if(i==A.length-1)&#123; right[i] = 1; &#125;else&#123; right[i] = right[i+1] * A[i+1]; &#125; B[i] = left [i] *right [i]; //在这个循环就可以直接出B[i]，不用再重新写一个for循环。 &#125; return B; &#125;&#125; 进一步改进 进一步观察，会发现其实没必要设置left、right这两个辅助数组，可以直接在B[]数组上操作。 1234567891011121314151617import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int B[] = new int [A.length]; //返回结果 B[0] = 1; for(int i = 1; i &lt; A.length; i++)&#123; //计算 B[i]左边的乘积（含对角线） B[i] = B[i-1] * A[i-1]; &#125; int temp = 1; //temp记录B[i]右边的乘积 for(int i = A.length-2; i &gt;=0 ; i--)&#123; temp = temp * A[i+1]; B[i] *= temp; &#125; return B; &#125;&#125; 题5 和为S的连续正数序列一开始没啥思路，暴力解决。 123456789101112131415161718192021222324import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; arrayList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); //i=sum是想当然的，可以优化 for(int i = sum; i&gt;=2; i--)&#123; //设i个连续数字，x,x+1,x+2.....x+(i-1)的和为sum， int temp = sum; //可以利用等差数列公式，不用这么麻烦 for(int j = 0; j&lt;i ;j++)&#123; //减去每个数字的常数项，以求出x的取值 temp -= j; // temp-0-1-2-...(i-1)，可以直接算出temp - (i/2)*(i-1),不过写的时候要写temp - i*(i-1)/2,否则i为奇数时就不对了。 &#125; int x = temp/i; if(temp % i == 0 &amp;&amp; x&gt;0)&#123; //temp / i的结果必须是整数，且题目要求是正数 ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j = 0 ; j&lt;i ;j++)&#123; //逐个将x,x+1....x+(i-1)加入list list.add(x+j); &#125; arrayList.add(list); &#125; &#125; return arrayList; &#125; &#125; 使用数学知识（等差数列求和公式变形），对上面的代码改进： 12345678910111213141516171819import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; arrayList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i = (int) Math.sqrt(2 * sum) ; i&gt;=2; i--)&#123; //i表示连续数字的个数 int temp = sum - i*(i-1)/2; //减去常数项 if(temp % i == 0 &amp;&amp; temp/i&gt;0)&#123; int x = temp/i; ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j = 0 ; j&lt;i ;j++)&#123; list.add(x+j); &#125; arrayList.add(list); &#125; &#125; return arrayList; &#125; &#125; 这样做，复杂度变成了O(根号s) 还有一个思路是 双指针，控制滑动窗口，可以试试看。 题6 【待改进-贪心】 剪绳子最近递归的题目做的多，思路挺顺的了，这题没想多久，自然而然就想到了。 12345678910111213141516171819202122public class Solution &#123; public int cutRope(int target) &#123; int max =0; for(int m =2 ;m&lt;=target; m++)&#123; //剪几刀 if(cut(target,m) &gt;max) max = cut(target,m); &#125; return max; &#125; //计算n段绳子剪去m段的最大值 public int cut(int n,int m)&#123; //剪下长度为n的绳子，剪m段,每段最少为1 if(m == 0)&#123; //m=0表示不需要剪了，直接返回 return 1; //这里要是return 0，做乘法后结果就都是0了，不对 &#125; int max = 0; for(int i =1 ;i&lt;= n-(m-1);i++)&#123; //第一刀剪掉i，i最少为1，最多为n-(m-1)以确保后面剩余的m-1刀每次都能剪1 if(i * cut(n-i,m-1) &gt;max) max = i * cut(n-i,m-1); &#125; return max; //返回 i* 的最大值 &#125;&#125; 截至今日结束，进度： 40/67 20200427 晴题1 按之字形顺序打印二叉树思路这题和昨天做的”把二叉树打印成多行“很像。都是用层序遍历的思路，区别就在于当访问行数是偶数，要将该行元素的ArrayList反转。 细节 Collections.reverse(arrayList); import java.util.Collections; arrayList.add() ,queue.offer()。一开始没注意写了arrayList.offer()报错了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;import java.util.Collections;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; if(pRoot == null)&#123; return new ArrayList&lt;&gt;(); &#125; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; rows = new ArrayList&lt;&gt;(); Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(pRoot); ArrayList&lt;Integer&gt; row = new ArrayList&lt;&gt;(); int nextLevelNum = 1; //记录还要访问几个元素可以到下一层，即每层元素的个数，初始化是1 boolean needReverse = false; //记录当前行是否需要反转 while(!queue.isEmpty())&#123; //队首节点出队列 TreeNode node = queue.poll(); //将节点值加入row row.add(node.val); if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; nextLevelNum--; if(nextLevelNum == 0)&#123;//说明该层访问完了 if(needReverse)&#123; Collections.reverse(row); &#125; rows.add(row); row = new ArrayList&lt;&gt;(); //重新设定nextLevelNum和needReverse nextLevelNum = queue.size(); needReverse = !needReverse; &#125; &#125; return rows; &#125;&#125; 顺时针打印矩阵参考 题2 平衡二叉树思路我的思路就是根据平衡二叉树的定义解决：一棵树是平衡二叉树，则其左右子树高度差不大于1且左右子树都是平衡二叉树。这种做法是最直观的，但是效率一般（不过也能AC）。 代码123456789101112131415public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if(root &#x3D;&#x3D; null) return true; int balanceFactor &#x3D; treeHeight(root.left) - treeHeight(root.right); return Math.abs(balanceFactor) &lt;&#x3D; 1 &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right); &#125; public int treeHeight(TreeNode node)&#123; if(node &#x3D;&#x3D; null) return 0; int leftHeight &#x3D; treeHeight(node.left); int rightHeight &#x3D; treeHeight(node.right); return Math.max(leftHeight,rightHeight)+1; &#125;&#125; 分析在计算每个节点的深度的时候，进行了多次的重复计算，这样计算的开销还是比较大的。（类比递归求斐波那契数列的重复计算） 又注意到实际上在计算树高时（上面的treeHeight方法）就要计算左右子树高度，这时候就可以判断是否平衡。 改进参考了博客。 核心：把求树的深度与判断树的平衡融合在一起。 改进思路就是在计算root高度的同时，就判断是否出现过不平衡的节点，使用一个成员变量isBalance存放结果（作为全局变量），一旦出现了不平衡节点，isBalance被置为false,则可以停止后续的递归计算。这样做效率比原思路好，只要调用一次treeHeight(root)即可。 12345678910111213141516171819public class Solution &#123; boolean isBalance; public boolean IsBalanced_Solution(TreeNode root) &#123; //当root=null，返回isBalance=true。 isBalance = true; //默认为true treeHeight(root); return isBalance; &#125; public int treeHeight(TreeNode node)&#123; if(node == null || isBalance == false) //如果isBalance已被置为false，可以直接返回，不用再判断了 return 0; int leftHeight = treeHeight(node.left); int rightHeight = treeHeight(node.right); if(Math.abs(leftHeight-rightHeight) &gt; 1)&#123; //判断root是否不平衡 isBalance = false; &#125; return Math.max(leftHeight,rightHeight)+1; &#125;&#125; 题3矩形覆盖思路其实该模型符合斐波那契数列。 f(n) = f(n-1)+f(n-2)， n=0的时候 0种 n = 1 的时候 只能横着覆盖，一种 n = 2 的时候 可以横着和竖着覆盖，两种 n = 3 的时候 第三级竖着覆盖，用了一级，剩下 n = 2，有两种覆盖方法 第三级横着覆盖，用了两级，剩下 n = 1，有一种覆盖方法 总共有 3 种 n = 4 的时候 第 4 级竖着覆盖，用了一级，剩下 n = 3，有三种覆盖方法 第 4 级横着覆盖，用了两级，剩下 n = 2，有两种覆盖方法 总共有 5 种方法 n = n 的时候 第 n 级竖着覆盖，用了一级，剩下 n = n - 1，所以关注第 n - 1 种有几种覆盖方法 第 n 级横着覆盖，用了两级，剩下 n = n - 2，所以关注第 n - 2 种有几种覆盖方法 总和为两种情况的总和 代码123456789101112public class Solution &#123; public int RectCover(int target) &#123; if(target == 0)&#123; return 0; &#125;else if(target == 1)&#123; return 1; &#125;else if(target == 2)&#123; return 2; &#125; return RectCover(target-1) + RectCover(target-2); &#125;&#125; 第n级横着放 改进递归做会有多次的重复计算，可以考虑空间换时间，动态规划求斐波那契数列。 此处略。 ## 【待解决】题4二进制中1的个数思路题目要求是求整数的补码中的1的个数。 我们知道，对于正数，其补码就是原码。如十进制数9的补码=10的原码=0，1001（首位0是符号位）。 而十进制数-9的原码=1，1001（首位1是符号位），其补码是：1，0111 我一开始想的是先算出补码的二进制表示，再计算1的个数，这种效率太低了，要用位运算，这块知识有些忘了，还要再复习一下。 ## 【待解决】题4 数组中只出现一次的数字思路位运算。 位运算异或（XOR）的特点： 0 ^ 0 = 0 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 1 = 1 a ^ a = 0 ,因为a的二进制^a的二进制每一位异或结果都是0。 a ^ 0 = a , 因为a的二进制的每一位与0的异或结果都是本身 结合上述两点，a ^ b ^ a = b 20200426 晴题1 把二叉树打印成多行思路显然，此题是层序遍历的应用。二叉树的层序遍历很简单，使用队列就能完成，本题要在层序遍历的基础上使用一个变量，来记录下一层的元素个数，每当遍历完了一层，就更新这个值，且换行。 提示 题目给的方法返回值是 ArrayList&lt;ArrayList &gt; ，一开始没反应过来，后来仔细一想，是每行的元素单独保存在一个ArrayList里，再返回所有行的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Queue;import java.util.LinkedList;import java.util.ArrayList;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; if(pRoot==null) return new ArrayList &lt;&gt;(); int nextLevelNum = 1; //记录还要访问几个元素才到下一层,初始值为1,因为第一层肯定只有根节点一个元素 Queue &lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(pRoot); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; rows = new ArrayList&lt;&gt;(); ArrayList &lt;Integer&gt; row = new ArrayList&lt;&gt;(); while(!queue.isEmpty())&#123; TreeNode node = queue.poll();//当前队头节点出队列 row.add(node.val); //将节点的元素值加入到row列表 if(node.left!=null)&#123; //并将其非空子节点加入队列 queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; nextLevelNum--; //每访问完了一个节点，nextLevelNum就减1 if(nextLevelNum == 0)&#123; //说明这一层已经访问完了，要重新设置它的取值,它的取值其实就是当前队列的元素个数 nextLevelNum = queue.size(); rows.add(row); row = new ArrayList&lt;&gt;(); &#125; &#125; return rows; &#125; &#125; 细节： 队列操作的API、导入所在包，nextLevelNum这个变量是本题精髓！ if(pRoot==null) return new ArrayList &lt;&gt;(); 一开始写的return null，无法通过！ &lt;!--￼59--&gt; 题3 数组中重复的数字思路HashSet 时间复杂度O(n) 空间复杂度O(n) 参考别人的：重排数组 ：时间复杂度O(n)，空间复杂度O(1)。 12345678910111213141516171819202122232425public class Solution数组中重复的数字 &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers == null)&#123; return false; &#125; HashSet &lt;Integer&gt; set = new HashSet &lt;&gt;(); for (int i = 0; i&lt;numbers.length ; i++)&#123; if(!set.contains(numbers[i]))&#123; set.add(numbers[i]); &#125;else&#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false; &#125;&#125; 【待解决】题4 数组中的逆序对思路 暴力求解：从第一个元素开始，判断后面比它小的元素的个数 O(n^2)，不出所料，运行超时，通过50%的用例。 【待学习】提示：归并的改进 20200422题1 二叉搜索树的第k个结点做题前思路给定一棵二叉搜索树，请找出其中的第k小的结点。根据BST中序遍历结果是升序的这一性质，可以中序遍历，直到遍历到第k个结点。 按照此思路的代码：12345678910111213141516171819202122//中序递归，成功ACpublic class Solution &#123; int num; //num表示当前中序遍历已经访问了几个元素 TreeNode node; //node存放结果 TreeNode KthNode(TreeNode pRoot, int k) &#123; inorder(pRoot,k); return this.node; &#125; void inorder(TreeNode node,int k)&#123; if(node==null)&#123; return; &#125; inorder(node.left,k); num++; if(num==k)&#123; this.node=node; return; //结束后续的访问 &#125; inorder(node.right,k); &#125;&#125; 分析：就算找到了Kth结点也会遍历完整个BST。时间复杂度是O(N) 改进：可以考虑非递归实现中序遍历，这样就能在找到Kth结点后结束遍历。 【待解决】题2 字符流中第一个不重复的字符做题前思路hashmap 知识点 LinkedHashMap和HashMap的差别 LinkedHashMap Hashmap遍历方法 题3 统计一个数字在排序数组中出现的次数做题前思路 法1：二分查找定位该数字，再找左边和右边相等的元素个数。 多种方法改进参考文章 最后采用的方法：因为数组中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。 123456789101112131415161718192021222324252627282930313233/** * @Created by hfq on 2020/4/23 * @used to: */public class Solution数字在排序数组中出现的次数 &#123; public int GetNumberOfK(int [] array , int k) &#123; return BinarySearch(array,(float)(k+0.5)) - BinarySearch(array,(float)(k-0.5)); &#125; //返回目标t插入array的位置 public static int BinarySearch(int [] array , float t)&#123; int i = 0; int j = array.length-1; int mid = 0; while(i&lt;=j)&#123; //&lt;= 等号不可遗漏！！ mid = j+(i-j)/2; if(array[mid] &gt; t)&#123; //在左边查找 j = mid-1; &#125;else if(array[mid] &lt; t)&#123; //在右边查找 i = mid+1; &#125;else&#123; //实际上不可能发生，可以和上面的else if合并 &#125; &#125; return i; //array[mid]在array[i]和array[j]中添加 &#125; public static void main(String[] args) &#123;// int [] a = &#123;3,3,3,3&#125;; int [] a = &#123;3,3,3,3&#125;; System.out.println(BinarySearch(a, (float) 2.5)); System.out.println(BinarySearch(a, (float) 3.5)); &#125;&#125; 分析：这种做法在各种情况下效率都比较高。 当数组是：[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]，如果采用法1，效率退化成O(n),而这种方法时间复杂度还是O(lgn)级别的 20200421题1：栈的压入、弹出序列代码：1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA==null||pushA.length==0) return true; int stack [] = new int[pushA.length]; int size = 0; int pushIndex=0; stack[size++] = pushA[pushIndex++]; int current = 0; while(pushIndex&lt;pushA.length) &#123; if(stack[size-1]!=popA[current]) &#123; stack[size++] = pushA[pushIndex++]; &#125;else&#123; size--; current++; &#125; &#125; while (size!=0)&#123; if(stack[size-1]!=popA[current]) &#123; return false; &#125; else &#123; size--; current++; &#125; &#125; if(size==0) return true; return false; &#125;&#125; 解析：以输入{1,2,3,4,5}，{4,5,3,2,1}为例。 借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 我的代码没有用JDK提供的Stack，而是用一个数组+size模拟栈。 题2：二叉树的下一个结点代码1234567891011121314151617181920public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; TreeLinkNode successor = null; //表示后续结点，保存返回结果 //当这个结点有右子树，那么其后续结点必然在其右子树中的最小的元素 if(pNode.right!=null)&#123; successor = pNode.right; while(successor.left!=null)&#123; successor = successor.left; //一直向左走找最小的元素 &#125; &#125;else if(pNode.next != null)&#123; //没有右子树但是有根节点 successor = pNode; while(successor.next != null &amp;&amp; successor == successor.next.right)&#123; successor = successor.next; //当此结点始终是其父节点的右子树的时候，逐级找父节点 &#125; successor = successor.next; &#125; return successor; &#125;&#125; 解析：求二叉树某一结点的后续结点。 image-20200421205013742 根据这个pNode结点的状态，分为三种情况求解: pNode存在右子树，那么其后续结点必然在其右子树中。 这是由中序遍历的定义决定的：若某节点存在右子树，那么访问完这个结点后访问的下一个结点必然是右子树中的某个结点。 返回结果是 pNode.right.left.left.left…. pNode不存在右子树，但存在父节点，那么其后续结点是其祖父结点，或者是null 既不存在右子树，也不存在父节点，返回null 提示： 可以借助二叉树的一种特殊情况——二叉搜索树思考这题，上述代码的注释就是这样做的，表面看我们考虑的是特殊情况，但是实际上这样做对二叉树具有普遍性。 另外提一下，这道题目有点坑的地方是：包含指向父结点的指针的变量名是next，不是parent，注意一下。 【待解决】题3:顺时针打印矩阵被这道题虐了很久。。 一直会忽略某些情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hfq;import java.util.ArrayList;public class Main &#123; public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList &lt;Integer&gt; list = new ArrayList&lt;&gt;(); addElementToList(matrix,0,matrix.length-1,0,matrix[0].length-1,list); return list; &#125; public static void addElementToList(int [][] matrix,int rowsMin,int rowsMax,int colsMin,int colsMax,ArrayList list) &#123; if(colsMax&lt;0 &amp;&amp; rowsMax&lt;0)&#123; return; &#125; for(int i = colsMin; i&lt;=colsMax ; i++)&#123; //从左往右 list.add(matrix[rowsMin][i]); // System.out.println(matrix[rowsMin][i]); &#125; if(rowsMax&gt;rowsMin)&#123; for(int i = rowsMin+1; i&lt;=rowsMax ; i++)&#123; //从上往下// System.out.println(\"i=\"+i+\",colsMax\"+colsMax); list.add(matrix[i][colsMax]); //System.out.println(matrix[i][colsMax]); &#125; &#125; if(colsMax-1&gt;colsMin)&#123; for(int i = colsMax-1; i&gt;=colsMin ; i--)&#123; //从右往左 list.add(matrix[rowsMax][i]); // System.out.println(matrix[rowsMax][i]); &#125; &#125; if(colsMax-colsMin&gt;=1 &amp;&amp; colsMax &gt; colsMin )&#123; for(int i = rowsMax-1; i&gt;=rowsMin+1 ; i--)&#123; //从下往上 list.add(matrix[i][colsMin]); // System.out.println(matrix[i][colsMin]); &#125; &#125; addElementToList(matrix,rowsMin+1,rowsMax-1,colsMin+1,colsMax-1,list); &#125; public static void main(String[] args) &#123;// int a [][] =&#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;&#125;;// int a [][] =&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;; int a [][] =&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;,&#123;7,8&#125;,&#123;9,10&#125;&#125;; ArrayList&lt;Integer&gt; integers = printMatrix(a); for(Integer integer:integers)&#123; System.out.printf(integer+\",\"); &#125; &#125;&#125; 题4:包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。 思路一开始我的想法很简单，用一个使用一个变量记录当前的最小元素，如果新压入栈的元素更小，就更新它。 但是仔细一想，这种做法有一个问题，假如记录的最小元素出栈了，就没办法以O(1）的时间复杂度获取新的最小元素了，所以在保存最小元素的同时，有必要保存最小元素出栈后次要小的元素，同理，也要保存第三小的元素…. 所以，要用一个辅助栈来保存当前的最小元素以及之前的的最小元素，栈顶就是当前栈的最小元素，栈顶元素的下一个元素就是这个元素出栈后的新的最小元素。 每次压栈时，如果压入的元素小于当前最小元素，则也将其压入辅助栈，否则，则将上一个最小元素压入辅助栈。 每次出栈时，弹出元素的同时也弹出辅助栈的元素。 知识点复习Stack的API peek() size() pop() push() 代码12345678910111213141516171819202122232425262728import java.util.Stack;public class Solution &#123; public Stack &lt;Integer&gt; stack = new Stack&lt;&gt;(); //数据栈 public Stack &lt;Integer&gt; minStack = new Stack&lt;&gt;();; //辅助栈 public void push(int node) &#123; stack.push(node); if(stack.size()==1)&#123; //现在是1，说明压栈前是0。 minStack.push(node); &#125;else&#123; minStack.push(node&lt;minStack.peek() ? node : minStack.peek()); &#125; &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125; 题解关键字 ：最小值辅助栈 题5 把数组排成最小的数没啥思路，借鉴了网上的解法，觉得很妙。 关键字：自定义比较大小的方法。 提示转成字符串，自定义比较器后排序 知识点复习 int类型转成String类型 String.valueOf(i) Integer.toString(i) i+”” 比较字符串大小 拼接字符串 （StringBuilder） sb.append() sb.toString() 代码细节 Arrays.sort() import java.util.Arrays; Comparator import java.util.Comparator; 123456new Comparator&lt;String&gt;() &#123; @Override public int compare(String str1, String str2) &#123; //3 12 312 123 return 0; &#125;&#125; 代码12345678910111213141516171819202122232425262728293031/** * https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993 * @Created by hfq on 2020/4/22 * @used to: * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数， * 打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。 */public class Solution把数组排成最小的数 &#123; public static String PrintMinNumber(int [] numbers) &#123; StringBuilder sb = new StringBuilder(); String numString [] = new String[numbers.length]; for (int i=0; i&lt;numbers.length; i++)&#123; numString[i]=String.valueOf(numbers[i]); //将整数转成字符串 &#125; Arrays.sort(numString, new Comparator&lt;String&gt;() &#123; @Override public int compare(String str1, String str2) &#123; //3 12 312 123 return 0; &#125; &#125;); for (String str : numString)&#123; sb.append(str); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; int[]numbers=&#123;3,32,321&#125;; System.out.println(PrintMinNumber(numbers)); &#125;&#125; 进度：25题/67题。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://hfq123.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"《Head-First-设计模式》读书笔记charpter8","date":"2020-04-21T06:52:00.000Z","path":"2020/04/21/《Head-First-设计模式》读书笔记charpter8/","text":"本篇博客是《Head First 设计模式》第八章的读书笔记。 分享主题是设计模式中的 「模板方法模式(Template Method Pattern)」。 定义模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 具体应用场景从饮品店制作咖啡和茶的制作方法讲起，咖啡和茶的制作流程如下图所示。 咖啡和茶的制作流程 接下来用代码表示咖啡的制作过程： 12345678910111213141516171819202122232425/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的制作流程 */public class Coffee &#123; public void prepareRecipe()&#123; //冲泡咖啡 boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void brewCoffeeGrinds()&#123; System.out.println(\"Dripping Coffee through filter\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addSugarAndMilk()&#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125; 同样的，茶的制作过程代码如下： 123456789101112131415161718192021222324/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea &#123; public void prepareRecipe()&#123; //冲泡茶 boilWater(); steepTeaBag(); pourInCup(); addLemon(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void steepTeaBag()&#123; System.out.println(\"Steeping the tea\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addLemon()&#123; System.out.println(\"Adding lemon\"); &#125;&#125; 可以发现，boilWater()和pourInCup()方法的代码重复了。究其原因，这是因为咖啡和茶的制作流程大致上一样，它们的制作过程都可以用下图的算法表示，1、3步骤是一样的，2、4步骤有差异，所以我们想到用继承的方法重用1、3步骤的代码，将实现1、3步骤的方法抽取到一个父类中，而2、4步骤这两个有差异的步骤在咖啡子类和茶子类中实现。 制作咖啡和制作茶的相同和不同的步骤 基于此想法，我们设置一个咖啡因饮料的父类： 1234567891011121314151617181920212223/** * @Created by hfq on 2020/4/21 * @used to: 咖啡因饮料的父类，是一个抽象类 */abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); addCondiments(); &#125; void boilWater()&#123; //步骤1，共同的操作，由父类实现 System.out.println(\"Bolling water\"); &#125; abstract void brew(); //步骤2，冲泡，由于不同饮料实现有差异，由子类实现 void pourInCup()&#123; //步骤3，共同的操作，由父类实现 System.out.println(\"Pouring into cup\"); &#125; abstract void addCondiments(); //步骤4，添加调料，由于不同饮料实现有差异，由子类实现&#125; 现在咖啡子类和茶子类的代码就变成了： 12345678910111213141516171819202122232425262728293031/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的冲泡流程 */public class Coffee extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Dripping Coffee through filter\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125;/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Steeping the tea\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding Lemon\"); &#125;&#125; 这样，我们就完成了共同代码（prepareRecipe()、boilWater()、pourInCup()三个方法）的重用。其中，prepareRecipe()方法就叫做模板方法。它作为制作咖啡因饮料算法的模板，在这个模板中，每个步骤都被一个方法代表了，其中，制作不同的咖啡因饮料有共同的步骤：就是上文说的步骤1和步骤3，它们可以直接在父类中实现(分别对应于boilWater()和pourInCup()方法)。制作不同的咖啡因饮料也有不同的步骤：步骤2和步骤4，由于子类有不同的实现，所以父类中不实现，设置为抽象方法，由子类实现，这就是模板方法模式中说的“将一些步骤延迟到子类中”。 如果有新的制作流程一致的咖啡因饮料加入，只需要继承父类，并负责实现父类的抽象方法（表示制作步骤中不同的部分）。 UML图模板方法模式的UML建模图如下： 模板方法模式的UML建模图 使用钩子(Hook)在上例中引入一个新的需求：客户可以自行选择是否需要在饮料中加入调料（也就是选择是否执行制作饮料中的步骤4），这时模板方法的钩子就起作用了。 做法很简单：在模板方法中，加入判断，如果判断为真，则执行步骤4，修改后的模板方法类代码如下： 1234567891011121314abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); if(customerWantsCondimentsHook())&#123; addCondiments(); &#125; &#125; ...省略了相同的代码.... boolean customerWantsCondimentsHook()&#123; //这是一个钩子，子类可以选择是否覆盖 return true; &#125;&#125; 这样一来，在子类中可以覆盖customerWantsCondimentsHook()方法来自行选择是否需要执行步骤4，它还可以更灵活地实现钩子：比如接受用户的输入，据此判断是否需要执行该步骤。 在这里，钩子作为条件控制，影响了抽象类的算法流程。 好莱坞原则书中本章引入了一个新的设计原则，称为好莱坞原则： 好莱坞原则（Hollywood Principle）：别打电话给我们，有事我会打电话给你。 好莱坞原则和模板方法之间的连接比较明显，当我们设计模板方法模式时，我们告诉子类，不要调用我们，我们会调用你。让我们再看一下的咖啡因饮料的设计类图： 好莱坞原则和模板方法 Java API中的模板方法书中指出，模板方法模式很常见，因为对于创建框架来说，这个模式简直棒极了。由框架控制如何做事情，而由使用框架的人指定框架算法中的每个步骤的细节。另外，模板方法有多种实现，不一定看起来和上例讲述的设计一致。 书中给出三个java api中的模板方法示例： 类实现comparable接口后可以用Collections.sort Swing Applet 第一个示例归结于模板方法我觉得似乎有些牵强，后两个示例平时开发没使用过，不熟悉。所以讲讲另外一个比较熟悉的示例吧：Servlet类的service()方法就是一个模板方法，定义了算法骨架，doGet()、doPost()方法是这个算法骨架中的具体步骤，子类可以实现自己的doGet()方法和doPost()方法，这样做子类自己的doGet()、doPost()方法就”挂进”了父类service()方法这一模板方法。 与我们上文咖啡因饮料示例不同的是，子类具有不同实现的方法在父类是抽象的，子类必须实现，而Servlet中的doGet()和doPost()有默认实现。 Servlet中的模板方法 Servlet中的模板方法具体实现参考这里。 总结 模板方法模式实际上是封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同实现，从而让固定的流程产生不同的结果。 模板方法封装了有固定结构的算法块，模板类中可以有各个子类具有相同实现的方法，也可以有各个子类具有不同实现的方法，具有相同实现的方法可以直接在父类（模板方法所在的类）中实现，而各个子类具有不同实现的方法由每个子类自行实现，这样做，子类实现的方法就“挂接”进模板方法里。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"《Head-First-设计模式》读书笔记charpter7","date":"2020-04-20T14:40:09.000Z","path":"2020/04/20/《Head-First-设计模式》读书笔记charpter7/","text":"本篇博客是《Head First 设计模式》第七章的读书笔记。 分享主题是设计模式中的 「适配器模式(Adapter Pattern)」以及 「外观模式(Facade Pattern)」。 适配器模式由于这两种设计模式都比较好理解，所以先直接从定义讲起。 定义适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 日常生活的类比我们先用日常生活中例子类比来理解适配器模式。如下图，由于接口的差异，美国笔记本电脑插头无法直接插进欧洲插座获电，而使用了中间的接口转换器后，问题就解决了。而值得注意的是，从无法使用到可以使用，我们既没有改变插座，也没有改变插头，唯一的变化就是引入了接口转换器这一适配器。在这里，这个适配器的作用就是将现有的不符合标准的插头接口“转化”成目标接口，这也正是适配器模式做的全部工作。 插头接口转换器的例子 具体应用场景如下图，系统中有两个接口:Duck和Turkey，它们都有fly()方法，这两个接口的差异在于Duck的quack()和Turkey接口的gobble()方法。MallardDuck和WildTurkey分别实现了Duck接口和Turkey接口。 image-20200420231854471 此外，在外部有个testDuck方法，它的参数是一个Duck对象，在方法体内分别调用了这个Duck对象的quack()方法和fly()方法，我们无需关注它的目的是什么，只需要关注要想调用这个方法，需要一个Duck类型的对象作为参数。 1234public static void testDuck(Duck duck)&#123; duck.quack(); duck.fly(); &#125; 接下来看看下面这段代码，testDuck(wildTurkey)这行代码必然会报错，因为wildTurkey 不是 Duck类型的。 123456789public static void main(String[] args) &#123; System.out.println(\"A duck says:\"); Duck mallardDuck =new MallardDuck(); testDuck(mallardDuck); //这行代码可以正常执行 System.out.println(\"A turkey says:\"); Turkey wildTurkey =new WildTurkey(); testDuck(wildTurkey); //这行代码必然会报错，因为wildTurkey 不是 Duck类型的。&#125; 我们用这个例子来类比上文中插头接口转换器的例子，testDuck()这个方法就相当于上例中的插座，它要求一个Duck对象作为参数才可以正常使用（换句话说，它的标准是Duck接口），就相当于欧洲插座要求一个符合欧洲标准的插头才能正常使用，不符合testDuck()标准的wildTurkey对象就相当于上例中的美国插头（类比详见下图）。而如果我们要是想在不改动WildTurkey类代码的基础上，完成testDuck(wildTurkey)这条语句的功能，就要想办法构建一个上例中的适配器。 类比插头接口转换器的例子 构建TurkeyAdapter这个适配器： 123456789101112131415161718192021/** * @Created by hfq on 2020/4/21 * @used to: 为Turkey接口构造适配器，以使得它符合Duck接口这个标准 */public class TurkeyAdapter implements Duck&#123; //适配器要实现目标接口Duck Turkey turkey; //组合了一个Turkey接口的对象 public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; //这里直接调用了turkey的gobble方法，当然，你也可以做点别的 this.turkey.gobble(); &#125; @Override public void fly() &#123; this.turkey.fly(); &#125;&#125; 测试代码： 1234System.out.println(\"A turkey says:\");Turkey wildTurkey =new WildTurkey();TurkeyAdapter wildTurkeyAdapter = new TurkeyAdapter(wildTurkey);testDuck(wildTurkeyAdapter); //完成了接口转化 至此，一个应用适配器模式的demo就写完了。引入了适配器后，在既不修改WildTurkey类代码、又不修改testDuck方法的代码的基础上，我们完成了原本不兼容的工作，看上去就像实现了将一个Turkey接口的对象转化成一个Duck接口的对象。 UML图适配器模式的UML建模图如下，为了便于理解，我结合刚才的例子添加了红字标注出上例中的各个部分分别代表了什么。适配器Adpter实现了目标接口，且其类中组合了一个被适配器Adptee的对象。 p.s 我本篇博客介绍的例子是采用对象组合的方式实现适配器模式，书中还给出了另外一种实现适配器模式的思路——多重继承，简而言之就是Adapter既继承Target，又继承Adaptee，由于java语法不支持多重继承，在此不做过多介绍。 适配器模式的UML图 以上就是适配器模式的全部内容了，是不是很简单！接下来一起来看看更简单的外观模式吧。 外观模式定义外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 具体应用场景书中给出的例子是家庭影院的例子：放映电影需要执行一系列任务，这些任务涉及到了多个对象（以及它们对应的多个方法），这导致了每次需要放映电影都要写上一长串代码。 image-20200421005039865 你需要的正是一个外观：有了外观模式，通过实现一个更合理的接口的外观类，你可以将一个复杂的子系统变的容易使用。所以我们引入一个外观类HomeTheaterFacade，这个类中组合了所有与放映电影相关的对象（爆米花机、投影仪等等），它提供了一些更加友好的方法（每个方法都是一个子系统）以供调用，调用方不用知道方法内部是如何做的，以放映电影为例，调用方只需要提供需要完成放映操作的对象实例化HomeTheaterFacade，再调用它的watchMovie()方法，引入外观模式后的类图如下所示： 家庭影院外观类图 放映电影的内部方法代码和调用放映电影方法的代码见下图： 放映电影方法、调用放映电影方法的代码实现 适配器模式和外观模式总结适配器模式在不修改接口的代码的基础上，提供了将一个接口转成另一个接口的方法，以达到兼容。 外观模式定义了一个高层接口,让子系统更容易使用，接口简单对调用方更友好。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"《Head-First-设计模式》读书笔记charpter5","date":"2020-04-18T14:19:15.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter5/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「单件模式(Singleton Pattern)」。 单件模式（也常叫单例模式）可以说是最简单的设计模式了，然而具体实现的还是有些讲究的，本文梳理了四种单例模式的实现方法 。其中前三种是书上给出的，最后一种书上没有提到，以作补充。 单例模式的基本认识 定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。 用来创建只能有一个实例的独一无二对象。 比如说线程池、缓存、对话框、处理偏好设置、注册表、日志对象、打印机等设备的驱动程序的对象。 可以确保只有一个实例会被创建，单件模式给了我们一个全局的访问点，和全局变量一样方便，又没有全局变量的缺点。 单例模式的四种实现方法一、懒汉 实现 私有的构造函数 私有的静态变量表示唯一实例，不初始化 公开的静态方法获取唯一实例 分析 优：延迟实例化(lazy instantiaze) 类加载时不会初始化，用到了才会产生(实例化) 缺：多线程可能引发创建多个实例(在不加synchronized关键字的情况下) 改进：为getInstance()方法加上synchronized关键字 引入了新的问题：降低了性能，为什么？ 因为实际上只有第一次执行此方法时，才真正需要同步，一旦设置了instance变量，就不再需要同步这个方法了。所以说，之后每次调用这个方法，同步都是一种累赘。 1234567891011121314151617/** * @used to: 懒汉实现单例模式，两私有一公开 */public class Singleton &#123; private static Singleton instance; private Singleton()&#123; &#125; public synchronized static Singleton getInstance()&#123; //如果不加synchronized关键字，多线程情况下，此处可能创建多个不同的实例对象 if (instance ==null) instance =new Singleton(); return instance; &#125;&#125; 二、饿汉饿汉单例模式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快。 实现 私有的构造函数 私有的静态变量表示唯一实例，初始化 公开的静态方法获取唯一实例 分析 与懒汉比较：饿汉在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快 优：不会有多线程导致创建了多个实例的问题 缺：即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。 1234567891011121314/** * @used to: 饿汉实现单例模式 */public class Singleton2 &#123; private static Singleton2 instance = new Singleton2(); //类加载时完成初始化 private Singleton2()&#123; &#125; public static Singleton2 getInstance()&#123; return instance; &#125;&#125; 三、双重校验锁DCL【推荐】 目标：是对懒汉中同步性能的优化，实现有更高同步性能的延迟加载。 实现 private static volatile Singleton instance 为什么要volatile？ if (instance == null) 校验1 synchronized (Singleton.class) if (instance == null) 校验2 分析 123456789101112131415161718192021/** * @used to: DCL（双重校验锁）实现单例模式 核心：volatile和两次校验 */public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3()&#123; &#125; public Singleton3 getSingleton()&#123; if (instance == null)&#123; //校验1,仅当singleton为空会进行同步。 synchronized (Singleton3.class)&#123; if(instance == null)&#123; //校验2，防止多线程中，不同线程执行到校验1，然后依次获得多个实例。 instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125;&#125; 四、静态内部类【推荐】 书上没给出这种方法，是从其他博客中学习到的。 1234567891011121314151617/** * @used to:静态内部类实现单例模式 */public class Singleton4 &#123; private static class SingletonHolder&#123; //静态内部类 private static Singleton4 instance = new Singleton4(); &#125; private Singleton4()&#123; &#125; public static Singleton4 getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 分析 它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。 不一样的是，它是在内部类里面去创建对象实例。 这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。 总结评价单例模式的四种实现方法主要从以下两个角度考虑： 是否延迟加载((lazy instantiaze)) ？ 怎么保证线程安全，在保证线程安全的情况下，性能如何 ？","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"《Head-First-设计模式》读书笔记charpter4","date":"2020-04-18T08:38:11.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter4/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「工厂模式(Factory Pattern)」。 本读书笔记系列前几篇文章写得比较冗长，耗时也久，大半天才写出一篇博客。从这篇开始，尝试换种风格，尽量写的简洁一点，忽略一些不必要细节，先整体过一遍再来看看有无补充得必要。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"《Head-First-设计模式》读书笔记charpter3","date":"2020-04-18T02:12:57.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter3/","text":"本篇博客是《Head First 设计模式》第三章的读书笔记。 分享主题是设计模式中的 「装饰者模式(Decorator Pattern)」。 应用背景——种类繁多的饮料的“类爆炸”背景书中给出的例子是，一家饮品店的饮品种类繁多，且客户可以自行选择在饮品内加入收费的调料（调料当然也有多种）。即使是同一种的饮品，由于加入了不同的调料，价格也会有差异，如何计算饮品的价格就成了一个问题。如下图1，书中给出的第一个尝试是列举所有饮品的可能情况来构成饮品的所有子类，如HouseBlendWithSoy(表示带调料Soy的HouseBlend饮品类)，由于饮品和调料的组合方式很多，这势必会造成”类爆炸”。 图1 但凡有点开发经验的都不会像上面这样做，我们往往都能想到通过继承解决类爆炸的常规思路，而继承解决会带来一些问题，这就需要引出本文的主角装饰者模式了，一起来看看吧。 通过继承解决具体做法是：为饮品父类中添加一些布尔类型的成员变量(如milk、soy等,都是调料名)来表示是否有该调料，和它们对应的成员方法(如hasMilk())。在父类的计算饮品价格方法 cost()中，依次判断是否加入了各调料，也就是判断该调料的变量是否为true，如果是true就在饮品的基础上加上这种调料的价格。如此一来，针对一个带特定调料的饮品对象，只需要设置它的这些成员变量的状态，使用继承自父类的cost()方法就能计算价格了。这种做法很简洁易懂，然而可拓展性不好：如果客户需要在饮品中加入双倍的某种调料，就要修改现有的代码：在饮品的父类中再加入多个成员变量(如milkNum,soyNum)来记录饮品的调料数目，同时，也会修改父类计算饮品价格的cost()方法，因为现在还要乘上调料的数量。 通过装饰者模式解决现在我们还不用着急知道什么是装饰者模式，只需要知道它的基本思路就是：用一种种调料层层“包装”饮品，然后逐级调用cost()方法来获得最终饮品的价格。 下图是用调料层层包装饮品的示例，模拟了加入了两种调料(Mocha和Whip)的DarkRoast饮品。 图2 我们姑且把调料叫做装饰者，把饮品叫做被装饰者。但是，这里有个小细节，调料既可以用来包装饮品（如图上红字标出的调料1对象包装了一个饮品对象），还可以包装其他调料（如图上红字标出的调料2包装了一个调料1对象），也就是说调料1在这里既作为最内层饮品的“装饰者”，又作为外层调料2的“被装饰者”。 为了标记每个装饰者包装的对象是谁，我们有必要在装饰者类（就是调料类）里设置个成员变量warppedObj——一个指向“被装饰者”的引用，那这个成员变量的类型应该是什么呢？这里有点绕，再次强调一下，调料2的“被装饰者”是调料1，其类型是调料，调料1的“被装饰者”是饮品，其类型是饮品，所以说这里怎么设置warppedObj的类型都不对：如果设置成饮品类，那么调料2就无法包装调料1，如果设置成调料类，那么调料1就无法包装饮品。也就是说如果要正确设定warppedObj类型以支持以上情形，就要完成调料类和饮品类的类型统一。书中的做法是让调料类继承饮品类，以达成类型的统一。 搞懂了这个，接下来的事情就好办了，如上图2，我们的目标是：计算有1份Whip、1份Mocha的DarkRoast饮品价格，做法就是先new一个Mocha对象包装DarkRoast对象记作obj1，在new一个Whip对象包装obj1。计算价格的时候调用最外层调料2对象的cost()方法，它的实现是调用其包装了的对象调料1的cost()方法获得调料1对象的价格，再加上自己的价格，而调料1的cost()实现又是调用内层饮品的cost()方法再加上自己的价格，以此类推，计算价格的过程就像上图2标出的6步流程。 如果这个饮品需要加入双倍的Whip调料，只需要再用一层Whip来包装，不用对其他代码改动。 装饰者模式装饰者模式思想在给出装饰者的定义之前，先来谈谈其“主要指导思想”，装饰者模式的指导思想是组合而非继承（在策略模式中也提到过）、开放关闭原则。 组合而非继承 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相关同的行为。然而，如果通过组合的做法扩展对象的行为，就可以在运行时动态地进行拓展。 开放关闭原则 含义：类应该对扩展开放，而对修改关闭。 解读：在不修改任何底层代码的情况下，给你的对象赋予新的职责。 这两条是书中引出装饰者模式的思想，现在理解不了没关系，先通读下文，再来回顾装饰者模式是如何遵循这两条思想的。 装饰者模式定义装饰者模式动态地将责任附加到对象上，若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。 装饰者模式UML图本案例中，使用装饰者模式后，uml图建模如下： 饮品是被装饰者（书中也叫做组件Component），可以被多种调料“包装”，它始终在最内层。 调料是装饰者，用来”包装“饮品，但是需要注意的是，调料同时也可能作为被装饰者，因为它外层可能还有别的调料来包装它。 在uml图中，我们特别需要关注的是饮品类和调料类的关系： 首先，调料子类里组合了饮品的对象。这个其实很好理解，就是记录调料这一装饰者包装了什么饮品（或者是包装了”包装了饮品“的调料）。 其次，调料的父类继承了饮品父类，也就是说调料也是饮品的子类，就像上文说的，它的目的是完成“调料类和饮品类的类型统一”。以我的理解，这里的继承的具体作用有两个:一是让调料类获得饮料类的方法，如cost()方法，二是以便于其它的调料类包装”包装了饮品的调料类“。 实际中的装饰者模式——java.iojava.io包提供的众多输入输出流相关的类，就是应用了装饰者模式。 输入流层层包装，外层流为内层流提供了新的服务。如下图，InputStream是被装饰者类父类,FilterInputStream是一个很多装饰者类的父类，其中有一个InputStream类型的名为in的成员变量。 image-20200418111628569 下面我给出了一个自定义InputStream的装饰类Demo,作用是将输入流字母变成小写。 12345678910111213141516171819202122232425/** * LowerCaseInputStream.class * @Created by hfq on 2020/4/18 * @used to: 编写自己的Java IO装饰者类,负责将输入流字母变成小写 * @return: */public class LowerCaseInputStream extends FilterInputStream &#123; /** * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt; * by assigning the argument &lt;code&gt;in&lt;/code&gt; * to the field &lt;code&gt;this.in&lt;/code&gt; so as * to remember it for later use. * * @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if * this instance is to be created without an underlying stream. */ protected LowerCaseInputStream(InputStream in) &#123; super(in); &#125; public int read() throws IOException &#123; int c = super.read(); return c==-1?c:Character.toLowerCase((char)c); &#125;&#125; 测试代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * JavaIoTest.class * @Created by hfq on 2020/4/18 * @used to: 测试代码 * @return: */public class JavaIoTest &#123; public static void main(String[] args) throws Exception &#123; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(\"designpatternlearning.iml\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"文件不存在！\"); &#125; System.out.println(\"读到的第一个字符是:\"+(char)inputStream.read()); DataInputStream dataInputStream = new DataInputStream(inputStream); //使用DataInputStream包装InputStream System.out.println(\"读到的一行字符是:\"+dataInputStream.readLine()); //使用自定义的DataInputStream包装InputStream LowerCaseInputStream lowerCaseInputStream = new LowerCaseInputStream(dataInputStream); int c = 0; System.out.println(\"剩下的字符【经过自定义IO流过滤大写字母为小写字母处理】：\"); while((c = lowerCaseInputStream.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; inputStream.close(); //长得更像装饰者模式的写法： InputStream in = new LowerCaseInputStream(new DataInputStream(new FileInputStream(\"designpatternlearning.iml\"))); while((c = in.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; in.close(); &#125;&#125; 总结 装饰者模式的UML建模图 如上图所见，装饰者模式的核心就是：装饰者既是一个(is-a)被装饰者，又有一个(has-a)被装饰者。 is-a 装饰者和被装饰者是相同的类型，这样做是为了利用继承达到“类型匹配”而不是为了利用继承“获得行为”。“类型匹配是说”一个装饰类的接口必须与被装饰类的接口保持相同。 has-a 指的是在装饰者的类中组合了一个被装饰者对象。 感悟 首先我觉得，书中这个这个例子其实并不是很好，调料类继承了饮品类，虽然知道它这样做是为了统一类型（使得装饰类既可以包装饮品，也可以包装其他的装饰类），但将调料作为饮品的子类的子类总归很别扭。 另外我觉得理解装饰者模式的核心就是理解”装饰类的接口必须与被装饰类的接口保持相同”，其根本原因是装饰者既要包装被装饰者，也要包装和它同类型的其他装饰者。 装饰者模式通过“层层包装”来装饰内层对象，为最内层的原对象锦上添花，添加新功能，扩展性好。 最后，以书中关于开放关闭原则的描述结尾： 代码应该如同晚霞中的莲花一样关闭（免于改变），如同晨曦中的莲花一样开发（能够扩展）。 这也就是引入装饰者模式的目标吧！","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"cxsj项目-停车位使用情况可视化","date":"2020-04-10T00:53:18.000Z","path":"2020/04/10/cxsj项目-停车位使用情况可视化/","text":"需求分析在智慧停车管理平台(WEB端)项目中，为了清晰地展示当前停车场的车位使用情况，想到把车位的使用状态可视化地展示到室内停车场地图上。效果如下： image-20200410113840534 根据室内地图的车位图标颜色不同，用户可以看到停车场各个车位的使用状态。此外，当用户点击地图内的车位图标时，还能获取当前指定车位的状态（是否占用，如果占用，还会显示车牌号）。 实现技术前端：Jquery (ajax请求数据) 后端：SpringBoot Mybatis (数据库查询数据) 室内地图支持：Esmap （地图展示) 实现方案1. 引入Esmap的室内地图,熟悉其sdk首先，从下载室内地图的示例，以获得示例地图的数据包。我选择的是“基本地图显示”示例。 然后，在html中引入室内地图，这一步Esmap官网的开发文档有详细的流程我就不多介绍了。按照指示引入地图到html后，实现的初始效果如下： image-20200409174547260 示例默认的主题颜色比较单调，可以通过配置参数来修改主题样式（如地图背景颜色等）。 接下来，熟悉Esmap的sdk，本案例中，我们主要关注的就是：如何跟踪点击事件？(用户点击后停车位能够触发操作)，修改图标的颜色（加载车位可视化页面时根据车位的使用状态为车位图标设置不同的颜色），发现这分别对应开发文档中地图事件中的“地图点击返回事件”和常用方法中的“改变房子颜色”的changeModelColor()方法。 接下来我们就研究一下这两个方法。 方法1：地图点击返回事件12345//地图点击返回事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.htmlmap.on('mapClickNode', function(event) &#123; console.log(event); //打印事件&#125; 可以发现，当点击地图的车位图标时，打印的车位对象如下图。 image-20200410095433726 因为点击地图其他图标(比如说楼梯、道路)也会触发地图点击事件，而在本案例中我们只要关注点击车位事件，所以我们可以以地图点击返回事件event中的name属性里是否包含”车位”二字来区分被点击的图标是否为车位，如果判断是车位，才会触发后续的方法changeModelColor()来改变被点击车位的颜色。 方法2：改变房子颜色123456789//改变房子颜色(一定要在地图加载完成事件之后才有效)//id,name二选择一，都可以是数组, fnum可选择，参数color:'#FF0000'//https://www.esmap.cn/escopemap/content/cn/develope/map-fun.htmlmap.changeModelColor(&#123; //id:[1,2], name:'车位1091', //fnum:[1], color:'#FF0000'&#125;) 需要注意开发文档里指出的”一定要在地图加载完成事件之后才有效”。也就是说，changeModelColor()方法要在加载完成事件完成后调用，如下： 12345//地图加载完成事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.html map.on('loadComplete', function () &#123; map.changeModelColor()方法要在此调用！！！&#125;); 至此，我们就完成了地图页面展示，掌握了点击车位图标触发事件的方法和修改车位图标颜色的方法。 2. 创建停车位的数据表和后端api接口在我创建的车位数据表中，有这样几个主要字段： 车位标识id：由于在本案例我们使用的室内地图数据包中，所有车位对象的name属性在“车位1001~车位1102”，为了下一步地图车位对象和数据库记录的绑定，车位id的值也设置在此范围内。 车位所在停车场标识parkinglot_id：由于我的项目涉及到多个停车场，需要此字段，如果只是有一个停车场可以不用此字段。 车位状态标识in_use：若车位是空闲状态，取值0，若占用取1。 车牌号car_id：若车位占用，存车牌号，否则为空。 停车时间park_time：若车位占用，存此车进入车位的时间戳，否则为0。 创建好车位数据表之后，生成一些假数据（我是通过写了一个java类，按照给定格式随机生成记录，然后拼接字符串打印这条记录的insert语句，然后到数据库执行，后来网上了解一下，或许可以尝试使用Python的伪造数据生成器Faker），生成的部分假数据如下图展示。 image-20200410102612112 下一步，写一个Controller，完成车位查询的api接口，响应POST方法，为请求返回json数据，代码如下： 1234567891011121314151617181920212223242526/** * * @param parkinglot_id 停车场ID * @param parking_space_id 车位id * @return * 如果参数parking_space_id 为空，查找所有停车场ID为parkinglot_id的所有车位使用情况 * 如果参数parking_space_id非空，根据停车场id和车位id 查询一条记录。 */ @ResponseBody @PostMapping(\"/parkinglot/&#123;parkinglot_id&#125;/space\") private Object selectAllSpace(@PathVariable(name = \"parkinglot_id\") Integer parkinglot_id, @RequestParam(name = \"parking_space_id\",required = false) Integer parking_space_id )&#123; ParkingSpaceExample example = new ParkingSpaceExample(); if(parking_space_id!=null)&#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id) .andIdEqualTo(parking_space_id); &#125; else &#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id); &#125; List&lt;ParkingSpace&gt; parkingSpaces = parkingSpaceMapper.selectByExample(example); return parkingSpaces; &#125; 如果请求时携带了parking_space_id参数，就只查询车位id等于parking_space_id的那条车位记录，否则，查询该停车场的全部车位记录。请求参数携带车位标识和不携带车位标识这两种请求应用场景分别是：加载页面时，需要查询全部车位的车位状态，而用户点击地图的某个车位图标时，只需要查询这一个车位状态。 当不携带车位标识时，某次请求响应的部分json数据如下图展示。 image-20200410104637275 至此，我们就完成了车位数据表的建立和查询。 3. 将地图显示和数据库“绑定”这一步我们就完成可视化的任务，具体需要完成的功能有两个：功能一是加载车位详情页面的时候，查询车位数据表，根据车位状态为地图的车位图标“上色”（空位占用则红，车位空闲则为绿）；功能二是当用户点击车位图标时，查询数据库该车位的当前状态并显示出来（如果车位占用还会显示出当前的车牌号）。 有了步骤1、2的基础后，这一步就很简单了，简单地说，就是用步骤2的数据填充到步骤1的方法内。具体做法是在javascript脚本中使用ajax请求获取后端的车位数据，然后对这些数据按指定格式处理，作为调用Esmap sdk的配置参数。 以功能一的实现为例： 使用ajax向步骤2中编写好的用于查询车位的api接口发送请求，获得请求后的json数据后，遍历每条数据（对应车位数据表的一条记录），根据数据的inUse属性的取值来标识车位是占用还是空闲状态，然后拼接“车位”二字到数据的id属性的取值，就获得了这条记录对应在地图上车位图标对象的name属性（也就是说，数据库中的车位id为1001的车位记录对应地图上name=”车位1001”的地图对象)。设置js数组inUseNameList和notInUseNameList，它们分别是全部占用车位对应的地图车位图标的name属性数组、全部空闲车位对应的地图车位图标的name属性数组。调用 map.changeModelColor()方法设置地图车位图标的颜色时，指定name参数为inUseNameList，颜色设置成红色，指定name参数为notInUseNameList，颜色设置成绿色。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 完成功能一：当地图加载完成时，设置停车位的颜色 */function loadSpace() &#123; var inUseNameList = new Array(); //全部的占用车位对应的地图车位图标的name属性数组 var notInUseNameList = new Array(); //全部的空闲车位对应的地图车位图标的name属性数组 var pathname = window.location.pathname; var parkinglot_id = pathname.charAt(pathname.length-1); console.log(pathname); $.ajax(&#123; //使用ajax请求数据 method: \"POST\", url: \"/parkinglot/\"+parkinglot_id+\"/space\", &#125;) .done(function( spaceList ) &#123; // console.log(spaceList); //打印全部车位信息 $.each(spaceList,function(i,space)&#123; var spaceName = \"车位\"+space.id; if(space.inUse==1)&#123; //表示车位被使用了 inUseNameList.push(spaceName); &#125;else &#123; notInUseNameList.push(spaceName); &#125; &#125;); map.changeModelColor(&#123; //占用车位设置成绿色 name: inUseNameList, color: '#FF0000'&#125; ); map.changeModelColor(&#123; //空闲车位设置成绿色 name: notInUseNameList, color: '#00FF00'&#125; ); &#125;);&#125;","tags":[{"name":"项目","slug":"项目","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://hfq123.github.io/tags/JavaWeb/"}]},{"title":"《Head-First-设计模式》读书笔记charpter2","date":"2020-04-06T14:26:09.000Z","path":"2020/04/06/《Head-First-设计模式》读书笔记charpter2/","text":"本篇博客是《Head First 设计模式》第二章的读书笔记。 分享主题是设计模式中的 「观察者模式(Observer Pattern)」。 1、应用场景—气象监测应用书中给出的例子是：公司要建立一个气象监测应用，如下图，WeatherData对象会从气象检测站获取实时更新的气象数据（湿度、温度、气压），WeatherData对象要做的就是将这些数据及时“分发”到多个布告板，使得每个布告板能使用最新的气象数据以更新它的显示情况。除此之外，附加的需求是系统必须可扩展，能够让用户随心所欲地添加或删除布告板，也就是说，目前系统有“目前状况”、“气象统计”、“天气预报”三个布告板，以后可能会删除某个或者新增别的布告板，言外之意就是说，WeatherData对象要随时准备好停止向现有的布告板分发最新数据以及随时准备好向新的布告板分发最新数据。 image-20200406223021520 2 实现思路2.1 错误示范我们先来看一个很容易想到的思路，然而这被书中称之为“错误示范”（这也是我学习观察者模式之前的思路）。首先我们先约定：一旦气象站测量的气象数据更新，WeatherData类的measurementsChanged()方法就会被调用，在本文，我们不用关心它是怎么做的，只要知道在此方法下，我们要做的就是将这些数据及时“分发”到多个布告板类。 接下来我们就一起来看看这个简单自然但是错误的示例吧，如下图，在WeatherData类的中measurementsChanged()方法里，做的事情很简单，就是获得最新的气象数据，然后以此作为参数各个布告板类的更新方法。 image-20200406223736428 看似完全能实现我们的需求：当气象站检测到新的数据，measurementsChanged()被调用：获得最新的气象数据，然后分别调用各个不同的布告板的update()方法（在这个方法里，布告板会根据自己的需求使用最新数据来改变显示板，我们无需关注update()方法里究竟做了什么，只要知道它需要获得WeatherData类的最新气象数据，供它们更新自己的数据以改变显示屏）。 这样实现究竟有哪些错误呢？ 各个布告板类之间是独立的，没有一个共同的接口，是典型的“针对实现而非针对接口编程”的错误。 每当添加或删除新的布告板，我们都不得不修改方法体内的代码。比如说设计了一个新的testDisplay布告板，我们就要加上一行testDisplay.update(temp,humdity,pressure)，当testDisplay不再需要获取最新的气象状态，就要删除这行代码。 也正是因为每当添加或删除新的布告板，我们都不得不修改方法体内的代码，所以我们无法在运行时动态地增加或者删除布告板。 2.2 观察者模式引入观察者模式就能解决上述实现带来的问题。 先简单介绍一下什么是观察者模式，在观察者模式中，有两个主角，分别是主题(Subject)和观察者(Observer)，书上用了“出版者”和“订阅者”来类比观察者模式中的主题和观察者。出版者一旦出版新的报纸，他就要负责将新报纸分发到各个订阅者手中，而那些没有订阅报纸的人就不会收到，就和这里的例子一样，WeatherData类一旦获得新的气象数据，就要负责分发到各个布告板类中。观察者模式的概念是：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 借助下图，能够让我们清楚地看到观察者模式的“一对多依赖”。 image-20200406230651346 观察者模式为主题和观察者都创建了各自的接口。在主题接口中，定义了注册观察者(registerObserver)方法、撤销观察者(removeObserver)方法、更新所有观察者状态方法（notifyObservers,一旦主题状态改变会触发）；在观察者接口中，定义了更新观察者状态的方法(update)。 image-20200407002547510 我们再把目光转移到应用场景，前面我们已经分析了思路1实现带来的问题，接下来就要好好考虑怎么解决： 首先，我们可以考虑需要为所有布告板类创建一个观察者接口，因为在WeatherData类中，WeatherData不关心布告板是叫currentConditionDisplay还是叫statisticsDisplay，只关心它是否需要在气象数据更新时获得自己的最新气象数据，如果它实现了观察者接口并且注册了主题（相当于订报人完成了订阅动作），那么当WeatherData类的数据更新时，它就是分发数据的目标之一。 然后，我们可以在WeatherData类中维护一个所有观察者组成的列表，这样做能让WeatherData类轻松地获取所有观察者（布告板）。有了观察者列表之后，每当WeatherData类的数据更新，就遍历列表内的所有布告板，调用它们的update()方法即可，WeatherData类不用再关注有几个观察者布告板，它们叫什么名字。当需要添加或删除新的布告板的时候，只需要对列表做增删操作，而不用像思路1中那样改动measurementsChanged()方法体内的代码，同时，这也解决了不能运行时动态地增删布告板的问题，因为运行时可以动态的修改列表的元素（比如说系统运行了十分钟后将currentConditionDisplay公告板从观察者列表中移除）。 想到这些，引入观察者模式之后的模型就呼之欲出了。引入观察者模式之后，本气象站应用的的类图就如下图所示，WeatherData和各布告板分别实现主题接口和观察者接口。 image-20200407002514351 接下来我们从代码的层面上来考虑一下主题的方法是如何实现的。 registerObserver(Observer o)：将观察者对象o加入到WeatherData维护的观察者列表。 removeObserver(Observer o)：将观察者对象o从WeatherData维护的观察者列表中删除。 notifyObservers():遍历WeatherData维护的观察者列表，在循环体内调用每个观察者对象的update()方法。 对比思路1和思路2，可以发现，通过引入观察者模式，我们不仅能方便地实现布告板的增删：当有了新的布告板对象o要“监听”WeatherData的最新数据，就调用registerObserver(o)，当它不再需要获取最新气象数据，就调用removeObserver(o)，还能在运行时动态地增删布告板：，比如说为布告板对象o设置一个“监听”时间10分钟，在10分钟内，它需要监听主题的状态变化，10分钟以后，它就不需要再监听，那么就可以通过在到达10分钟的时候调用removeObserver(o)将其从观察者列表移除即可。 3、总结与思考从观察者模式的两个主角来看，主题拥有自己的一些状态(参考例子中WeatherData对象的天气数据)，而多个观察者想要获知这些状态来改变自身的状态，从而构成了一对多依赖。主题向全体观察者通知，观察者可以随时决定取消监听主题。 如果我们仔细体会本例中一下思路1到思路2的转变，会发现实现了一个松耦合的过程，在思路1中，主题需要关注观察者是谁，而引入观察者模式后，主题不需要知道观察者的具体类是谁，只知道观察者实现了某个接口，有新的观察者出现时，主题的代码不需要修改，二者并非紧耦合。改变主题或观察者其中一方，不会影响另外一方。 最后，本文以一条设计原则结尾。为了交互对象之间的松耦合设计而努力。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"20200406 算法题2则","date":"2020-04-06T14:21:31.000Z","path":"2020/04/06/20200406算法题2则/","text":"今天在牛客网刷了两道剑指offer关于二叉树的题，都比较简单，都可用分治法的思路解决。 题1：二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 我的解答12345678910public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); int max=leftDepth&gt;rightDepth?leftDepth:rightDepth; return max+1; &#125;&#125; 解析：略 题2：二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 &#x2F; \\ 6 10 &#x2F; \\ &#x2F; \\ 5 7 9 11 镜像二叉树 8 &#x2F; \\ 10 6 &#x2F; \\ &#x2F; \\ 11 9 7 5 我的解答：1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 解析：这里需要注意必须交换左子树根节点和右子树根节点的引用而非交换取值。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://hfq123.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"《Head First 设计模式》读书笔记charpter1","date":"2020-04-05T07:10:41.000Z","path":"2020/04/05/《Head-First-设计模式》读书笔记charpter1/","text":"本篇博客是《Head First 设计模式》第一章的读书笔记。 分享主题是设计模式中的 「策略模式(Strategy Pattern)」。 1、应用场景—一群鸭子引发的故事。书中给了这样一个例子作为应用场景引入：某公司有一套模拟鸭子游戏，游戏中会出现各种各样的鸭子，这些鸭子有一些动作：呱呱叫、戏水。按照面向对象的思想，系统设计为鸭子这一对象设计了一个名为Duck的超类，在这个类中，为实现动作呱呱叫、戏水分别设置了quack()、swim()方法，而各种不同种类的鸭子通过继承这一超类获得这些描述鸭子动作的方法。 接下来问题来了，系统引入了一个新的需求：让鸭子飞起来。开发人员需要为鸭子类加入描述飞行动作的方法，书中也是以实现此需求展开来引入策略模式的。 2、解决思路—继承还是接口 ？2.1 通过继承实现首先,我们很自然地想到，可以在超类Duck中加入一个fly()方法（就像quack()、swim()方法一样），子类通过继承获取描述鸭子飞的方法。 分析： 因为所有子类都会继承超类Duck的方法，即使是一些不能飞的鸭子如橡胶鸭也会继承fly()方法，这样做我们不得不在子类橡胶鸭中重写fly()方法以覆盖继承的方法，比如说，将其子类中不会飞的鸭子的fly()方法体修改成什么都不做。同理，如果有不会叫的鸭子，又需要在该子类中重写quack()方法。 评价：这种思路是最容易想到的,主要利用了面向对象的继承、多态（体现在重写方法）特性。在代码重用上有一定效果，因为子类可以重用父类的fly()方法，但是也存在了一些缺点： (ps:这四个缺点是书中的一道多选题，只给出了答案，具体解读为自己的想法，如有不对，欢迎指正)。 代码在多个子类中重复：假设鸭子有多种飞行方式，那么我们无法仅通过继承超类的fly()方法来描述所有鸭子的飞行方式。我们必须为所有与超类中fly()实现的飞行方式不一致的鸭子子类编写fly()的覆盖方法，而具有相同的飞行方式但不同于超类中fly()给出的飞行方式的众多鸭子子类的覆盖方法将会是一样的，导致代码重复。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们需要看完Duck超类的fly()方法和全部的鸭子子类覆盖的fly()方法才能知道鸭子全部的飞行方式。 运行时的行为不容易改变：通过继承实现，每一个特定的Duck对象的飞行方式都是确定的，这是因为在它的 fly()方法是写死的，每个Duck对象的飞行方式已经在其创建的时候确定了，也就是说，鸭子不能中途切换飞行方式。 改变会牵一发而动全身，造成其他鸭子不想要的改变：这是指如果修改了超类的fly()方法，会影响到其子类。 下文可以看到，通过使用策略模式能有效解决这些问题。 2.2 通过接口实现上面的解读以fly()举例，其实其他方法也可能存在类似的问题，比如说如果不同类的鸭子叫法不同，继承的quark()方法也会存在上述问题，有的鸭子这样飞、叫，有的鸭子那样飞、叫，有的鸭子不飞不叫。这时，我们就想到了将fly()、quark()从超类中取出来放进一个接口。如下图，以fly()为例，将其放进一个名为Flyable的接口。 image文件夹 *分析 *：这样一来，如果一个鸭子子类会飞则实现Flyable接口，将其fly()方法写到子类的方法体，如果不会飞则无需实现。 评价：从超类中分离出有些子类不需要的fly()、quack()方法，这样避免了部分子类继承它压根不需要的方法的情况。然而这样做的缺点也很明显，每次编写一个会飞的新的鸭子子类，都必须在子类中单独实现fly()方法（即使有和它飞行方式一样的其他子类），导致代码根本无法重用，所以这种方法非常不可取。 2.3 策略模式如何弥补思路1、2的缺陷，这就需要引入策略模式这一设计模式，讲策略模式之前，先引入2条设计原则。 设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 在本案例中，我们假设容易变化的方法是fly()和quack()，而每个鸭子的游泳方式是一样的，即swim()方法是不需要变化的。所以设法将fly()和quack()方法从超类中抽取出来建立一组新的结构来代表每个行为，而swim()方法继续保留在Duck超类中。 设计原则2：针对接口编程，而不是针对实现编程。 我们可以利用接口代表每个行为，比如说，引入接口FlyBehavior与QuackBehavior分别代表了飞行、呱呱叫的行为，通过实现FlyBehavior接口的fly()方法，建立各种各样飞行的行为类，来描述不同飞行方式。与思路2通过接口实现的区别在于，我们不再是直接在Duck或者是它的子类中实现不同的fly()方法，而是再另外引入一个实现了FlyBehavior接口的行为类来实现fly()方法。本系统中，每个飞行的行为类都实现了FlyBehavior接口，而在Duck类中，我们定义一个FlyBehavior接口型的成员变量，来保存其对应的行为类的指针，以调用其飞行方法。 image-20200406005221237 这样做就是策略模式的思路。使用策略模式后，本系统的全局类图如下图展示， 不变的方法swim()仍然在Duck超类中实现，而经常改变的fly()、quack()方法被抽离成为接口，再用具体的行为类去实现这些接口，在Duck超类中，保存对应的行为类一个对象的指针以确定该类鸭子的对应的fly、quack行为。 image-20200406003932396 为什么说引入了策略模式会解决上述继承的四个问题呢？ 代码在多个子类中重复：如果使用继承，如果鸭子的飞行方式与超类中给定的的不一致，即使是有同样飞行方式的鸭子子类，也不能重用代码，因为它们都要在各自的类里重写fly()方法。而引入策略模式后，只需要为有同样飞行方式的鸭子子类编写一个实现了FlyBehavior的行为类。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们只需要关注实现了FlyBehavior接口的所有类的fly()方法就能知道鸭子的全部行为。 运行时的行为不容易改变：通过改变Duck或其子类对象的行为类的指针，就可以实现运行时切换飞行方式，也就是说，在Duck类中创建一个setFlyBehavior()方法，就可以随时改变鸭子的行为。 改变会牵一发而动全身，造成其他鸭子不想要的改变：如果某种鸭子的飞行方式有所改变，只需要改变其行为类的引用，不影响其他鸭子子类。 3、总结与思考 image-20200406014158325 是时候给出策略模式的概念了（像本文一样，书中在本章节的最后才给出其概念，也就是讲完了所有细节再告诉你你已经不知不觉地学会了策略模式，我个人觉得这种学习方法比较适合人认识新事物的规律，否则，如果开头就先抛出这个晦涩的概念就能把人吓跑了！）： 策略（Strategy）模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 本项目中，我们可以把鸭子飞行的方式看作是策略，描述不同鸭子飞行方式的代码就构成了策略的算法族。之所以说策略模式让使“算法的变化独立于使用算法的客户”，是因为使用策略模式可以方便地更改客户正在使用的策略（通过更改Context类中对策略的引用）。如果认为使用思路1的继承方法，不厌其烦地在子类中编写fly()的覆盖方法、多写上几行重复代码是可以接受的话，那么，能够随时方便地为类替换策略这个优点就是你无法拒绝策略模式的理由。 这里也就引出了组合和继承(有一个VS是一个)的关系：使用策略模式之后 ，在Duck的子类中通过FlyBehavior、QuickBehavior接口间接地组合了飞行、呱呱叫的行为类，这是“有一个”的关系，理解成Duck的某个子类“有一个“飞行策略。而如果使用继承，则是”是一个“的关系，Duck的子类继承了父类的fly()方法或者重写后获得了自己的fly()方法，不能做到在运行时候动态地改变行为。在使用策略模式后，策略是以”行为类“的方式存在的，而如果使用继承，策略是以方法的形式写死在类里。使用策略模式后，当类的策略在运行时需要发生改变，只需要改变”有一个“的状态，由有一个策略A变成一个策略B，只需要修改其接口的引用（就像修改任何一个普通成员变量一样）。而如果使用继承，想要修改某个鸭子的飞行方式，需要通过修改其fly()方法的代码，当然也就做不到动态地完成改变行为了。综上对组合和继承的讲述，引出了一条新的设计原则： 设计原则3：多用组合，少用继承。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"我的第一篇博客","date":"2020-04-04T13:03:27.000Z","path":"2020/04/04/我的第一篇博客/","text":"引言我正在尝试使用Hexo搭建博客,其实早就有搭建博客的想法 ,然而一直没有去实现,今天刚做完一个SpringBoot项目。闲着无事心血来潮就开始了,完工后才发现原来搭建一个自己的博客这么简单且高效，有点相见恨晚的感觉。这第一篇博客就来简单记录一下我本次搭建博客的路线，以作纪念。以后我会更多地在此分享自己的学习内容，记录开发遇到的问题。 搭建环境本次博客搭建使用到的工具有 Hexo + Github。 Hexo是一个博客框架，让我们从渲染前端页面、部署JavaWeb开发环境中解脱出来，把更多的精力放在写博客这件事情本身上，如其官网介绍： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo的灵活性体现在其大部分前端显示内容都是通过参数来配置的，包括整个博客的主题、模板都可通过配置完成（下文会讲搭建好博客后如何更换主题）。 1586022290377 Github大家都比较熟悉，这里主要用到了它的Github Pages的功能来提供远端访问的支持，不使用Github，只使用Hexo工具也能搭建博客，不过只能在本地端口访问。 搭建步骤1 、安装Hexo 2、关联Github的库 3、更换自己喜欢的博客主题 本打算重做以详细记录一下这几个步骤，但是想想这次部署之后以后也没有必要重新部署了，再加上网上已经有很很详细的教程了，重新做一次对自己提升不大，就不浪费时间，所以直接贴教程：手把手教你用Hexo+Github 搭建属于自己的博客 遇到问题特别要注意在修改配置文件_config.xml中的配置项时的格式，正确格式形如：”属性: 空格 值”，如”title: 然后就的博客”。如果冒号和值之前没有空格隔开执行hexo命令时会报错。 以上就是本篇博客的全部内容了，没什么干货，差不多是简单的流水账，仅是为了纪念第一篇博客，以后争取只写高质量的博客！！！","tags":[{"name":"工具","slug":"工具","permalink":"http://hfq123.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","date":"2020-04-04T12:24:26.585Z","path":"2020/04/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]