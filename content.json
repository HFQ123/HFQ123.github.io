[{"title":"智慧停车项目介绍","date":"2020-06-23T06:13:50.000Z","path":"2020/06/23/智慧停车项目介绍/","text":"这篇博客介绍我在简历中提到的「智慧停车管理项目」的管理员端，因为项目没上线，演示部分所以就用截图的形式给出。 项目简介伴随国内汽车拥有量剧增，城市“停车难”问题近年来日渐凸显，是成为很多城市的通病。 停车难在哪？对于车主来说，有两难：一难在停车高峰时间段、繁华地段或是不熟悉的地段快速找到空闲停车位，在停车高峰期或是繁华地段，车主往往需要花费许多时间找车位甚至排队停车。二是找车难，在大型停车场、或者是车主不熟悉的停车场，很容易忘记自己的爱车的停放位置。对于停车场来说，大部分城市的停车位使用率不高。《2017 中国智慧停车行业大数据报告》称：“全国近 50%的停车场使用率低于 30%,近 9 成以上停车场使用率低于 50%”。解决停车问题最直接的方式就是建立更多的停车场，然而，汽车总量不断增多，但土地是有限的，如何实现有效管理，是缓解停车难的一个思考方向。基于此市场痛点，智慧停车行业也就应运而生了。智慧停车是指将无线通信技术、移动终端技术、GPS 定位技术、GIS 技术等综合应用于城市停车位的采集、管理、查询、预订与导航服务，实现停车位资源的实时更新、查询、预订与导航服务一体化，实现停车位资源利用率的最大化、停车场利润的最大化和车主停车服务的最优化。 此项目的目标对象有两类用户：一类是普通车主，另一类是停车场管理员，普通车主端用微信小程序实现，停车场管理员端则是Web端实现，本篇博客介绍的也就是管理员端。 技术实现技术栈介绍本智慧停车管理项目涉及的技术栈如下图： 智慧停车管理项目技术栈 实现方案之前我写过2篇博客详细地介绍了项目中两个功能实现过程，如感兴趣，请移步下面的两篇文章： 实现方案——停车场车位使用情况可视化 此博客介绍了停车位可视化功能的实现方案。 实现方案——实时通知提醒显示 此博客介绍了实现通知实时提醒的功能的实现方案。 系统功能划分根据业务和开发难度，我把智慧停车系统的管理员端大致划分了三个功能模块，分别是信息发布和维护模块，可视化模块，数据分析模块。 智慧停车系统功能分解图 系统演示1、首页 首页 2、登录页面 登录页面 3、公告发布页面 公告发布页面 4、公告板页面 公告发布成功跳转到公告板，在这里，管理员可以查看自己已发布的全部的公告。 公告板页面 5、公告详情页面 在公共详情页，车主可以提问，管理员可以回复车主的问题。 公告详情页面 6、停车场选择页面 一个管理员可以选择要查看的停车场。 展示该管理员管理的停车场 7、停车位使用情况可视化页面 此页面在室内地图上以停车位的颜色的形式区分占用or空闲，可视化出当前停车场停车位的使用情况，并且当点击某个停车位区块，就会触发事件，如果该车位是占用状态，会显示出车牌号。 停车位可视化页面 8、历史停车数据页面 历史停车数据 9、报表 根据历史停车数据生成折线图","tags":[{"name":"项目","slug":"项目","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"数据结构与算法——排序学习笔记","date":"2020-05-24T02:55:31.000Z","path":"2020/05/24/数据结构与算法——排序学习笔记/","text":"本篇博客是记录我学习排序算法的学习笔记，目前更新到了几种常用的、基于比较的排序：冒泡、选择、堆、插入、归并、快速6种排序方式，还有一些排序方式希尔排序、计数排序、基数排序、桶排序，待更。 每种排序算法的介绍都从排序思路、实例计算、代码实现、算法分析几个角度展开。 另外请注意本文提到的排序全都默认是升序排序。 冒泡排序（Bubble Sort）排序思路每一轮冒泡过程依次比较每两个相邻的元素，将值大的元素交换到右边，经过一轮冒泡过程后，最大的元素就被交换到了最后一位，进行下一轮冒泡过程时，忽略上一轮最后一位的元素，循环直到所有元素有序（也就是经过了n-1轮冒泡）。 实例计算下图给出了使用冒泡排序对数组{3，2，4，1}进行排序的过程。 冒泡排序的实例计算过程 以上图的第一轮冒泡为例讲解详细冒泡过程：首先进行比较①：比较3和2，发现3比2大，所以交换，数组变成2，3，4，1；然后进行比较②，注意此时第二个元素已经变成3了，所以这里比较②比较的是3和4，发现3比4小，所以无需交换，数组仍然是2，3，4，1；然后进行比较③，发现4比1大，所以交换，数组变成了2，3，1，4。 经过第一轮排序后，数组中最大的元素放到了数组的末尾，所以第二次冒泡不用再考虑这个元素。也就是说，第二次冒泡的只需要进行两次比较了，以此类推。 代码实现1234567891011121314/** * 冒泡排序的实现 * @param array 需要升序排序的整型数组 */public static void bubbleSort(Integer[] array) &#123; for (int end = array.length - 1; end &gt; 0; end--) &#123; for (int begin = 1; begin &lt;= end; begin++) &#123; //这相邻的两个元素中，如果前面的元素比后面的元素大，交换 if (array[begin] &lt; array[begin - 1]) &#123; swap(array, begin, begin - 1); &#125; &#125; &#125;&#125; 算法分析时间复杂度：O(n^2)。 针对冒泡排序还有一种针对最后一些元素局部有序的优化思路，如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数，这里不展开了。 空间复杂度：O(1) 稳定性: 稳定 选择排序（Selection Sort）排序思路每轮选择遍历数组中的未排序部分选出最大的数，与数组中最后一个未排序的元素交换位置，如此一来，没经过一轮选择，最大的数字就被交换到了未排序元素的最后，这个元素就可以被认为是有序的了，下一轮选择时忽略这个已排序的数字，循环直到所有元素有序（也就是经过了n-1轮选择）。 实例计算下图给出了使用选择排序对数组{3，2，4，1}进行排序的过程。 选择排序的实例计算过程 以上图第一轮选择为例：遍历发现4是最大的元素，就交换元素4和末尾元素1的位置，得到3，2，1，4。 代码实现123456789101112131415161718/** * 选择排序的实现 * * @param array 需要升序排序的整型数组 */public static void selectionSort(Integer[] array) &#123; //end记录当前数组中未排序部分的最后一个元素的下标 for (int end = array.length - 1; end &gt; 0; end--) &#123; //记录这一轮选择中的最大元素的下标 int indexOfMax = 0; for (int i = 1; i &lt;= end; i++) &#123; if (array[i] &gt; array[indexOfMax]) &#123; indexOfMax = i; &#125; swap(array, indexOfMax, end); &#125; &#125;&#125; 算法分析时间复杂度：O（n^2），选择排序的流程和冒泡排序的流程类似，都是每经过一轮，可以获得数组中当前未排序部分的最大元素，但是可以看到，选择排序的交换(swap)次数远小于冒泡排序的交换次数，所以平均性能会更好一点。 空间复杂度：O（1） 稳定性： 不稳定。 需要注意选择排序是不稳定的！比如说数组是： 3a ,2a,2b,3b。按照上面选择排序的代码来执行， 经过第一轮选择后变成了：3b,2a,2b,3a,而经过第一轮选择后，3a就固定在了最后一位，也就是说3a的位置本来在3b的前面，经过排序后，位置变成了在3b的后面，所以说这种排序算法是不稳定的。 探究其原因，这是因为当前最大值初始是3a（indexOfMax=0），即使后面遇到了3b，因为不满足array[i] &gt; array[indexOfMax]条件，最大值依旧被认为是3a而不是3b。这时候你可能会想到，把代码中的判断条件改成 array[i] &gt; =array[indexOfMax]，如此一来，第一轮选择的结果就变成了：3a,2a,2b,3b，这样的话3a和3b的相对顺序就不会被破坏,但是别着急下结论，以此类推， 第二轮选择的结果是：2b,2a,3a,3b,第三轮的选择是：2b,2a,3a,3b。选择排序结束，可以看到2b和2a的相对顺序发生了改变，也就是说，即使判断条件改了，还是可能不稳定！ 堆排序 (Heap Sort)排序思路其实堆排序的思路和选择排序的思路类似：也是想办法先从数组中未排序部分找出最大值，然后放到数组的末尾，只不过找未排序部分中的最大值的策略不一样：选择排序中，由于未排序部分没有什么特殊的性质，只能直接通过遍历一遍，来找到最大值，显然这一过程的时间复杂度是O(n)，而在堆排序中巧妙地用到了最大堆的特性，把数组中未排序部分建成一个最大堆，这样找最大元素值的复杂度就变成了O（1）（不过为维持最大堆的特性就需要额外的O(logn)开销）。 如果对最大堆的含义和性质、建立过程还不清楚的话，可以参考我的这篇博客： 数据结构与算法—二叉堆学习笔记。 总体来说，堆排序的排序流程是这样的： 第一步：对需要排序的数组原地建最大堆(heapify操作)。 这一步可以通过自下而上（从最后一个非叶子结点开始递减至根节点）的下沉操作完成，时间复杂度是O(n)。 第二步：开始进行选择未排序部分中的最大元素操作，并交换到未排序部分的最后，循环下面三步操作直到堆的大小减小为1。 2.1 交换堆顶元素和堆中的最后一个元素。 2.2 堆的大小减小1，也就是说，上一步操作被放到最后的元素被排除在堆外。 2.3 对现在的堆顶元素（也就是空降上来的、2.1步中的最后一个元素）进行sinkDown下沉操作。 可以看到，每进行一轮第二步的操作（2.1、2.2、2.3），就会选出未排序部分中的最大值放到未排序数组的末尾，这样一来最后一个元素就成为有序的了，这也是为什么堆的size减小的原因，因为最大堆只维护未经排序的部分。 实例计算下图给出了使用堆排序对数组{3，2，4，1}进行排序的过程。 堆排序的实例计算过程 注意：图上红色结点是已经不属于当前堆的结点，因为它们已经是排序了的，而堆中只会保留当前所有未被排序的部分。 代码实现这里给出了堆排序要用到的的核心方法：siftDown下沉操作，在堆排序的第一步建堆和第二步排序中都会用到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** 堆排序的实现 * @param array 要排序的整型数组 */ public static void heapSort(Integer array[]) &#123; //堆排序的第一步：在array数组上原地建堆 heapify(array); //记录当前未排序部分构成的堆的大小，初始大小为待排序数组的长度 int heapSize = array.length; //堆排序的第二步: while (heapSize &gt; 1) &#123; swap(array, 0, heapSize - 1); heapSize--; siftDown(array, heapSize, 0); &#125; &#125;/** 最大堆的下沉操作 * @param heap 存储最大堆的数组 * @param size 当前最大堆的大小 * @param index 要下沉的结点在数组中的下标 */ public static void siftDown(Integer[] heap, int size, int index) &#123; //2*i+1&lt;size说明 int leftChildIndex = 2 * index + 1; //记录index结点的左右孩子中较大的孩子的下标 int bigChildIndex; while (leftChildIndex &lt; size) &#123; //大孩子下标默认为左孩子下标 bigChildIndex = leftChildIndex; //如果右孩子存在且右孩子的值大于左孩子 if (leftChildIndex + 1 &lt; size &amp;&amp; heap[leftChildIndex + 1] &gt; heap[leftChildIndex]) &#123; bigChildIndex = leftChildIndex + 1; &#125; //然后当前结点和大孩子进行比较,如果小于大孩子需要交换 if (heap[index] &gt;= heap[bigChildIndex]) &#123; break; &#125; swap(heap, index, bigChildIndex); index = bigChildIndex; leftChildIndex = 2 * index + 1; &#125; &#125; /**把一个任意整型数组建成最大堆（利用数次下沉操作） * @param array 要被建立成最大堆的整型数组 */ public static void heapify(Integer[] array) &#123; //从最后一个非叶子结点开始下沉操作 for (int i = array.length / 2; i &gt;= 0; i--) &#123; //array表示堆存储的数组，array.length表示堆的大小 siftDown(array, array.length, i); &#125; &#125; 算法分析时间复杂度：第一步通过自下而上的下沉的建堆过程的时间复杂度是O(n)，而第二步每一轮（2.1、2.2、2.3的三个操作）时间复杂度是O(logn)，第二部会循环次数约为n次（实际上是n-1次，每次选个未排序中的最大元素使其有序），所以堆排序第二步的时间复杂度是n*O(logn)。所以总的来说，时间复杂度是O(n)+O(nlogn)。 综上所述，堆排序最好最坏时间都是复杂度：O(nlogn)，说的更精确一点就是O(n)+O(nlogn)。 空间复杂度：O(1) 稳定性：不稳定。 比如：5,4a,4b,4c: 第一轮选择出5作为最大元素，与4c交换，然后4c就成为堆顶了，无需调整，4c会成为第二个被选择的元素。 插入排序（Insertion Sort）排序思路插入排序的排序思路和平时打扑克牌时理牌一样：打牌时，我们在左手拿着已经理好顺序从小到大的牌，右手从桌面拿了一张大小不确定的牌，然后把它插入到左手牌堆的合适的位置使得左手的所有牌仍然是有序的，重复直到牌抓完了，最后左手的牌肯定是有序的。这里很形象地类比了插入排序的要素：插入排序将要排序的序列分成两部分：一部分是已排序部分，另外一部分是未排序部分，然后将未排序部分的第一个元素插入到已排序部分的合适位置，这样的话这个元素也成为已排序的了，直到未排序部分为空，排序完成。 实例计算 堆排序的实例计算过程 如上图，插入排序的每一轮都会选出第一个未排序的数字，将其插入到左边已排序部分的合适位置。 代码实现1234567891011121314/** * 插入排序的实现 * @param array 需要排序的数组 */public static void insertSort(Integer array[]) &#123; //begin为第一个未排序元素的下标,此下标会不断后移一位直到所有元素都排序 for (int begin = 1; begin &lt; array.length; begin++) &#123; int i = begin; while (i &gt;= 1 &amp;&amp; array[i] &lt; array[i - 1]) &#123; swap(array, i, i - 1); i--; &#125; &#125;&#125; 上面的插入排序的代码可以优化一下：先将待插入的元素备份,确定了位置再把待插入元素插入。 1234567891011121314151617181920/** * 插入排序的实现（优化后） * @param array 需要排序的数组 */public static void insertSort2(Integer array[]) &#123; //begin为第一个未排序元素的下标,此下标会不断后移一位直到所有元素都排序 for (int begin = 1; begin &lt; array.length; begin++) &#123; int i = begin; //iValue备份了要插入的元素 int iValue = array[i]; //比较待插入元素与array[i - 1] while (i &gt;= 1 &amp;&amp; iValue &lt; array[i - 1]) &#123; array[i] = array[i-1]; i--; &#125; //确定了插入位置后一步到位完成赋值操作 array[i] = iValue; &#125;&#125; 这样一来，能减少中间过程的赋值次数，这个优化思路其实很多地方都有用到，比如说二叉堆的上浮和下沉操作。 插入排序还有一种优化方式：结合二分查找确定待插入的那个元素在已排序部分的插入位置，这里就不展开了。 算法分析时间复杂度：最坏、平均时间复杂度是O(n^2)，最好时间复杂度是O(n)（也就是当待排序数组已经是升序的）。实际上，插入排序的算法时间复杂度和逆序对的数量成正比关系，逆序对的数量越多，插入排序的时间复杂度就越高，当逆序对数量很少、待排序数组几乎有序的情况下，插入排序甚至比快速排序还快。 空间复杂度：O(1) 稳定性：稳定 归并排序（Merge Sort)排序思路归并排序是典型的分治算法。分治算法的基本思路是把一个复杂的问题分成两个或更多的性质相同而规模更小的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 《算法导论》中将分治算法归纳为分解、解决、合并三个步骤，这三个步骤在归并排序中的是怎么体现的呢？ 分解：把原问题中对数组排序，分解成2个子问题——对数组的左半部分排序和对数组的右半部分排序。 解决：如果待排序数组的规模够小（只有一个元素），直接返回，否则继续分解成更小的子问题，递归解决。 合并：把两个子问题排序的结果合并，合并成有序数组。 实例计算 选择排序的实例计算过程 代码实现归并排序中最关键的就是把array[begin…mid] 和 array[mid+1…end]这两个已经有序的数组合并，也就是merge方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 归并排序的实现 * * @param array */public static void mergeSort(Integer array[]) &#123; mergeSort(array,0,array.length-1);&#125;/** * 归并排序的辅助函数 * @param array * @param begin * @param end */public static void mergeSort(Integer array[],int begin,int end)&#123; //如果不超过两个元素。 if(begin&gt;=end) &#123; return; &#125; int mid = (begin+end)/2; mergeSort(array,begin,mid); mergeSort(array,mid+1,end); merge(array,begin,mid,end);&#125;/** * 合并两个有序数组。注意这里说的两个有序数组只是逻辑上可以看作是两个有序数组，实际上它们存储在一个数组里 * 需要合并的数组分别是： array[begin...mid] 和 array[mid+1...end] */public static void merge(Integer array[],int begin,int mid,int end) &#123; Integer res [] = new Integer[end-begin+1]; int p=0,p1=begin,p2=mid+1; while(p1&lt;=mid &amp;&amp; p2&lt;=end)&#123; if (array[p1] &lt;= array[p2]) &#123; res[p++] = array[p1++]; &#125; else &#123; res[p++] = array[p2++]; &#125; &#125; //退出循环，说明有一个数组的全部元素都已经全部加入到res数组了,另一个数组的部分元素还没加入，就将其剩余元素都加入进来 while (p2 &lt;= end) &#123; res[p++] = array[p2++]; &#125; while (p1 &lt;=mid) &#123; res[p++] = array[p1++]; &#125; //复制res数组到array数组 for(int i=begin;i&lt;=end;i++)&#123; array[i] = res[i-begin]; &#125;&#125; 归并排序的merge方法有一个细节:需要进行merge操作的两组序列存储在同一个数组中，并且是挨在一起的。合并操作要开辟额外的空间，可以只开辟一个临时数组（用于保存左半边），然后直接在原数组修改。下面的代码时开辟了一整个数组然后复制：优化后的merge(只开辟左半部分的空间): 123456789101112131415161718192021222324252627/** * 合并两个有序数组。注意这里说的两个有序数组只是逻辑上可以看作是两个有序数组，实际上它们存储在一个数组里 * 需要合并的数组分别是： array[begin...mid] 和 array[mid+1...end] */public static void merge(Integer [] array,int begin,int mid,int end) &#123; Integer [] leftCopy = new Integer[mid-begin+1]; for(int i=begin;i&lt;=mid;i++)&#123; leftCopy[i-begin] = array[i]; &#125; int p=begin,p1=0,p2=mid+1; while(p1&lt;leftCopy.length &amp;&amp; p2&lt;=end)&#123; if (leftCopy[p1] &lt;= array[p2]) &#123; array[p++] = leftCopy[p1++]; &#125; else &#123; array[p++] = array[p2++]; &#125; &#125; //退出循环，说明有一个数组的全部元素都已经全部加入到res数组了,另一个数组的部分元素还没加入，就将其剩余元素都加入进来 while (p2 &lt;= end) &#123; array[p++] = array[p2++]; &#125; while (p1 &lt;leftCopy.length) &#123; array[p++] = leftCopy[p1++]; &#125;&#125; 其实merge方法还可以进一步优化：上面的代码中，每次调用merge方法，都会开辟一次左半边的数组，事实上我们可以只开辟一次（大小定为原数组的一半），也像array一样作为调用时的参数传入，这样的话从头到尾只需要用到一个长度为原数组一半的临时数组，这里就不展开了。 算法分析时间复杂度：归并排序是递归实现的，其递归表达式是T(n) =2*T(n/2)+O(n) （n&gt;=2），T(1)=O(1), 对应的时间复杂度是O(nlogn) 空间复杂度：因为进行合并操作时要用到临时数组存放左半边的有序数组，开辟了额外空间，归并排序的空间复杂度是O(n) 稳定性：稳定，归并排序分解和合并两个步骤中，，分解只是确定两个子数组的下标，合并操作时才会交换元素的位置，而需要合并的两个有序数组是原数组的左左边和右半边数组，只要保证如果左右数组有元素相等的情况下，左边的数组优先就能保证稳定。 比如说合并数组：1a,4, (左半边)| 1b,5。 合并结果是 1a,1b,4,5。 快速排序排序思路和归并排序，快速排序的思想也是分治。 快速排序的过程是： 1．先从数组中取出一个数作为基准数。 2．分区过程，将不小于基准数的数全放到它的右边，不大于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数。 实例计算 快速排序的实例计算过程 代码实现在实现快速排序时，最重要的方法就是partition方法，它的作用是选择一个基准点（我的代码中选择第一个元素作为基准点），然后以某种策略调整数组，用来把乱序数组划分成为3部分：所有元素值都不大于基准点的左半部分 | 基准点 | 所有元素值都不小于基准点右半部分，此方法的返回结果是调整后基准点的下标。 注意：调整数组来把基准点放在合适位置有多种不同的实现方式，所以partition方法也有多种不同的实现思路，不过其目的都是一样的。 快速排序的完整代码如下（分别给出了两种不同思路的partition实现）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public static void quickSort(Integer array[]) &#123; quickSort(array, 0, array.length - 1); &#125; /** * 对array[begin...end]进行排序 */ public static void quickSort(Integer array[], int begin, int end) &#123; if (end &lt;= begin) &#123; return; &#125; int mid = partition2(array, begin, end); quickSort(array, begin, mid); quickSort(array, mid + 1, end); &#125; /** * 元素array[begin]作为轴点，将轴点放在合适位置，使左边的元素全都不大于它，右边的元素全不小于它 * * @return 返回值是轴点插入位置的下标，调用者根据它可以将原数组划分成两个子数组 */ public static int partition(Integer array[], int begin, int end) &#123; //备份轴点值 int pivotValue = array[begin]; while (begin &lt; end) &#123; while (end &gt; begin &amp;&amp; array[end] &gt;= pivotValue) &#123; end--; &#125; //此时array[begin]的位置是无效元素（已经备份了） array[begin] = array[end]; while (begin &lt; end &amp;&amp; array[begin] &lt;= pivotValue) &#123; begin++; &#125; //此时array[end]的位置是无效元素（已经备份了） array[end] = array[begin]; &#125; //退出循环时，begin必然等于end，因为始终只有一个指针在移动 array[begin] = pivotValue; return begin; &#125;/*** partition的另一种实现思路*/ public static int partition2(Integer array[], int begin, int end) &#123; //备份轴点值 int pivotValue = array[begin]; int beginCopy = begin; while (begin &lt; end) &#123; while (end &gt; begin &amp;&amp; array[end] &gt;= pivotValue) &#123; end--; &#125; //一旦上一个while循环退出，说明 array[end] &lt; pivotValue 或者 begin==end while (begin &lt; end &amp;&amp; array[begin] &lt;= pivotValue) &#123; begin++; &#125; //一旦上一个while循环退出，说明 array[begin] &gt; pivotValue 或者 begin==end //到这里，说明array[end] &lt; pivotValue且array[begin] &gt; pivotValue 或者 begin==end。无论是那种情况，都可以交换下标begin、end对应的元素。 swap(array, begin, end); &#125; //交换 swap(array, beginCopy, begin); return begin; &#125; 算法分析时间复杂度：平均时间复杂度是O(nlogn)，最坏时间复杂度是O(n^2)。 理想情况下，我们希望每次经过partition操作之后，能将原数组划分成平均的两部分。这样一来，原问题也是被划分成两个规模相等的子问题（它们的规模都是原问题的一半），也就是说在左右平均的情况下，递归表达式是T(n)=2T(n/2)+O(n)，（后面的O(n)是执行partition操作的时间复杂度）,对应的时间复杂度是O(nlogn)。 而在最坏情况下，如果划分的左右数组元素数量极度不均匀（比如说选出的基准点始终是最大或最小值），递归表达式是T(n)=T(n-1)+O(n)，对应的时间复杂度是O(n^2)。为了降低最坏情况出现的概率，可以采取随机选择轴点元素的方式（写代码的时候仍旧可以选择第1个作为轴点元素，不过在此之前先随机挑一个元素和它互换位置）。 partition操作是O(n)级别的 空间复杂度：因为涉及到递归调用造成栈空间的使用，空间复杂度是O(logn) 稳定性：不稳定。 十大排序算法总结 算法 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 冒泡排序 O(n^2) O(n) O(n^2) O(1) 稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn) 不稳定 备注：上表中冒泡排序的最好时间复杂度是O(n)针对的是优化后的冒泡排序：优化的冒泡排序中每次冒泡过程会记录最后交换的位置，此优化对于最后一些元素已经局部有序的情况有效，当数组已经是有序状态，有最好的时间复杂度，为O(n)。","tags":[{"name":"置顶文章","slug":"置顶文章","permalink":"http://hfq123.github.io/tags/%E7%BD%AE%E9%A1%B6%E6%96%87%E7%AB%A0/"},{"name":"算法","slug":"算法","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法—二叉堆学习笔记","date":"2020-05-22T04:36:36.000Z","path":"2020/05/22/数据结构与算法—二叉堆学习笔记/","text":"本篇博客是我学习数据结构与算法的笔记，分享主题是「二叉堆」。 引入二叉堆是什么？以下给出一些二叉堆的定义： 堆（Heap）是一种树状的数据结构，它有一个重要性质：任意节点的值总是大于等于或小于等于子节点的值。 如果任意节点的值总是大于等于子节点的值，称为最大堆。 如果任意节点的值总是小于等于子节点的值，称为最小堆。 而二叉堆的逻辑结构就是一颗完全二叉树，由于完全二叉树的一些性质，代码实现时可以用数组存储，下文会详细介绍。 一个最大堆示例 为什么要引入二叉堆这个数据结构？ 想象这样一个场景：我们要设计一种数据结构，用来存放未知数量的整数，我们可以随时向其添加任意整数，在使用时,我们特别关注它的最大值，而不关心其他值, 除了添加元素操作之外，还有两个操作分别是：获取当前这个数据结构的最大值、删除最大值。 这个数据结构可以用线性表、BBST（如AVL、RBT）实现，它们的时间复杂度分析如下表： 数据结构 获取最大值时间复杂度 删除最大值时间复杂度 添加元素时间复杂度 有序的动态数组 O（1） O(1) O(n) 红黑树 O(logN) O(logN) O(logN) 针对此需求，有没有更优的数据结构？ 我们发现，无论是维护元素顺序的动态数组还是红黑树都考虑了整个数据结构的顺序。有序数组不用多说，至于红黑树，构建时也间接维护了每个元素之间大小关系，其中序遍历结果是有序的。 而在需求中，我们重点关注对象的是这个数据结构的最大值，不在乎其他元素的大小顺序，维护整个数据结构的顺序显得有些“杀鸡用牛刀”的感觉。 实际上，这一需求就能用最大堆来实现，使获取最大值、添加元素、删除最大值这三个操作都有不错的效率： 获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn)。 代码实现此部分以最大堆为例，给出代码实现。 在写代码前，先研究一下二叉堆的特性，前面已经提到了二叉堆的逻辑结构就是一棵完全二叉树，完全二叉树的结构可以存储在数组里，根据索引的关系就能计算出每个结点的父结点、子结点： 二叉堆的特性 在二叉堆的接口设计中：重点关注这三个操作：获取最大值、添加元素、删除最大值。 获取最大值这一操作很简单，根据最大堆的定义，任意节点的值总是大于等于子节点的值，所以根节点的值就是最大值，也就是说，数组的首元素就是最大值。 添加元素时，直接添加到最大堆的最后，但是这可能会破坏最大堆的结构，所以需要上浮(sift up)操作：如果插入的结点元素值比父节点元素值大，就要交换两者位置，循环直到插入结点的元素值不大于父节点的值或者插入结点已经上浮成为根节点（也就是说此节点没有父节点了）退出循环。 12345678910111213141516171819202122232425262728293031/** * 添加元素到最大堆 * @param element 要插入的元素值 */void add (E element)&#123; elements[size]=element; //插入到数组的最后 siftUp(size); //对刚才添加的元素执行“上浮”操作 size++;&#125;/** * 上浮操作，调整插入元素的位置 * @param index 需要上浮操作的数组元素的索引 */void siftUp(int index)&#123; int pIndex = 0; //父节点的索引 E value = elements[index],pValue; //自己的元素值和父节点的元素值 while (index&gt;0)&#123; //只要还有父节点，就循环 pIndex = (index-1)/2; //父节点的索引 pValue = elements[pIndex]; //父节点的元素值 if(cmp(value,pValue)&lt;=0)&#123; //cmp函数用于比较两个元素的大小 break; &#125; //如果大于父结点，就交换。 //E tmp = elements[index]; ---标注1 elements[index] = elements[pIndex]; //elements[pIndex] = tmp; ---标注2 index = pIndex; &#125; elements[index] = value; //----标注3&#125; 在上述代码，处理上浮操作的时候有一个小细节：在循环中，如果插入结点元素值比父节点要大，就要交换当前结点和父节点的位置，按理说交换操作应该是三步走：临时变量保存本结点的元素值（代码中标注1），本结点元素值=父节点元素值，父节点元素值=临时值（代码中标注2），然而这里由于每次比较的都是父节点和待插入结点的值，所以可以将新添加节点备份，确定最终位置才摆放上去（代码中标注3）。 删除最大值时，并不是直接删除根节点，而是先用最后一个结点的值覆盖根节点的值，然后再删除最后一个结点。 最后一个结点的值覆盖根节点的值这可能又会破坏最大堆的结构，所以需要下沉(sift down)操作。 12345678910111213141516171819202122232425262728293031323334353637/** * 移除最大值（也就是数组的首个元素） */void remove()&#123; if(size==0) &#123; return; &#125; elements[0] = elements[size-1]; //用最后一个元素值覆盖首结点的元素值 elements[size-1] = null; //真正移除的是最后一个元素 size--; siftDown(0);&#125;/** * 下沉操作，删除最大值后调用 * @param index */void siftDown(int index)&#123; int leftChild; int bigChild; //记录左右孩子中较大的那个的索引 E value = elements[index]; while(index&lt;size/2)&#123; //只要还有子结点 也就是左孩子索引2i+1&lt;size，也就是i&lt;(size-1)/2 leftChild = 2*index+1;//左孩子索引 bigChild = leftChild; //大孩子默认为左孩子（因为右孩子可能不存在） if(leftChild+1&lt;size &amp;&amp; cmp(elements[leftChild+1],elements[leftChild])&gt;0)&#123; //第一个条件表示右孩子存在，第二个条件表示右孩子比左孩子大 bigChild = leftChild +1; &#125; if(cmp(elements[bigChild],value)&lt;=0)&#123; break; &#125; //如果大孩子的值比自己大，才进行后续操作 elements[index] = elements[bigChild]; index = bigChild; &#125; //退出循环时，要么就是该节点已经下沉到最底了(没有子结点了)，要么就是该节点已经到了大于等于所有子结点的位置 elements[index] = value;&#125; 二叉堆的接口设计中，除了上面这三个最重要的方法，还有一些别的方法： replace(E element) 删除最大值的同时插入一个新元素：用元素element代替根节点的值，然后进行下沉(siftDown)操作。 批量建堆,也就是把一个没有规律的数组建立成堆： 有两种办法。 方法1：自上而下的上浮O(nlogn)：本质是一个个添加 12345678/** * 自上而下的上浮 */void heapify1()&#123; for(int i=1;i&lt;size;i++)&#123; siftUp(i); &#125;&#125; ​ 方法2：自下而上的下沉O(n)。 12345678/** * 自下而上的下沉 */void heapify2()&#123; for(int i=size/2;i&gt;=0;i--)&#123; //从非叶子结点开始下沉 siftDown(i); &#125;&#125; 注意：自上而下的下沉或者自下而上的上浮都不能作为批量建堆的方法。 应用1、Top K问题 从n个数里找出最大的k个数。（k&lt;&lt;n） ◼ 如果使用排序算法（如快速排序）进行全排序，需要 O(nlogn) 的时间复杂度。 把所有数都排序了，杀鸡用牛刀。 ◼ 如果使用进行k次局部排序（每次选出未处理的元素中的最大值放到前面），需要 O(n*k) 的时间复杂度。 处理完毕后，最大的k个数也排序了，需求中这最大的k个元素也不需要排序，似乎多此一举。 ◼而如果使用二叉堆（最小堆）来解决，可以使用 O(nlogk) 的时间复杂度来解决。 建立一个大小为k的堆，先把数组n中的前k个元素添加到堆，然后对剩余元素做如下处理： 如果n数组中的当前元素大于堆顶元素，就用它代替最小堆堆顶元素，并进行sift down操作，以维护堆的性质。 如果当前元素小于堆顶元素，什么都不用做，继续访问下一个元素。 最后，堆中的k个数字就是最大的K个数，完美解决。 2、优先级队列 jdk的PriorityQueue就是二叉堆（最小堆）实现的。 这里截取部分代码看看：这不就是我们的siftUp上浮操作吗！ JDK的PriorityQueue实现部分代码截图 另外多说一句，在我写代码的时候，直接把两个元素的比较逻辑封装起来——在二叉堆类中组合了一个比较器对象(Compartor类型)，如果有外部比较器，就用外部比较器的逻辑比较，否则强制转成Comparable接口比较，像下面这样： 123456int cmp(E e1,E e2)&#123; if(comparator!=null)&#123; return comparator.compare(e1,e2); &#125; return ((Comparable)e1).compareTo(e2);&#125; 这样把比较逻辑封装起来之后的好处就是写代码时很简洁，但是仔细一想也有缺点：每次比较任何两个元素时都会判断比较器是否为空，再决定这两个元素比较的逻辑，这其实是没必要的，做了很多多余的判断，这也是为什么JDK实现中分为了siftUpComparable和siftUpUsingComparator，看上去有些啰嗦，实际上减少了判断次数。 关于优先级队列的更详细内容，推荐阅读:PriorityQueue详解。 总结最后做一个简单总结。 用于维护二叉堆性质的的上浮和下沉操作： sift up 上浮：添加元素时直接添加到数组末尾，可能会破坏二叉堆性质——每个结点元素值必须大于子结点元素值，所以要上浮找到新元素的合适插入位置，想象一下如果把一个最大的元素值插入到了数组末尾后，会一直上浮到根节点。 sift down 下沉: 当要删除最大值的时候，直接让最后一个元素”空降“替代最大值，这种”空降“也可能会破坏二叉堆性质，所以要下沉，直到让”空降“的末尾节点找到合适的位置。 最大堆和最小堆的”无缝切换“ 另外值得一提的是，我上面写的代码是最大堆的实现，如何在此基础上修改成最小堆呢？ 实际上不用修改封装好了的二叉堆类的代码，只要调用代码处指定自定义的比较器就好了。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构之树学习小结","date":"2020-05-20T05:33:29.000Z","path":"2020/05/20/数据结构与算法—树学习笔记/","text":"此系列是我数据结构的学习笔记，观看视频课程，网上有很全面的笔记了，节约时间，细节没有再展开。 本篇博客分享主题：「树」，简单总结一下近期学的二叉搜索树、平衡二叉搜索树、红黑树，重点介绍二叉搜索树。 基本认识二叉搜索树(Binary Search Tree),又叫做二叉查找树、二叉排序树。 任意一个节点的值都大于其左子树所有节点的值。 任意一个节点的值都小于其右子树所有节点的值。 它的左右子树也是一颗二叉搜索树。 一棵二叉搜索树（BST） 为什么要引入二叉搜索树，需求是什么？ 在乱序数组中插入元素，搜索操作平均时间复杂度O(n)，插入操作复杂度O(1) 排好序的数组，二分搜索，最坏时间复杂度O(logn),但插入、删除操作平均复杂度是O(n) 使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)））（更准确得说是O(h),h为树高） 而后面学到的平衡二叉搜索树（AVL）、红黑树（Red Black tree）都是特殊的二叉搜索树，它们主要是为了解决BST太不平衡时效率退化的问题，只不过为了维持二叉树的(相对)平衡，它们有各自附加的要求。总的来说，添加、删除节点这两个基本操作都是一样的，只不过对于AVL和RBT来说，在添加或删除元素之后，可能会破坏树原来的性质，所以需要一些额外的操作（对于AVL来说是旋转，对于RBT来说是着色和旋转）来维持树的性质，以达到更好的性能。 退化成链表的二叉搜索树时间复杂度就变成了O(n)，那么AVL和RBT是怎么优化的呢？AVL树的节点除了维护节点的左右父节点的指针之外，还会维护此节点的高度，AVL树规定每个节点的平衡因子只可能是1，0，-1，否则，称之为失衡。添加和删除节点后可能会导致失衡，我们就做一些额外的操作让它重复恢复平衡就行,具体又分为LL、RR和LR、RL的旋转情况，本文不再展开。 上面那棵BST等价的AVL树 而红黑树的节点除了维护节点的左右父节点的指针之外，还会维护此节点的颜色,红黑树的性质比起AVL更加复杂： 1、节点是RED或者BLACK2、根节点是BLACK3、叶子节点（外部节点，空节点）都是BLACK4、RED节点的子节点都是BLACK RED节点的parent都是BLACK 从根节点到叶子节点的所有路径上不能有2个连续的RED节点 5、从任意节点到叶子节点的所有路径都包含相同数目的BLACK节点。 上面那棵BST等价的红黑树 BST的插入删除操作插入操作比较简单，只需要不断将要插入结点的值和当前工作节点比较，如果待插入节点的值比当前节点的值大，就往左走，否则就往右走，直到工作节点为空，就确定了插入位置。 查找的操作也类似。 删除需要考虑三种情况：度为0、1、2。 度为2： 令后继结点的元素值覆盖删除结点，然后删除后继节点，后继节点的度必为0/1，所以就转化成了下面的两种情况 (ps.取前驱节点替代也可以）度为1： 使删除结点的父节点指向删除结点的子结点，注意删除的是根节点的特殊情况度为0： 直接删除，注意删除的是根节点的特殊情况 常用方法遍历(适用所有二叉树) 前序遍历(Preorder)，访问顺序： 根节点 -&gt; 前序遍历左子树 -&gt; 前序遍历右子树递归实现。 中序遍历(Inorder)，访问顺序：中序遍历左子树 -&gt; 根节点 -&gt; 中序遍历右子树 中序遍历的结果是有序的，因为根据BST的定义，左&lt;中&lt;右。 后序遍历(Postorder)，访问顺序：后序遍历左子树 -&gt; 后序遍历右子树 -&gt; 根节点 层序遍历(Level Order)，访问顺序：从上到下，从左到右依次访问节点。 对于前中后序遍历来说，既可以用递归实现，还可以非递归实现(栈)。 参考我的其他博客： 前序遍历的非递归实现 后序遍历的非递归实现 一棵二叉树的遍历结果 求前驱节点和后续节点一个节点的前驱节点和后续节点分别指的是树的中序遍历结果中这个节点的前一个结点和后一个结点，计算前驱节点的思路如下： 如果此节点有左子树，必定有前驱节点，前驱节点=node.left.right…right 如果此节点没有左子树，但是有根节点，则可能有前驱节点，前驱节点=node.parent.parent…直到当前结点是父节点的左孩子。 否则，返回null 后续节点同理。 设计思想这一部分，简单谈一谈设计BST类代码时候的设计模式，可供参考，把代码写的优雅一点。 策略模式从二叉搜索树的定义来看，涉及到比较操作，所以二叉搜索树存储的元素必须具备可比较性。 一方面，我们可以规定节点元素必须是可比较的，也就是使节点元素的类实现Comparable接口，里面实现compareTo方法，又可以在BST类中加入一个外部比较器，可以让调用者自行决定使用什么比较方法来比较元素大小。详情不再展开，参考比较器comparable与comparator的使用 模板方法模式BST类是父类，AVL和RBT是子类。我们前面说了，在BST中的插入删除方法，只需要做基本操作，而AVL和RBT的插入删除操作之后，还需要做一些额外操作来维持树的性质，所以在设计BST这一个父类的时候，将add()和remove()方法（分别用于插入和删除结点）作为模板方法，在两个方法的最后调用afterAdd()和afterRemove()作为“钩子”，在BST类中，afterAdd()和afterRemove()这两个方法里什么都不做，而AVL和RBT子类重写它们，里面写插入/删除节点后维持树性质的代码。 这样一来，AVL和RBT这两个子类，就可以重用基本操作部分的代码。 性能比较参考动态查找树比较。 BST效率总结： 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)，和高度相关O(h)。 插入删除操作算法简单，时间复杂度与查找差不多。 AVL效率总结： 查找的时间复杂度维持在O(logN)，不会出现最差情况 AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。 AVL树在执行删除时代价稍大，可能造成O(logN)次旋转，执行每个删除操作的时间复杂度需要O(2logN)。 红黑树效率总结： 查找效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些（因为树高可能比AVL高），但也远远好于BST。 插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。 AVL树和红黑树性能对比以及选择图解 个人总结BST和AVL树和红黑树的基础，在理想情况下，它的查找、插入、删除的时间复杂度是O(logN)，但是在一些情况下，其时间复杂度会退化，极端情况下退化成链表，总的来说，BST查找、插入、删除的时间复杂度是和其整体高度正相关的。所以，AVL为了不让BST由于高度失衡而导致时间复杂度退化，就规定了平衡因子的概念，它的查找操作完全和BST一样，插入删除操作之后如果导致树失衡会做旋转操作使得恢复平衡，这样就严格控制了其平衡性（也就是控制了树的高度），所以查找、插入、删除三个操作的时间复杂度都能稳定维持在O(logN）。这里我们还有必要了解一些AVL插入和删除节点的细节:在AVL树插入节点只会造成1次旋转（单旋或双旋），而在AVL树删除节点可能会造成O(logN)次旋转（删除后，父节点失衡调整后导致其祖父节点直到根节点都失衡，都需要旋转）。 而红黑树相较于AVL树来说，对于树的平衡要求没有AVL那么高（所以说，拥有同样多节点的树，红黑树可能比AVL树的树高更大），虽然在红黑树节点定义中，并没有看到关于高度的定义，只有颜色的定义，但是实际上只要满足了其五条要求（在插入删除节点后可能会破坏红黑树要求，所以要进行染色和旋转操作），最后构建出来的红黑树的高度就不会像BST那样有高度严重失衡的坏情况，事实上，红黑树的最长路径长度不超过最短路径长度的2倍，所以说其查找代价还是能基本维持在O(logN)，有时查找性能或许比AVL略逊色一点（因为其高度可能比AVL大），但是其RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。 推荐阅读以下博文的笔记很详细，给出链接供查阅。 小码哥《恋上数据结构与算法》笔记（八）：二叉搜索树 小码哥《恋上数据结构与算法》笔记（九）：平衡二叉搜索树（AVL） 小码哥《恋上数据结构与算法》笔记（十）：B树 小码哥《恋上数据结构与算法》笔记（十一）：红黑树 为什么HashMap使用红黑树而不使用AVL树 另外，推荐一个可以模拟各种树构建、删除过程的网页： 构建各种树的可视化网页工具 还有一个常用的树：哈夫曼树,参考：哈夫曼树与哈夫曼编码","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Mybatis错误排查-多表联合查询时两张表字段相同造成的记录缺失的问题","date":"2020-05-13T14:37:43.000Z","path":"2020/05/13/Mybatis错误排查-多表联合查询时两张表字段相同造成的记录缺失的问题/","text":"问题背景这是在学习Mybatis框架做学习demo时遇到的问题，特此记录。 现有用户表和账户表，规定：一个用户可以有多个账户，一个账户对应确定的一个用户，即对于账户记录来说，是一对一的关系。 两张表的记录如下： image-20200513224038566 现需要使用Mybatis查询出账户表的所有记录，并且需要查询此账户记录对应的用户（利用外键uid）。 sql语句和查询结果如下： 123456789# 一个简单的内连接查询select a.id,a.uid,a.money,u.* from account a,user u where a.uid =u.id;# 此条sql语句执行的结果：1 41 1000 41 张三 2000-02-27 17:47:08 男 杭州市西湖区3 41 2000 41 张三 2000-02-27 17:47:08 男 杭州市西湖区2 45 1000 45 小胡 1999-03-04 12:04:06 男 杭州市杭州电子科技大学 账户类对应的Mapper的xml部分配置如下： 1234567891011121314151617181920 &lt;resultMap id=\"accountMap\" type=\"Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!-- 在Account类中，组合了一个User对象 --&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;!-- 查询所有账户记录（含用户信息） --&gt; &lt;select id=\"findAll\" resultMap=\"accountMap\" &gt; select a.id,a.uid,a.money,u.* from account a,user u where a.uid =u.id; &lt;/select&gt; 按照此配置测试，发现结果有两个问题： 1、只查询出两条记录信息，而实际上账户数据表中有三条账户记录。 2、账户id结果有误，两条账户记录的正确id应该分别是id=1和id=2，而不是下图中的41和45。 测试结果截图（有两处错误） 排查解决排查思路：其实根据上面执行结果出现的第二个问题就大致定位到了问题所在：账户id打印的是用户id，原因很有可能是因为这两张表的字段id重复，导致无法区分。 解决思路：为其中的一个id字段起别名，以便区分开来。 1234567891011121314151617&lt;resultMap id=\"accountMap\" type=\"Account\"&gt; ！注意此处的column修改了 &lt;id property=\"id\" column=\"accountId\"&gt;&lt;/id&gt; ....此部分和修改前一样，故省略 &lt;association property=\"user\" column=\"uid\" javaType=\"User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; ....此部分和修改前一样，故省略 &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAll\" resultMap=\"accountMap\" &gt; ！注意此处为acocount表的id 起了别名accountId。 select u.*,a.id as accountId,a.uid,a.money from account a,user u where a.uid =u.id;&lt;/select&gt; 果然，修改后，解决了，得到了正确查询结果。 修改后的正确测试结果截图 总结在使用mybatis进行多表联合查询时，如果两张表中的字段名称形同，会出现无法正常映射的问题。 问题解决办法：在SQL查询语句中时，给重复的字段 起别名，然后在column属性使用别名进行映射。","tags":[{"name":"错误排查","slug":"错误排查","permalink":"http://hfq123.github.io/tags/%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"}]},{"title":"Java基础查漏补缺之反射","date":"2020-05-12T08:17:45.000Z","path":"2020/05/12/Java基础查漏补缺之反射/","text":"反射的原理反射是什么? JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 为什么要学习反射？ “反射是框架设计的灵魂。” 大三上初学Spring框架时，就听过这句话，看了介绍反射的知识点云里雾里，完全是硬着头皮跟着做，现在学了JVM类加载过程之后，这块知识还是比较好理解的。 首先回顾一下类加载过程：加载-&gt;连接-&gt;初始化 其中加载这一步骤要做三件事： 通过类的全限定名获取此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的访问入口。 我们需要重点关注，生成的Class对象描述了这个对象的所有信息，比如都有哪些构造方法，都有哪些成员方法，都有哪些字段等，在反射中就要利用到Class对象。 反射的使用使用反射要关注以下2个重点问题。 如何获取类的Class对象?有以下3种获取类的Class对象的方法: 12345678910111213//方法1：调用类的一个实例的getClass方法Dog dog = new Dog();Class&lt;Dog&gt; dogClass = dog.getClass();//方法2：类的字面量Class&lt;Dog&gt; dogClass1 = Dog.class;//方法3：推荐！利用Class类的静态方法forName()，其参数是需要获取的类的全限定类名，需处理ClassNotFoundException异常try &#123; Class&lt;Dog&gt; dogClass2 = (Class&lt;Dog&gt;) Class.forName(\"reflect.Dog\");&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 对这三种获取Class对象的方式的理解：每个对象的对象头里存了该对象所在类的Class对象的引用（这块知识点在JVM中有详细介绍），所以从原理上看，可以直接根据对象获取Class对象，如方法1，实际上getClass()是Object类的方法,所以自然所有对象都会有这个方法了。 获得Class对象之后有什么用？当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取该类中的构造方法、成员变量、方法等信息，类的这一个个组成部分会被映射成一个个对象,比如说利用反射获得类的构造器对象，然后就可以利用这个类的构造器对象构造一个这个类的实例，总的来说,利用反射能做的事情有： 获取构造方法，用此构造方法创建对象 aClass.getConstructor(); newInstance() 获取成员变量 getFiled(“filedName”) getFileds() getDeclaredFileds() 获取成员方法，并执行此成员方法 getMethod() getDeclaredMethod() invoke() 反射的应用 修改私有成员变量的值 执行私有成员方法 反射妙用：通过反射运行配置文件内容 我利用反射+代理模式写了个demo，用来计算任意类的无参方法的执行时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package reflect;import java.lang.reflect.Method;/** * @Created by hfq on 2020/5/12 * @used to: 用于计算任意类的任意无参方法的执行时间 */public class TimeProxy &#123; String className; String methodName; public TimeProxy()&#123; &#125; public TimeProxy(String className, String methodName) &#123; this.className = className; this.methodName = methodName; &#125; public Long exeucte() throws Exception &#123; Class&lt;?&gt; aClass = Class.forName(className); Long start = System.currentTimeMillis(); Method method = aClass.getDeclaredMethod(methodName,null); method.setAccessible(true); method.invoke(aClass.newInstance(),null); return System.currentTimeMillis()-start; &#125; public static void main(String[] args) throws Exception &#123; TimeProxy timeProxy = new TimeProxy(\"reflect.Person\",\"eat\"); System.out.println(\"人吃饭，吃了:\"+timeProxy.exeucte()+\" ms\"); TimeProxy timeProxy2 = new TimeProxy(\"reflect.Brid\",\"fly\"); System.out.println(\"鸟飞行，飞了:\"+timeProxy2.exeucte()+\" ms\");// 测试系统Math类的random()方法，报java.lang.IllegalAccessException// TimeProxy println = new TimeProxy(\"java.lang.Math\", \"random\"); // System.out.println(\"Math执行random方法，执行了\"+println.exeucte()+\" ms\"); &#125;&#125;class Person&#123; private void eat() throws InterruptedException &#123; Thread.sleep(1000); //人吃饭三秒 &#125;&#125;class Brid&#123; private void fly() throws InterruptedException &#123; Thread.sleep(3000); //鸟飞翔三秒 &#125;&#125;/*打印结果如下：人吃饭，吃了:1001 ms鸟飞行，飞了:3001 msProcess finished with exit code 0*/ 更多内容我就不在此展开了，参考如下文章，案例比较全面： 原文链接：https://blog.csdn.net/sinat_38259539/article/details/71799078","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://hfq123.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"java并发编程-等待/通知机制","date":"2020-05-09T09:01:04.000Z","path":"2020/05/09/java并发编程-等待-通知机制/","text":"https://www.cnblogs.com/powercto/p/10848825.html#a%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E8%AF%B4wait-%E8%A6%81%E6%94%BE%E5%9C%A8while%E9%87%8C%E9%9D%A2%EF%BC%9F while的作用 标志的作用： 即使唤醒线程先执行了，也正常。","tags":[{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"cxsj项目-服务端主动推送数据到客户端","date":"2020-05-07T05:20:09.000Z","path":"2020/05/07/cxsj项目-服务端主动推送数据到客户端/","text":"需求分析在智慧停车管理平台(WEB端)项目的公告发布模块中，管理员发布公告后，车主用户可以评论公告（这可以作为用户提问的一种途径），为了让管理员及时看到用户对公告的评论，以便及时回复，需增加一个通知提醒功能，就和大多数WEB应用一样，页面顶部有一个通知图标，如果有通知，就高亮显示起到提醒的作用。 目标实现效果当没有任何通知的时候（在我这个案例中，也就是没有用户回复公告的提醒），显示通知图标。 没有通知的时候页面顶部状态栏 当有通知时，高亮显示未读通知的数目，当用户点击页面顶部“通知”按钮的时候，根据时间降序显示出所有通知，并且重点标注出哪些通知是未读的。 image-20200508134511709 实现思路基本思路接下来介绍一下本案例中是怎么实现通知回复功能的。 当用户进行评论公告操作后，先将用户的评论插入到数据库的评论表中，如果插入成功，生成一条对应的通知记录，在数据库设计时，通知表(notification)包含了如下字段： 字段名 作用 id 通知表的主键 notifier 通知发起者id，外键，关联用户表 receiver 通知接收者id，外键，关联用户表 outerId 公告id，外键，关联公告表，表示notifier在编号为outId的公告下回复了receiver gmt_create 通知创建的时间戳，bigint类型 status 通知的阅读状态（对于接收者而言），0标识未读，1标识已读 结合具体场景对数据表各个字段的解读： 用户A成功回复了管理员发布的公告，则生成一条通知记录，其中，notifier字段存用户A的id，recevier字段存管理员的id，outId存被回复的公告的id，gmt_create保存系统当前的时间戳，以记录通知生成的时间，status初始化为0表示通知接收者还未读。 持久化通知记录到数据库之后，我们就可以获得每个用户的未读通知数目和全部历史通知数据： 12345#查询某用户未读通知的数目select count(1) from notification where receiver = 用户ID and status = 0#查询某用户的全部通知select * from notification where receiver = 用户ID 至此就很明朗了：加载WEB页面时，先查询当前用户的未读通知的数目，如果是0，则显示通知图标，如果大于0，则高亮显示未读通知的数目。这个流程可以通过ajax调用后端查询接口实现，代码就不展开了。 现在问题来了，这样做的缺点是什么？ 1、实时性差，每次需要手动刷新当前页面或者点击别的页面，重新加载后，才会获得当前实时的未读通知数目。 2、效率不高，每进入一个新的页面，都会查询当前的未读通知数目，即使距离上一次查询的一段时间内，未读通知数并没有更新，也会查询。 改进思路针对上述这两个问题，有一些改进思路： ”假装实时“的客户端轮询机制首先，为了解决实时性差的问题，我们可以想到：客户端每隔一小段时间，就使用ajax调用查询接口，获取当前用户未读通知的数目，获取结果后局部刷新到顶部栏通知框内。 这样做一定程度上实现了”实时“通知：比如说，每隔2秒，客户端就发起一次查询当前通知未读数的请求，服务器返回结果，如果不考虑网络等因素的延时，网页顶部的通知状态栏中的数字始终是2s内的未读通知数，对于普通WEB应用来说，这样的实时性是可以接受的。 轮询机制的代码实现（每隔2000ms调用一次查询方法并更新）： 123setInterval(function()&#123; 此处写ajax查询的代码&#125;,2000) 接下来，我们来分析一下这种机制的性能： 轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。 这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。 注:此段描述摘自于此博客。 总的来说，轮询机制似乎确实在一定程度上能解决实时性的问题，但是效率很差。 由于轮询有一定的时间差，所以我在标题上说是”假装实时“。 真正实时的WebSocket概念之所以轮询机制的效率低，是因为，客户端无法得知后台数据什么时候发生了更新，所以每次发送请求时只能”抱着试一试“的态度，请求当前后台某个数据的值，以尽可能获取最近一段时间内的该数据的最新值，概括地说，和普通客户端请求一样，轮询机制是由客户端发起请求。而理想的模型是在服务器端数据有了变化后，可以主动推送给客户端,这种”主动型”服务器是解决这类问题的很好的方案。Web Socket就是这样的方案。 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 注:此段描述摘自于菜鸟教程。 简而言之，WebSocket 拓展了客户端获取后台数据的方式，普通情况下，只能由客户端主动拉取(pull)，而用了WebSocket之后，可以通过服务器主动推送（push），客户端被动获取数据。 讲到这里，终于呼应上本文的标题了。 由于我还没系统学过java的网络编程，之前也没接触过WebSocket，于是采用了号称“让websocket更简单”的解决方案——GoEasy API，结果证明，使用起来确实极其简单。 理解GoEasy的工作原理很简单，浏览器订阅channel，服务端后客户端都可以向channel发布消息，消息被发布 到channel后，所有订阅了该channel的客户端都可以获得channel里的消息。 GoEasy的推送机制 图源自GoEasy的工作原理。 使用这里就简单地介绍一下GoEasy的使用过程吧。 1、注册并登录GoEasy账号后，首先注册一个应用，选免费版即可。 2、后端推送数据到channel 首先，在maven项目的pom.xml中添加如下依赖: 12345678910111213141516 &lt;dependencies&gt; ........... &lt;!-- GoEasy的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.goeasy&lt;/groupId&gt; &lt;artifactId&gt;goeasy-sdk&lt;/artifactId&gt; &lt;version&gt;0.3.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这是gson的依赖，一开始没有加，报错ClassNotFound了 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12GoEasy goEasy = new GoEasy( \"这里填写第一步注册应用完成后获取到的Common key\");goEasy.publish(\"my_channel\", String.valueOf(replyNum)); //replyNum是我项目中生成新通知后，更新后的\"通知未读数目\" 3、前端从channel中获得消息 首先，下载js文件，引入到thymeleaf的html模板中。 编写获取channel中数据的前端代码： 1234567891011121314151617/** * 订阅channel，获取最新的未读通知数目 */function subscribleReplyNum() &#123; var goEasy = new GoEasy(&#123; host:'hangzhou.goeasy.io', //应用所在的区域地址: 【hangzhou.goeasy.io |singapore.goeasy.io】 appkey: 这里依旧填写第一步注册应用完成后获取到的Common key &#125;); goEasy.subscribe(&#123; channel: \"my_channel\", //“my_channel”对应于发布时的channel名 onMessage: function (message) &#123; console.log(\"Channel:\" + message.channel + \" content:\" + message.content); $(\"#not_read_count\").text(message.content); //更新“通知状态栏”的未读通知数目的span的值 &#125; &#125;);&#125; 至此，就可以正常使用了，完成如下效果： image-20200508174335930","tags":[{"name":"项目","slug":"项目","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"再谈单例模式","date":"2020-05-06T15:20:09.000Z","path":"2020/05/06/再谈单例模式/","text":"之前，学设计模式的时候，接触了单例模式的四种实现方法，那个时候还不怎么理解，糊里糊涂地整理了笔记。 现在学了JVM和并发编程后，对单例模式的实现细节有了更好的掌握。借此机会回顾一下DCL(Double Check Lock，即双重检查锁)实现单例和静态内部类实现单例。 DCL单例模式经典懒汉单例模式的实现123456789101112public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public synchronized static Singleton getInstance()&#123; if(instance==null) return new Singleton(); return instance; &#125;&#125; 在此代码，重点关注synchronized关键字，它修饰了获取单例的静态方法。 之所以在这里要用synchronized，是因为防止多线程情况下，如果多个线程同时执行到了if(instance==null)，判断都是true，将会导致在多个不同的线程创建了多个不同实例，违背了单例模式的目标，所以需要使用synchronized保证这块代码的原子性，也就是在一个线程创建实例的时候避免其他线程的干扰。 一步步改进我们知道，synchronized关键字修饰静态方法，就相当于修饰了所在类.Class对象，所以上述代码等价于如下代码: 1234567891011121314public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; synchronized (Singleton.class)&#123; if(instance==null) return new Singleton(); &#125; return instance; &#125;&#125; 这种方法虽然实现了懒惰实例化，需要用到单例时才会创建，而且也保证了线程安全。 但是性能上存在缺陷： 原因是，在此实现中，每次进入getInstance方法获取单例时，都要进入先synchronized修饰的同步代码块。但实际上只有在首次创建单例（第一次调用getInstance方法）的时候，有线程安全的问题，一旦创建了单例后，多个线程获取单例不会有线程安全的问题，而synchronized加锁是有性能开销的，这样做就相当于把一部分不需要加锁的情况，也加了锁。 根据此思路，我们对这段代码改进，就会得到DCL单例模式的初步实现： 12345678910111213141516public final class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; if(instance==null)&#123; //根据分析，只有首次创建（也就是当前instance为空）时，需要进入同步代码块 synchronized (Singleton.class)&#123; if(instance==null) return new Singleton(); &#125; &#125; return instance; &#125;&#125; 在此实现中，先后两次对instance进行是否为空的判断，这也是“double check“这个名字的由来。 细心的读者会看到上文我说，这一种是DCL的”初步实现“，看似完美的实现有什么不足呢？ 这就要从字节码的角度分析了。 指令重排。 先调用构造方法再内存指向，先内存指向再调用构造方法都有可能！！。 其他线程执行第一个检查的时候，判断instance==null的条件不成立，直接返回了instance对象，而对比经典的单例模式实现中，synchronized关键字修饰了，只有获得了对象监视器的线程可以访问instance 。 不会影响本线程，但是可能影响其他线程 说了这么多，如何解决呢？ ​ private static volatile Singleton instance; 饿汉：类加载时就会创建单例对象。（静态成员变量会初始化阶段赋值） 懒汉：类加载时不会导致单例对象被创建，而是首次使用该对象才会创建。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"推荐阅读","slug":"推荐阅读","permalink":"http://hfq123.github.io/tags/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/"}]},{"title":"JVM-虚拟机性能监控与故障处理实战","date":"2020-05-04T09:53:58.000Z","path":"2020/05/04/JVM-虚拟机性能监控与故障处理实战/","text":"本文主要介绍如何应用一些虚拟机的性能监控和分析的命令。 jdk命令行工具jps image-20200504175625119 jps可以查看当前jvm运行的进程名和它们对应的虚拟机进程号。查到进程号后方便结合后续的很多其他命令。 jstatjstat用于监视虚拟机各种运行状态信息，显示类装载、内存、垃圾收集、JIT编译等运行数据。 image-20200504175926715 表示分析进程 id 为 8608 的 gc 情况，每隔 1000ms 打印一次记录，不停止。 jinfojinfo用于实时查看和调整虚拟机各项参数。 image-20200504180217340 带参数的jinfo image-20200504180250530 jmap用于生成堆转储快照。 image-20200504180359885 jhat用于分析堆转储快照。使用jhat，用户可以在浏览器上查看分析结果。 image-20200504180455772 进入localhost:7070: image-20200504180509345 jstack用于生成虚拟机当前时刻的线程快照。 主要目的是定位线程出现长时间停顿的原因， 如死锁、死循环、请求外部资源长时间等待….. 持续等待用户输入造成停顿时间过长 jstack定位死锁 可视化工具jconsole可以在cmd窗口打开jconsole图形化工具，然后连接到本地进程或远程进程。 image-20200504181849691 VisualVM强大的运行监视和故障处理程序，可以在cmd窗口输入jvisualvm打开此图形化工具。 image-20200504183707463 转储后分析内存","tags":[{"name":"JVM","slug":"JVM","permalink":"http://hfq123.github.io/tags/JVM/"}]},{"title":"JVM学习笔记-垃圾回收","date":"2020-05-04T08:03:13.000Z","path":"2020/05/04/JVM学习笔记-垃圾回收/","text":"主要参考材料是《深入理解Java虚拟机》第二版。 根据学习内容，制作了思维导图。 image-20200504160356910","tags":[{"name":"JVM,笔记","slug":"JVM-笔记","permalink":"http://hfq123.github.io/tags/JVM-%E7%AC%94%E8%AE%B0/"}]},{"title":"Java并发编程笔记1-基本概念","date":"2020-04-30T16:51:39.000Z","path":"2020/05/01/Java并发编程笔记1-基本概念/","text":"JVM已经学的差不多了，今天开始学习Java并发编程，记录学习笔记。 多线程的基本概念首先还是从基本概念讲起。 进程VS线程进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载到CPU，把数据加载至内存。在指令运行过程中还需要用到用到磁盘、网络等设备，进程就是用来加载指令、管理内存、管理IO的。 当一个程序运行，从磁盘加载这个程序的代码到内存，这时就开启了一个进程。 进程可以视作程序的一个运行实例，大部分程序可以同时运行多个实例进程，有些只能启动一个实例进程。 程序是静态的，而进程是动态的。 线程 一个线程就是一个指令流，将指令流中的一条条指令以一定顺序交给CPU执行。 线程是最小的CPU调度单位。进程作为资源分配的最小单位，在windows中是不活动的，只是作为线程的容器。 对比 独立性：进程之间基本上是互相独立的，而同一个进程内可能有多个线程，它们之间相互协作完成进程。 资源角度：进程拥有线程的共享资源，如内存空间，供其内部的线程共享。 通信方式： 进程通信：同一计算机的进程之前通信称为IPC(Inter-process communication)，不同计算机之间的进程通信，需要通过网络，并且遵守共同的协议，如HTTP。 线程通信：线程通信相对简单，因为它们共享进程内的内存。 线程更轻量，线程上下文切换成本一般比进程上下文切换低。 并发VS并行推荐阅读 单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，一般会将这种 线程轮流使用 CPU 的做法称为并发（concurrent）。多核 cpu下，每个核(core) 都可以调度运行线程，这时候线程可以是并行(parallel)的。 关于并发和并行的概念辨析，这里引用Go语言创始人Rob pike的描述： &lt;%blockqoute%&gt; “Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once” &lt;%endblockqoute%&gt; 并发是一段时间内应对多个任务的能力(某个时间片内执行一个任务的一部分，下一个时间片可能执行其它任务的一部分，多个任务轮流时间片，通过不同任务之间切换，切换后的任务从上次停止的地方继续)，而并行是一个时间点上同时处理多个任务的能力。 并发是一段时间内某个系统或单元的各个组成部分通过相互配合来处理大量的任务，强调结构和调度，并行是某一时刻多个单元同时在做各自的任务， 强调执行。 多线程的应用 异步调用。 无需等待方法调用。 利用CPU多核优势并行 Java线程创建并启动线程创建线程的3种方式。 在Java中，创建线程主要是用到Thread类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @Created by hfq on 2020/5/1 * @used to: 创建线程的3种方式 */@Slf4j(topic = \"c.Test1\")public class Test1 &#123; /** * 创建线程方式1 */ public static void test1()&#123; Thread t1 = new Thread(\"myThread1\")&#123; @Override public void run()&#123; log.debug(\"thread 1 start........\"); &#125; &#125;; t1.start(); &#125; /** * 创建线程方式2 */ public static void test2()&#123; Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; log.debug(\"thread 2 start........\"); &#125; &#125;,\"myThread2\"); //Thread t2 = new Thread(() -&gt; log.debug(\"thread 2 start........\"),\"myThread2\"); t2.start(); &#125; /** * 创建线程方式3 */ public static void test3()&#123; FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; log.debug(\"thread 3 start........\"); return null; &#125; &#125;); Thread t3 = new Thread(integerFutureTask, \"myThread3\"); t3.start(); &#125; public static void main(String[] args) &#123; test1(); test2(); test3(); log.debug(\"main thread start........\"); &#125;&#125; ！！！ 【拓展阅读—Java创建涉及的设计模式】 Thread类涉及到的两种设计模式 线程类的模板方法设计模式 多线程策略模式 查看进程和线程的方法windows：tasklist、taskkill linux: ps、top、kill java: jps、jstack、jconsole Java操作线程的常见方法start&amp;run如果在主函数中直接调用线程的 run方法 是在主线程中执行了 run，没有启动新的线程使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码 sleep 与 yield调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 调节线程优先级setPriority()。Thread.MIN_PRIORITY ：1，Thread.MAX_PRIORITY：10 join方法Thread中，join()方法的作用是调用线程等待该线程完成后，才能继续往下运行。 join()方法还有一个重载方法join(long n) ，等待线程运行结束,最多等待 n毫秒。 interrupt方法打断 sleep，wait，join 的线程 给受阻塞的线程发出一个中断信号，这样受阻线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。 待理解 两阶段终止模式 守护线程默认新创建的线程是非守护线程，java进程中主线程和所有非守护线程都结束了才会结束。 设置为守护线程：setDaemon(true)。 垃圾回收器：守护线程 线程状态在操作系统课本上，我们学的是进程有五种状态：新建、就绪、运行、阻塞、终止。 而在Java语言中，一个线程的状态有六种。从jdk Thread类的源码中就可以看到，定义在名称为State枚举中： image-20200516184955190 线程安全问题多线程对静态变量进行相同次数的自增自减。 thread1 thread2 a++; a–; a++:取a，计算a+1，写回内存 a–:取a，计算a-1，写回内存","tags":[{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"并发","slug":"并发","permalink":"http://hfq123.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"JVM学习笔记-JVM内存区域","date":"2020-04-29T16:38:18.000Z","path":"2020/04/30/JVM学习笔记-JVM内存区域/","text":"学习JVM有一段时间了，消化后整理了此笔记便于自己复习，此系列定位为“笔记”，一些地方就写得比较精简了，适合已经系统学习过JVM的读者翻阅。 主要参考材料是《深入理解Java虚拟机》第二版。 JVM内存区域运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，每个区域有各自的用途。 根据该区域是否是线程私有，可以分为线程私有的区域和线程共享的区域。 线程私有的内存区域程序计数器它的作用是指示当前线程要执行的字节码的行号（字节码指令的地址）。 java多线程是通过线程轮流切换实现的，线程被挂起后下次需要恢复到正确的执行位置，所以每个线程都需要一个独立的程序计数器。 除了线程私有，程序计数器区域的另一个特点是占用内存空间很小，唯一的一个不会OOM的区域。 Java虚拟机栈既然它是栈，那么栈元素是什么呢？答案是栈帧。栈帧用于存放局部变量表、操作数栈 、动态链接、方法出口等信息。每调用一个Java方法，与之对应的一个栈帧入栈，执行完成，出栈。 此区域有两种内存溢出的情形： StackoverflowError 栈中加入的元素（栈帧）过多造成栈溢出，也就是调用的方法过多，一直没有返回），比如说持续递归会造成这种情况 。 OutOfMemoryError 如果虚拟机栈支持动态扩展，扩展时无法申请足够的内存，就会出现此情况OOM。 本地方法栈这一内存区域与 Java虚拟机栈类似，不过其服务的对象是本地方法（一般是由C/C++实现的）而非Java方法。 线程共享的内存区域堆此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也就变得不那么绝对了。 如果从垃圾回收的角度考虑，由于大部分JVM实现都采用了分代收集的回收算法，把堆空间进一步划分成新生代和老年代,其中新生代包括了Eden空间，From Survivor空间，To Survivor空间。 方法区方法区存放已被虚拟机加载的类的元数据（类信息、常量、静态变量、编译后的代码等等）。 永久代、元空间、方法区 三者关系 方法区是内存区域的一种规范，永久代和元空间都是方法区的一种实现。JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 运行时常量池是方法区的一部分 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用），类加载后Class文件中的常量池信息就进入了方法区的运行时常量池。 HotSpot虚拟机对象探秘《深入理解Java虚拟机》书中详细地介绍在HotSpot虚拟机在堆中对象分配、布局和访问的全过程。 对象的创建对象的创建总体上有这几个步骤： 类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 为新生对象分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 初始化为零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 对象头的设置 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行init方法 把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。 Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志等等,被官方称作Mark Word，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 对象的大小必须是 8 字节的整数倍。 对象的访问建立对象就是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种。 这两种对象访问方式各有优势，使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 。。。此处待上图。。。 实战:OutOfMemoryError异常上面讲的都是理论，在实战中，可能会遇到OOM的问题，我们开发人员要做的就是快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常该如何处理。 内存溢出区域 报错信息 可能的原因 解决方法 堆 OOM java heap space 调节堆大小(-Xms,-Xmx)检查代码对象的生命周期是否合理 栈 StackoverflowError OutOfMemoryError 方法区","tags":[{"name":"JVM","slug":"JVM","permalink":"http://hfq123.github.io/tags/JVM/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter9","date":"2020-04-26T02:22:51.000Z","path":"2020/04/26/《Head-First-设计模式》读书笔记charpter9/","text":"本篇博客是《Head First 设计模式》第九章的读书笔记。 分享主题是设计模式中的 「迭代器模式(Iterator Pattern)」以及 「组合模式(Composite Pattern)」。 迭代器模式场景:菜单合并有一家早餐馆和一家饭馆合并了，我们需要合并2张菜单，由于以前它们底层实现的数据结构不同，早餐菜单是由AarryList实现的，而正餐菜单是由数组实现的，现在要打印合并后的菜单。注意：这里说的“合并”不要求底层实现的数据结构的统一，产生一个新的菜单，而只需要打印格式统一就行了，供服务员类菜单统一打印菜单。 思路1：依次打印两张菜单实现P.S.为了便于阅读，本文只给出了部分核心代码，完整代码见GitHub。 pancakeHouseMenu类和DinerMenu类分别是早餐菜单和正餐菜单，代码略。 服务员类代码： 123456789101112131415161718192021public class Waitress&#123; //服务员类，主要工作:打印菜单(包含早餐菜单和正餐菜单) PancakeHouseMenu pancakeHouseMenu; //早餐菜单对象，ArrayList实现 DinerMenu dinerMenu; //正餐菜单对象，数组实现 ..... public void printMenu()&#123; //思路1 System.out.println(\"早餐--烙饼专场:\"); ArrayList&lt;MenuItem&gt; arrayList = pancakeHouseMenu.getArrayList(); for(MenuItem item : arrayList)&#123; System.out.println(item.toString()); &#125; System.out.println(\"正餐--套餐饭专场：\"); MenuItem[] menuItems = dinerMenu.getMenuItems(); for(int i = 0; i&lt;menuItems.length; i++)&#123; if(menuItems[i] == null) return; System.out.println(menuItems[i].toString()); &#125; &#125; .....&#125; 如上代码，这种思路是依次打印早餐菜单和正餐菜单： 用一个ArrayList对象接收早餐菜单，遍历这个ArrayList对象，打印每个早餐菜单项。 用一个数组对象接收正餐菜单，遍历这个数组对象，打印每个正餐菜单项。 分析 这种方法需要服务员类清楚地知道各个菜单的内部实现是怎么样的，这样才能分别使用正确的数据类型接收各菜单。 如果有新的菜单需要合并（比如这家餐厅又并入了一个咖啡馆），毫无疑问，我们要修改服务员类的printMenu()方法：根据新的菜单的数据结构接收菜单，再遍历这个集合。 总结前面两点，也就是说，如果有第三张菜单的出现，那么就会需要三个循环，服务员类需要清楚地知道这三张菜单各自的底层数据结构，数组？ArrayList ？HashTable？…… 思路2：使用迭代器模式经过对思路1的分析，我们发现，对于服务员类来说，其实没有必要关注菜单实现的细节：不需要知道每张菜单的各个菜单项是存放在什么类型的集合中的，它只需要关注如何依次获得每个菜单项对象。为此，改进思路是设计原则中的封装变化的部分：在这里，需要封装由不同集合类型所造成的遍历。 使用迭代器之后以正餐菜单为例，设计迭代器： 123456789101112131415161718192021222324252627282930313233public class DinerMenu implements IMenu &#123; //正餐菜单 static int MAX_ITEMS = 10 ; int numberOfItems = 0 ; MenuItem [] menuItems; ..........................//省略了初始化代码 @Override public Iterator createIterator() &#123; return new DinerMenuIterator(this.getMenuItems()); //获得迭代器 &#125;&#125;public class DinerMenuIterator implements Iterator &#123; //正餐菜单的迭代器 MenuItem [] items; //正餐菜单的数据结构是数组 int postion = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; @Override public boolean hasNext() &#123; if(postion&gt;=items.length || items[postion]==null) return false; return true; &#125; @Override public MenuItem next() &#123; return items[postion++]; &#125;&#125; 服务员类中打印整张菜单的方法： 123456789101112131415public void printMenuWithIterator()&#123; //使用迭代器后，打印整张合并后的菜单 System.out.println(\"早餐--烙饼专场:\"); // printMenu(pancakeHouseMenu.createIterator()); printMenu(pancakeHouseMenu.getArrayList().iterator()); //pancakeHouseMenu的菜单项组织的数据结构是ArrayList，所以可以直接获得ArrayList内置的迭代器 System.out.println(); System.out.println(\"正餐--套餐饭专场：\"); printMenu(dinerMenu.createIterator());&#125;public void printMenu(Iterator iterator)&#123; //遍历某个菜单迭代器可访问的全部菜单项 while (iterator.hasNext())&#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.toString()); &#125;&#125; 可以看到，服务员类中，只需要调用各个菜单迭代器的hasNext()和next()来获得每个菜单项，无需关注其数据结构，只有在迭代器内部才需要关注具体的数据结构。 进一步改进：如上服务员类的代码，服务员类中分别组合了早餐菜单和午餐菜单两个对象，为了提高可拓展性，可以用一个ArrayList保存所有菜单，便于今后加入新的菜单或者删除现有菜单。 改进后更加优雅的服务员类代码: 12345678910111213141516171819202122232425262728/** * @Created by hfq on 2020/4/26 * @used to: 更加优雅的服务员 */public class WaitressImproved &#123; ArrayList menuList; //保存各个菜单 public WaitressImproved(ArrayList menuList) &#123; this.menuList = menuList; &#125; public void printMenu()&#123; Iterator menuIterator = menuList.iterator(); while (menuIterator.hasNext())&#123; IMenu menu = (IMenu) menuIterator.next(); //遍历各个菜单 printMenu(menu.createIterator()); //调用printMenu方法依次遍历并打印该菜单的每个菜单项 System.out.println(); &#125; &#125; public void printMenu(Iterator iterator)&#123; //遍历某个菜单迭代器可访问的全部菜单项 while (iterator.hasNext())&#123; MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.toString()); &#125; &#125;&#125; 可以看到，这样做的好处在于，如果有新的菜单（需要实现createIterator()方法，获得这个菜单的迭代器）加入，不需要修改服务员类的代码，就能直接调用打印整个菜单的功能。 定义接下来我们来看看迭代器模式的定义： 迭代器模式提供一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 结合上例解读迭代器模式：服务员类不需要知道各个菜单内部究竟是用数组表示的还是ArrayList表示的，它只需要获得菜单的迭代器，由迭代器告诉服务员类还有没有没有遍历到的对象( hasNext() )、下一个遍历的对象是谁)( next() )，来遍历其中的每个对象。 设计原则 一个类应该只有一个引起变化的原因 java的Iterator接口迭代器模式在平时开发中经常用到。 hasNext() next() 组合模式场景引入组合模式的场景仍然是上例中菜单的例子，现在餐厅菜单引入了新的需求：上例的正餐菜单里需要嵌套一个甜品菜单，支持嵌套菜单后，整张菜单应该长这样： 支持嵌套子菜单的菜单结构 重点关注上图的“正餐菜单”，在这个菜单集合中，其集合项既可以是它的子菜单（图上的甜品菜单），又可以是普通菜品。 在代码中，我们也需要某种树形结构，可以在一个菜单下同时容纳子菜单和菜品。 引入组合模式没错，我们要引入组合模式来解决这个问题，先来看看组合模式是什么吧： &lt;%blockquote%&gt;组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象以及对象组合。&lt;%endblockquote%&gt; 有了场景的铺垫，很容易配合其定义解读，解读之前，再来规定一下案例中涉及到的几个业务概念，避免混淆。 菜单：作为一个整体菜单独立存在，比如上图的正餐菜单，在代码中独立以一个集合的形式存在。 菜品：菜单下具体的一道菜，比如，上图鸡腿饭是正餐菜单的一道菜品，是形成树形结构的“叶子节点”。 子菜单：某张菜单下嵌套的下级菜单，比如，上图甜品菜单是正餐菜单的一个子菜单，是形成树形结构的“子树”。 菜单项：在菜单概念中，提到了菜单是以一个集合的形式独立存在的，菜单项则就是菜单集合的集合项了，本案例中，菜品和子菜单都可以作为菜单项。 绕了这么多，让我们结合组合模式的定义分析：在本例中，“整体”对应菜单，“部分”对应菜单项，“个别对象”对应菜品，“对象组合”对应子菜单。因为菜单项既可以是菜品，也可以是子菜单，就构成了有层级关系的树形结构，而我们引入组合模式的目标就是希望能够以统一的方式地处理菜单下级的菜品和子菜单这两种不同结构，而不用关注它到底有没有、有几个子菜单，甚至在子菜单中也能再嵌套子菜单。写出简单的代码，就能够对整个菜单结构应用相同的操作，可以忽略对象组合（子菜单）和个别对象（菜品）的差别。 组合模式的UML图如下，接下来我们就要根据这个类图来编写本案例引入组合模式的代码，我已在图上红字标出本例中涉及到的类分别对应的组合模式角色。 组合模式的UML图 代码第一步，编写菜单项这一抽象父类代码再次强调，菜品可以作为菜单项，子菜单也可以作为菜单项，所以作为菜品和子菜单的共同接口，菜单项既要规定菜品有的方法，也要规定子菜单有的方法。 对于子菜单，它需要的方法有：添加菜单项、删除菜单项等。 对于菜品，它需要的方法有：获取菜品名、获取价格等。 子菜单需要的全体方法+菜品需要的全体方法就构成了菜单项抽象类的方法了。 123456789101112131415161718192021222324252627282930313233343536package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/26 * @used to: 菜单项（子菜单+菜品）的共同接口，抽象类实现 * 其中，有部分方法只针对子菜单有意义，有部分方法只针对菜品有意义，有部分方法对于它们都有意义，提供统一操作 */public abstract class MenuComponent &#123; public void add(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; public void remove(MenuComponent menuComponent)&#123; throw new UnsupportedOperationException(); &#125; public MenuComponent getChild(int i)&#123; throw new UnsupportedOperationException(); &#125; public String getName()&#123; throw new UnsupportedOperationException(); &#125; public String getDescription()&#123; throw new UnsupportedOperationException(); &#125; public double getPrice()&#123; throw new UnsupportedOperationException(); &#125; public boolean isVergetarian()&#123; //是否是蔬菜 throw new UnsupportedOperationException(); &#125; public void print()&#123; throw new UnsupportedOperationException(); &#125;&#125; 在这个抽象类接口中，我们要注意，有些方法，比如说add()、remove()，只针对子菜单这一菜单项有意义而菜品这一菜单项不需要，而有些方法，比如说getPrice()，只针对菜品这一菜单项有意义而子菜单这一菜单项不需要， 正是因为子类菜品不需要其中的某些方法，而子菜单不需要另外一些方法，所以在抽象类的默认实现中，都抛出了异常。 而print()方法是一个”操作方法“，则可看作菜品和菜单项两者共同的操作。 至此，就完成了就是菜单项父类代码的编写（对应上面UML建模图中的Component角色），接下来就来完成其子类的代码，其子类包括菜品（对应Leaf角色）和子菜单（对应Composite角色）。 第二步，编写菜单项的两个子类代码菜品类和子菜单类只要挑选抽象父类中自己感兴趣的、有意义的方法实现即可。 菜品类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/30 * @used to: 菜单项的子类之一--菜品类 */public class MenuItem extends MenuComponent &#123; String name; //名称 String desc; //描述 boolean vegetarian; //是否为蔬菜 double price; //价格 public MenuItem(String name, String desc, boolean vegetarian, double price) &#123; this.name = name; this.desc = desc; this.vegetarian = vegetarian; this.price = price; &#125; public String getName()&#123; return name; &#125; public String getDescription() &#123; return desc; &#125; public double getPrice() &#123; return price; &#125; public boolean isVergetarian() &#123; return vegetarian; &#125; public void print() &#123; String item = \"MenuItem&#123;\" + \"name='\" + name + '\\'' + \", desc='\" + desc + '\\'' + \", vegetarian=\" + vegetarian + \", price=\" + price + '&#125;'; System.out.println(item); &#125;&#125; 子菜单类： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hfq.headfirstjava.charpter9.composite;import java.util.ArrayList;/** * @Created by hfq on 2020/4/30 * @used to: 子菜单类 */public class Menu extends MenuComponent&#123; ArrayList menuComponents = new ArrayList(); //组合了一个ArrayList对象来保存子菜单的所有菜单项 String name; String description; public Menu(String name, String description) &#123; this.name = name; this.description = description; &#125; public void add(MenuComponent menuComponent)&#123; menuComponents.add(menuComponent); &#125; public void remove(MenuComponent menuComponent)&#123; menuComponent.remove(menuComponent); &#125; public MenuComponent getChild(int i)&#123; return (MenuComponent) menuComponents.get(i); &#125; public String getName()&#123; return name; &#125; public String getDescription()&#123; return description; &#125; public void print()&#123; //难点 System.out.println(name+\"(\"+description+\")\"); System.out.println(\"--------------------------------\"); Iterator iterator = menuComponents.iterator(); while (iterator.hasNext())&#123; MenuComponent menuComponent = (MenuComponent) iterator.next(); menuComponent.print(); //递归调用子菜单的所有菜单项print方法 &#125; &#125;&#125; 第三步，编写服务员类的代码服务员类对应上面UML建模图中的Client客户角色。 12345678910111213141516171819202122232425262728293031323334353637package com.hfq.headfirstjava.charpter9.composite;/** * @Created by hfq on 2020/4/30 * @used to: 引入组合模式后的服务员类，是菜单的客户(UML类图中的Client) */public class Waitress &#123; MenuComponent allMenus; public Waitress(MenuComponent allMenus) &#123; this.allMenus = allMenus; &#125; public void printMenu()&#123; allMenus.print(); &#125; //测试代码 public static void main(String[] args) &#123; MenuComponent totalMenu = new Menu(\"总菜单\",\"存放所有分菜单\"); MenuComponent breakfastMenu = new Menu(\"早餐菜单\",\"含有各种早餐\"); breakfastMenu.add(new MenuItem(\"肉包子\",\"有猪肉的包子\",false,2.0)); breakfastMenu.add(new MenuItem(\"菜包子\",\"有香菇的包子\",true,1.0)); breakfastMenu.add(new MenuItem(\"烙饼\",\"荤素搭配的烙饼\",false,3.0)); MenuComponent dinnerMenu = new Menu(\"正餐菜单\",\"含有各种饭,还包含了一个甜品菜单\"); dinnerMenu.add(new MenuItem(\"鸡腿饭\",\"有红烧鸡腿\",false,10.0)); dinnerMenu.add(new MenuItem(\"牛肉饭\",\"有香辣牛肉\",false,15.0)); MenuComponent dessertMenu = new Menu(\"甜品菜单\",\"包含多种甜品\"); dessertMenu.add(new MenuItem(\"烧仙草\",\"美味的烧仙草\",false,3.0)); dessertMenu.add(new MenuItem(\"绿豆汤\",\"清爽的绿豆汤\",true,1.0)); dinnerMenu.add(dessertMenu); totalMenu.add(breakfastMenu); totalMenu.add(dinnerMenu); Waitress waitress = new Waitress(totalMenu); waitress.printMenu(); &#125;&#125; 上述测试代码打印菜单的结果如下所示，成功达到我们的目标： 测试打印整张菜单的结果 为了让显示效果好一点，看得出菜单嵌套的层级效果，我又对上面的代码做了略微的改动，print()方法加了一个String类型的前缀，具体实现请移步Github。如下图，改动后，能在打印结果看出来甜品菜单是正餐菜单的子菜单。 改动后的显示效果具有层次 总结组合模式中让组件接口（对应于本例中的菜单项的抽象类）同时包含一些管理子节点（子菜单）和叶子节点（菜单项）的操作，客户(Client)就可以将组合和叶节点一视同仁，也就是说，一个元素究竟是组合还是叶节点，对用户是透明的，在案例中，即使是用户不知道一个菜单项究竟是子菜单还是普通菜品的情况下，也能调用统一的print方法打印。 然而，组合模式这种做法失去了一些“安全性”，这是因为客户有机会对一个元素做不恰当或者是没有意义的操作(列入本例中试图调用一个菜品对象的add方法，菜品类继承了菜单项抽象类，所以它有add方法，但是这个add方法实际上是为子菜单类服务的，而对菜品类无意义)。假如我们将菜品和子菜单各自需要的方法区分开来放到不同的接口里，客户代码就必须用条件语句和instanceof操作符来区别对待不同类型的节点(菜品和子菜单)。 所以说，使用组合模式是便利性和违背涉及原则折衷的一个选择。 组合迭代器分别学完了迭代器模式和组合模式之后，来看看它们共同作用会什么样的火花吧，亲密无间的配合也是它们放在同一个章节的原因。 我们可以这样理解，在上文介绍迭代器模式时的场景中，菜单集合是一维的，因为其集合元素都是菜品，而组合模式中的案例场景中，菜单结构是有嵌套层次的。针对一个元素全都是菜品对象的普通的菜单集合，构建它的迭代器很简单，而对于构建像这一树形层次结构的集合的迭代器又该如何做呢？","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"密码测试文章","date":"2020-04-25T16:52:33.000Z","path":"2020/04/26/密码测试文章/","text":"我的名字（全小写）？26370213ec222ab70d5b0a28fe3afc58ad364a9a8e644a0f27472f05678679b7b447aa193cd5f8e634c1f8a6c2f3768287d7d05195b8437b8f646f274a57e68d8ef79fdcd15cfb3b7b027b1c73e04d51","tags":[{"name":"日常","slug":"日常","permalink":"http://hfq123.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"《Head-First-设计模式》读书笔记charpter8","date":"2020-04-21T06:52:00.000Z","path":"2020/04/21/《Head-First-设计模式》读书笔记charpter8/","text":"本篇博客是《Head First 设计模式》第八章的读书笔记。 分享主题是设计模式中的 「模板方法模式(Template Method Pattern)」。 定义模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 具体应用场景从饮品店制作咖啡和茶的制作方法讲起，咖啡和茶的制作流程如下图所示。 咖啡和茶的制作流程 接下来用代码表示咖啡的制作过程： 12345678910111213141516171819202122232425/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的制作流程 */public class Coffee &#123; public void prepareRecipe()&#123; //冲泡咖啡 boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void brewCoffeeGrinds()&#123; System.out.println(\"Dripping Coffee through filter\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addSugarAndMilk()&#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125; 同样的，茶的制作过程代码如下： 123456789101112131415161718192021222324/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea &#123; public void prepareRecipe()&#123; //冲泡茶 boilWater(); steepTeaBag(); pourInCup(); addLemon(); &#125; public void boilWater()&#123; System.out.println(\"Bolling water\"); &#125; public void steepTeaBag()&#123; System.out.println(\"Steeping the tea\"); &#125; public void pourInCup()&#123; System.out.println(\"Pouring into cup\"); &#125; public void addLemon()&#123; System.out.println(\"Adding lemon\"); &#125;&#125; 可以发现，boilWater()和pourInCup()方法的代码重复了。究其原因，这是因为咖啡和茶的制作流程大致上一样，它们的制作过程都可以用下图的算法表示，1、3步骤是一样的，2、4步骤有差异，所以我们想到用继承的方法重用1、3步骤的代码，将实现1、3步骤的方法抽取到一个父类中，而2、4步骤这两个有差异的步骤在咖啡子类和茶子类中实现。 制作咖啡和制作茶的相同和不同的步骤 基于此想法，我们设置一个咖啡因饮料的父类： 1234567891011121314151617181920212223/** * @Created by hfq on 2020/4/21 * @used to: 咖啡因饮料的父类，是一个抽象类 */abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); addCondiments(); &#125; void boilWater()&#123; //步骤1，共同的操作，由父类实现 System.out.println(\"Bolling water\"); &#125; abstract void brew(); //步骤2，冲泡，由于不同饮料实现有差异，由子类实现 void pourInCup()&#123; //步骤3，共同的操作，由父类实现 System.out.println(\"Pouring into cup\"); &#125; abstract void addCondiments(); //步骤4，添加调料，由于不同饮料实现有差异，由子类实现&#125; 现在咖啡子类和茶子类的代码就变成了： 12345678910111213141516171819202122232425262728293031/** * @Created by hfq on 2020/4/21 * @used to: 咖啡的冲泡流程 */public class Coffee extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Dripping Coffee through filter\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding sugar and milk\"); &#125;&#125;/** * @Created by hfq on 2020/4/21 * @used to: 茶的制作过程 */public class Tea extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Steeping the tea\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Adding Lemon\"); &#125;&#125; 这样，我们就完成了共同代码（prepareRecipe()、boilWater()、pourInCup()三个方法）的重用。其中，prepareRecipe()方法就叫做模板方法。它作为制作咖啡因饮料算法的模板，在这个模板中，每个步骤都被一个方法代表了，其中，制作不同的咖啡因饮料有共同的步骤：就是上文说的步骤1和步骤3，它们可以直接在父类中实现(分别对应于boilWater()和pourInCup()方法)。制作不同的咖啡因饮料也有不同的步骤：步骤2和步骤4，由于子类有不同的实现，所以父类中不实现，设置为抽象方法，由子类实现，这就是模板方法模式中说的“将一些步骤延迟到子类中”。 如果有新的制作流程一致的咖啡因饮料加入，只需要继承父类，并负责实现父类的抽象方法（表示制作步骤中不同的部分）。 UML图模板方法模式的UML建模图如下： 模板方法模式的UML建模图 使用钩子(Hook)在上例中引入一个新的需求：客户可以自行选择是否需要在饮料中加入调料（也就是选择是否执行制作饮料中的步骤4），这时模板方法的钩子就起作用了。 做法很简单：在模板方法中，加入判断，如果判断为真，则执行步骤4，修改后的模板方法类代码如下： 1234567891011121314abstract class CaffeineBeverage&#123; final void prepareRecipe()&#123; //为了防止子类修改制作流程，使用final关键字修饰 boilWater(); brew(); pourInCup(); if(customerWantsCondimentsHook())&#123; addCondiments(); &#125; &#125; ...省略了相同的代码.... boolean customerWantsCondimentsHook()&#123; //这是一个钩子，子类可以选择是否覆盖 return true; &#125;&#125; 这样一来，在子类中可以覆盖customerWantsCondimentsHook()方法来自行选择是否需要执行步骤4，它还可以更灵活地实现钩子：比如接受用户的输入，据此判断是否需要执行该步骤。 在这里，钩子作为条件控制，影响了抽象类的算法流程。 好莱坞原则书中本章引入了一个新的设计原则，称为好莱坞原则： 好莱坞原则（Hollywood Principle）：别打电话给我们，有事我会打电话给你。 好莱坞原则和模板方法之间的连接比较明显，当我们设计模板方法模式时，我们告诉子类，不要调用我们，我们会调用你。让我们再看一下的咖啡因饮料的设计类图： 好莱坞原则和模板方法 Java API中的模板方法书中指出，模板方法模式很常见，因为对于创建框架来说，这个模式简直棒极了。由框架控制如何做事情，而由使用框架的人指定框架算法中的每个步骤的细节。另外，模板方法有多种实现，不一定看起来和上例讲述的设计一致。 书中给出三个java api中的模板方法示例： 类实现comparable接口后可以用Collections.sort Swing Applet 第一个示例归结于模板方法我觉得似乎有些牵强，后两个示例平时开发没使用过，不熟悉。所以讲讲另外一个比较熟悉的示例吧：Servlet类的service()方法就是一个模板方法，定义了算法骨架，doGet()、doPost()方法是这个算法骨架中的具体步骤，子类可以实现自己的doGet()方法和doPost()方法，这样做子类自己的doGet()、doPost()方法就”挂进”了父类service()方法这一模板方法。 与我们上文咖啡因饮料示例不同的是，子类具有不同实现的方法在父类是抽象的，子类必须实现，而Servlet中的doGet()和doPost()有默认实现。 Servlet中的模板方法 Servlet中的模板方法具体实现参考这里。 总结 模板方法模式实际上是封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同实现，从而让固定的流程产生不同的结果。 模板方法封装了有固定结构的算法块，模板类中可以有各个子类具有相同实现的方法，也可以有各个子类具有不同实现的方法，具有相同实现的方法可以直接在父类（模板方法所在的类）中实现，而各个子类具有不同实现的方法由每个子类自行实现，这样做，子类实现的方法就“挂接”进模板方法里。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter7","date":"2020-04-20T14:40:09.000Z","path":"2020/04/20/《Head-First-设计模式》读书笔记charpter7/","text":"本篇博客是《Head First 设计模式》第七章的读书笔记。 分享主题是设计模式中的 「适配器模式(Adapter Pattern)」以及 「外观模式(Facade Pattern)」。 适配器模式由于这两种设计模式都比较好理解，所以先直接从定义讲起。 定义适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 日常生活的类比我们先用日常生活中例子类比来理解适配器模式。如下图，由于接口的差异，美国笔记本电脑插头无法直接插进欧洲插座获电，而使用了中间的接口转换器后，问题就解决了。而值得注意的是，从无法使用到可以使用，我们既没有改变插座，也没有改变插头，唯一的变化就是引入了接口转换器这一适配器。在这里，这个适配器的作用就是将现有的不符合标准的插头接口“转化”成目标接口，这也正是适配器模式做的全部工作。 插头接口转换器的例子 具体应用场景如下图，系统中有两个接口:Duck和Turkey，它们都有fly()方法，这两个接口的差异在于Duck的quack()和Turkey接口的gobble()方法。MallardDuck和WildTurkey分别实现了Duck接口和Turkey接口。 image-20200420231854471 此外，在外部有个testDuck方法，它的参数是一个Duck对象，在方法体内分别调用了这个Duck对象的quack()方法和fly()方法，我们无需关注它的目的是什么，只需要关注要想调用这个方法，需要一个Duck类型的对象作为参数。 1234public static void testDuck(Duck duck)&#123; duck.quack(); duck.fly(); &#125; 接下来看看下面这段代码，testDuck(wildTurkey)这行代码必然会报错，因为wildTurkey 不是 Duck类型的。 123456789public static void main(String[] args) &#123; System.out.println(\"A duck says:\"); Duck mallardDuck =new MallardDuck(); testDuck(mallardDuck); //这行代码可以正常执行 System.out.println(\"A turkey says:\"); Turkey wildTurkey =new WildTurkey(); testDuck(wildTurkey); //这行代码必然会报错，因为wildTurkey 不是 Duck类型的。&#125; 我们用这个例子来类比上文中插头接口转换器的例子，testDuck()这个方法就相当于上例中的插座，它要求一个Duck对象作为参数才可以正常使用（换句话说，它的标准是Duck接口），就相当于欧洲插座要求一个符合欧洲标准的插头才能正常使用，不符合testDuck()标准的wildTurkey对象就相当于上例中的美国插头（类比详见下图）。而如果我们要是想在不改动WildTurkey类代码的基础上，完成testDuck(wildTurkey)这条语句的功能，就要想办法构建一个上例中的适配器。 类比插头接口转换器的例子 构建TurkeyAdapter这个适配器： 123456789101112131415161718192021/** * @Created by hfq on 2020/4/21 * @used to: 为Turkey接口构造适配器，以使得它符合Duck接口这个标准 */public class TurkeyAdapter implements Duck&#123; //适配器要实现目标接口Duck Turkey turkey; //组合了一个Turkey接口的对象 public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; //这里直接调用了turkey的gobble方法，当然，你也可以做点别的 this.turkey.gobble(); &#125; @Override public void fly() &#123; this.turkey.fly(); &#125;&#125; 测试代码： 1234System.out.println(\"A turkey says:\");Turkey wildTurkey =new WildTurkey();TurkeyAdapter wildTurkeyAdapter = new TurkeyAdapter(wildTurkey);testDuck(wildTurkeyAdapter); //完成了接口转化 至此，一个应用适配器模式的demo就写完了。引入了适配器后，在既不修改WildTurkey类代码、又不修改testDuck方法的代码的基础上，我们完成了原本不兼容的工作，看上去就像实现了将一个Turkey接口的对象转化成一个Duck接口的对象。 UML图适配器模式的UML建模图如下，为了便于理解，我结合刚才的例子添加了红字标注出上例中的各个部分分别代表了什么。适配器Adpter实现了目标接口，且其类中组合了一个被适配器Adptee的对象。 p.s 我本篇博客介绍的例子是采用对象组合的方式实现适配器模式，书中还给出了另外一种实现适配器模式的思路——多重继承，简而言之就是Adapter既继承Target，又继承Adaptee，由于java语法不支持多重继承，在此不做过多介绍。 适配器模式的UML图 以上就是适配器模式的全部内容了，是不是很简单！接下来一起来看看更简单的外观模式吧。 外观模式定义外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 具体应用场景书中给出的例子是家庭影院的例子：放映电影需要执行一系列任务，这些任务涉及到了多个对象（以及它们对应的多个方法），这导致了每次需要放映电影都要写上一长串代码。 image-20200421005039865 你需要的正是一个外观：有了外观模式，通过实现一个更合理的接口的外观类，你可以将一个复杂的子系统变的容易使用。所以我们引入一个外观类HomeTheaterFacade，这个类中组合了所有与放映电影相关的对象（爆米花机、投影仪等等），它提供了一些更加友好的方法（每个方法都是一个子系统）以供调用，调用方不用知道方法内部是如何做的，以放映电影为例，调用方只需要提供需要完成放映操作的对象实例化HomeTheaterFacade，再调用它的watchMovie()方法，引入外观模式后的类图如下所示： 家庭影院外观类图 放映电影的内部方法代码和调用放映电影方法的代码见下图： 放映电影方法、调用放映电影方法的代码实现 适配器模式和外观模式总结适配器模式在不修改接口的代码的基础上，提供了将一个接口转成另一个接口的方法，以达到兼容。 外观模式定义了一个高层接口,让子系统更容易使用，接口简单对调用方更友好。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter5","date":"2020-04-18T14:19:15.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter5/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「单件模式(Singleton Pattern)」。 单件模式（也常叫单例模式）可以说是最简单的设计模式了，然而具体实现的还是有些讲究的，本文梳理了四种单例模式的实现方法 。其中前三种是书上给出的，最后一种书上没有提到，以作补充。 单例模式的基本认识 定义：单件模式确保一个类只有一个实例，并提供一个全局访问点。 用来创建只能有一个实例的独一无二对象。 比如说线程池、缓存、对话框、处理偏好设置、注册表、日志对象、打印机等设备的驱动程序的对象。 可以确保只有一个实例会被创建，单件模式给了我们一个全局的访问点，和全局变量一样方便，又没有全局变量的缺点。 单例模式的四种实现方法一、懒汉 实现 私有的构造函数 私有的静态变量表示唯一实例，不初始化 公开的静态方法获取唯一实例 分析 优：延迟实例化(lazy instantiaze) 类加载时不会初始化，用到了才会产生(实例化) 缺：多线程可能引发创建多个实例(在不加synchronized关键字的情况下) 改进：为getInstance()方法加上synchronized关键字 引入了新的问题：降低了性能，为什么？ 因为实际上只有第一次执行此方法时，才真正需要同步，一旦设置了instance变量，就不再需要同步这个方法了。所以说，之后每次调用这个方法，同步都是一种累赘。 1234567891011121314151617/** * @used to: 懒汉实现单例模式，两私有一公开 */public class Singleton &#123; private static Singleton instance; private Singleton()&#123; &#125; public synchronized static Singleton getInstance()&#123; //如果不加synchronized关键字，多线程情况下，此处可能创建多个不同的实例对象 if (instance ==null) instance =new Singleton(); return instance; &#125;&#125; 二、饿汉饿汉单例模式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快。 实现 私有的构造函数 私有的静态变量表示唯一实例，初始化 公开的静态方法获取唯一实例 分析 与懒汉比较：饿汉在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度较快 优：不会有多线程导致创建了多个实例的问题 缺：即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。 1234567891011121314/** * @used to: 饿汉实现单例模式 */public class Singleton2 &#123; private static Singleton2 instance = new Singleton2(); //类加载时完成初始化 private Singleton2()&#123; &#125; public static Singleton2 getInstance()&#123; return instance; &#125;&#125; 三、双重校验锁DCL【推荐】 目标：是对懒汉中同步性能的优化，实现有更高同步性能的延迟加载。 实现 private static volatile Singleton instance 为什么要volatile？ if (instance == null) 校验1 synchronized (Singleton.class) if (instance == null) 校验2 分析 123456789101112131415161718192021/** * @used to: DCL（双重校验锁）实现单例模式 核心：volatile和两次校验 */public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3()&#123; &#125; public Singleton3 getSingleton()&#123; if (instance == null)&#123; //校验1,仅当singleton为空会进行同步。 synchronized (Singleton3.class)&#123; if(instance == null)&#123; //校验2，防止多线程中，不同线程执行到校验1，然后依次获得多个实例。 instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125;&#125; 四、静态内部类【推荐】 书上没给出这种方法，是从其他博客中学习到的。 1234567891011121314151617/** * @used to:静态内部类实现单例模式 */public class Singleton4 &#123; private static class SingletonHolder&#123; //静态内部类 private static Singleton4 instance = new Singleton4(); &#125; private Singleton4()&#123; &#125; public static Singleton4 getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 分析 它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。 不一样的是，它是在内部类里面去创建对象实例。 这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。 总结评价单例模式的四种实现方法主要从以下两个角度考虑： 是否延迟加载((lazy instantiaze)) ？ 怎么保证线程安全，在保证线程安全的情况下，性能如何 ？","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter4","date":"2020-04-18T08:38:11.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter4/","text":"本篇博客是《Head First 设计模式》第四章的读书笔记。 分享主题是设计模式中的 「工厂模式(Factory Pattern)」。 本读书笔记系列前几篇文章写得比较冗长，耗时也久，大半天才写出一篇博客。从这篇开始，尝试换种风格，尽量写的简洁一点，忽略一些不必要细节，先整体过一遍再来看看有无补充得必要。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"《Head-First-设计模式》读书笔记charpter3","date":"2020-04-18T02:12:57.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter3/","text":"本篇博客是《Head First 设计模式》第三章的读书笔记。 分享主题是设计模式中的 「装饰者模式(Decorator Pattern)」。 应用背景——种类繁多的饮料的“类爆炸”背景书中给出的例子是，一家饮品店的饮品种类繁多，且客户可以自行选择在饮品内加入收费的调料（调料当然也有多种）。即使是同一种的饮品，由于加入了不同的调料，价格也会有差异，如何计算饮品的价格就成了一个问题。如下图1，书中给出的第一个尝试是列举所有饮品的可能情况来构成饮品的所有子类，如HouseBlendWithSoy(表示带调料Soy的HouseBlend饮品类)，由于饮品和调料的组合方式很多，这势必会造成”类爆炸”。 图1 但凡有点开发经验的都不会像上面这样做，我们往往都能想到通过继承解决类爆炸的常规思路，而继承解决会带来一些问题，这就需要引出本文的主角装饰者模式了，一起来看看吧。 通过继承解决具体做法是：为饮品父类中添加一些布尔类型的成员变量(如milk、soy等,都是调料名)来表示是否有该调料，和它们对应的成员方法(如hasMilk())。在父类的计算饮品价格方法 cost()中，依次判断是否加入了各调料，也就是判断该调料的变量是否为true，如果是true就在饮品的基础上加上这种调料的价格。如此一来，针对一个带特定调料的饮品对象，只需要设置它的这些成员变量的状态，使用继承自父类的cost()方法就能计算价格了。这种做法很简洁易懂，然而可拓展性不好：如果客户需要在饮品中加入双倍的某种调料，就要修改现有的代码：在饮品的父类中再加入多个成员变量(如milkNum,soyNum)来记录饮品的调料数目，同时，也会修改父类计算饮品价格的cost()方法，因为现在还要乘上调料的数量。 通过装饰者模式解决现在我们还不用着急知道什么是装饰者模式，只需要知道它的基本思路就是：用一种种调料层层“包装”饮品，然后逐级调用cost()方法来获得最终饮品的价格。 下图是用调料层层包装饮品的示例，模拟了加入了两种调料(Mocha和Whip)的DarkRoast饮品。 图2 我们姑且把调料叫做装饰者，把饮品叫做被装饰者。但是，这里有个小细节，调料既可以用来包装饮品（如图上红字标出的调料1对象包装了一个饮品对象），还可以包装其他调料（如图上红字标出的调料2包装了一个调料1对象），也就是说调料1在这里既作为最内层饮品的“装饰者”，又作为外层调料2的“被装饰者”。 为了标记每个装饰者包装的对象是谁，我们有必要在装饰者类（就是调料类）里设置个成员变量warppedObj——一个指向“被装饰者”的引用，那这个成员变量的类型应该是什么呢？这里有点绕，再次强调一下，调料2的“被装饰者”是调料1，其类型是调料，调料1的“被装饰者”是饮品，其类型是饮品，所以说这里怎么设置warppedObj的类型都不对：如果设置成饮品类，那么调料2就无法包装调料1，如果设置成调料类，那么调料1就无法包装饮品。也就是说如果要正确设定warppedObj类型以支持以上情形，就要完成调料类和饮品类的类型统一。书中的做法是让调料类继承饮品类，以达成类型的统一。 搞懂了这个，接下来的事情就好办了，如上图2，我们的目标是：计算有1份Whip、1份Mocha的DarkRoast饮品价格，做法就是先new一个Mocha对象包装DarkRoast对象记作obj1，在new一个Whip对象包装obj1。计算价格的时候调用最外层调料2对象的cost()方法，它的实现是调用其包装了的对象调料1的cost()方法获得调料1对象的价格，再加上自己的价格，而调料1的cost()实现又是调用内层饮品的cost()方法再加上自己的价格，以此类推，计算价格的过程就像上图2标出的6步流程。 如果这个饮品需要加入双倍的Whip调料，只需要再用一层Whip来包装，不用对其他代码改动。 装饰者模式装饰者模式思想在给出装饰者的定义之前，先来谈谈其“主要指导思想”，装饰者模式的指导思想是组合而非继承（在策略模式中也提到过）、开放关闭原则。 组合而非继承 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相关同的行为。然而，如果通过组合的做法扩展对象的行为，就可以在运行时动态地进行拓展。 开放关闭原则 含义：类应该对扩展开放，而对修改关闭。 解读：在不修改任何底层代码的情况下，给你的对象赋予新的职责。 这两条是书中引出装饰者模式的思想，现在理解不了没关系，先通读下文，再来回顾装饰者模式是如何遵循这两条思想的。 装饰者模式定义装饰者模式动态地将责任附加到对象上，若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。 装饰者模式UML图本案例中，使用装饰者模式后，uml图建模如下： 饮品是被装饰者（书中也叫做组件Component），可以被多种调料“包装”，它始终在最内层。 调料是装饰者，用来”包装“饮品，但是需要注意的是，调料同时也可能作为被装饰者，因为它外层可能还有别的调料来包装它。 在uml图中，我们特别需要关注的是饮品类和调料类的关系： 首先，调料子类里组合了饮品的对象。这个其实很好理解，就是记录调料这一装饰者包装了什么饮品（或者是包装了”包装了饮品“的调料）。 其次，调料的父类继承了饮品父类，也就是说调料也是饮品的子类，就像上文说的，它的目的是完成“调料类和饮品类的类型统一”。以我的理解，这里的继承的具体作用有两个:一是让调料类获得饮料类的方法，如cost()方法，二是以便于其它的调料类包装”包装了饮品的调料类“。 实际中的装饰者模式——java.iojava.io包提供的众多输入输出流相关的类，就是应用了装饰者模式。 输入流层层包装，外层流为内层流提供了新的服务。如下图，InputStream是被装饰者类父类,FilterInputStream是一个很多装饰者类的父类，其中有一个InputStream类型的名为in的成员变量。 image-20200418111628569 下面我给出了一个自定义InputStream的装饰类Demo,作用是将输入流字母变成小写。 12345678910111213141516171819202122232425/** * LowerCaseInputStream.class * @Created by hfq on 2020/4/18 * @used to: 编写自己的Java IO装饰者类,负责将输入流字母变成小写 * @return: */public class LowerCaseInputStream extends FilterInputStream &#123; /** * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt; * by assigning the argument &lt;code&gt;in&lt;/code&gt; * to the field &lt;code&gt;this.in&lt;/code&gt; so as * to remember it for later use. * * @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if * this instance is to be created without an underlying stream. */ protected LowerCaseInputStream(InputStream in) &#123; super(in); &#125; public int read() throws IOException &#123; int c = super.read(); return c==-1?c:Character.toLowerCase((char)c); &#125;&#125; 测试代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * JavaIoTest.class * @Created by hfq on 2020/4/18 * @used to: 测试代码 * @return: */public class JavaIoTest &#123; public static void main(String[] args) throws Exception &#123; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(\"designpatternlearning.iml\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"文件不存在！\"); &#125; System.out.println(\"读到的第一个字符是:\"+(char)inputStream.read()); DataInputStream dataInputStream = new DataInputStream(inputStream); //使用DataInputStream包装InputStream System.out.println(\"读到的一行字符是:\"+dataInputStream.readLine()); //使用自定义的DataInputStream包装InputStream LowerCaseInputStream lowerCaseInputStream = new LowerCaseInputStream(dataInputStream); int c = 0; System.out.println(\"剩下的字符【经过自定义IO流过滤大写字母为小写字母处理】：\"); while((c = lowerCaseInputStream.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; inputStream.close(); //长得更像装饰者模式的写法： InputStream in = new LowerCaseInputStream(new DataInputStream(new FileInputStream(\"designpatternlearning.iml\"))); while((c = in.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; in.close(); &#125;&#125; 总结 装饰者模式的UML建模图 如上图所见，装饰者模式的核心就是：装饰者既是一个(is-a)被装饰者，又有一个(has-a)被装饰者。 is-a 装饰者和被装饰者是相同的类型，这样做是为了利用继承达到“类型匹配”而不是为了利用继承“获得行为”。“类型匹配是说”一个装饰类的接口必须与被装饰类的接口保持相同。 has-a 指的是在装饰者的类中组合了一个被装饰者对象。 感悟 首先我觉得，书中这个这个例子其实并不是很好，调料类继承了饮品类，虽然知道它这样做是为了统一类型（使得装饰类既可以包装饮品，也可以包装其他的装饰类），但将调料作为饮品的子类的子类总归很别扭。 另外我觉得理解装饰者模式的核心就是理解”装饰类的接口必须与被装饰类的接口保持相同”，其根本原因是装饰者既要包装被装饰者，也要包装和它同类型的其他装饰者。 装饰者模式通过“层层包装”来装饰内层对象，为最内层的原对象锦上添花，添加新功能，扩展性好。 最后，以书中关于开放关闭原则的描述结尾： 代码应该如同晚霞中的莲花一样关闭（免于改变），如同晨曦中的莲花一样开发（能够扩展）。 这也就是引入装饰者模式的目标吧！","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"cxsj项目-停车位使用情况可视化","date":"2020-04-10T00:53:18.000Z","path":"2020/04/10/cxsj项目-停车位使用情况可视化/","text":"需求分析在智慧停车管理平台(WEB端)项目中，为了清晰地展示当前停车场的车位使用情况，想到把车位的使用状态可视化地展示到室内停车场地图上。效果如下： image-20200410113840534 根据室内地图的车位图标颜色不同，用户可以看到停车场各个车位的使用状态。此外，当用户点击地图内的车位图标时，还能获取当前指定车位的状态（是否占用，如果占用，还会显示车牌号）。 实现技术前端：Jquery (ajax请求数据) 后端：SpringBoot Mybatis (数据库查询数据) 室内地图支持：Esmap （地图展示) 实现方案1. 引入Esmap的室内地图,熟悉其sdk首先，从下载室内地图的示例，以获得示例地图的数据包。我选择的是“基本地图显示”示例。 然后，在html中引入室内地图，这一步Esmap官网的开发文档有详细的流程我就不多介绍了。按照指示引入地图到html后，实现的初始效果如下： image-20200409174547260 示例默认的主题颜色比较单调，可以通过配置参数来修改主题样式（如地图背景颜色等）。 接下来，熟悉Esmap的sdk，本案例中，我们主要关注的就是：如何跟踪点击事件？(用户点击后停车位能够触发操作)，修改图标的颜色（加载车位可视化页面时根据车位的使用状态为车位图标设置不同的颜色），发现这分别对应开发文档中地图事件中的“地图点击返回事件”和常用方法中的“改变房子颜色”的changeModelColor()方法。 接下来我们就研究一下这两个方法。 方法1：地图点击返回事件12345//地图点击返回事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.htmlmap.on('mapClickNode', function(event) &#123; console.log(event); //打印事件&#125; 可以发现，当点击地图的车位图标时，打印的车位对象如下图。 image-20200410095433726 因为点击地图其他图标(比如说楼梯、道路)也会触发地图点击事件，而在本案例中我们只要关注点击车位事件，所以我们可以以地图点击返回事件event中的name属性里是否包含”车位”二字来区分被点击的图标是否为车位，如果判断是车位，才会触发后续的方法changeModelColor()来改变被点击车位的颜色。 方法2：改变房子颜色123456789//改变房子颜色(一定要在地图加载完成事件之后才有效)//id,name二选择一，都可以是数组, fnum可选择，参数color:'#FF0000'//https://www.esmap.cn/escopemap/content/cn/develope/map-fun.htmlmap.changeModelColor(&#123; //id:[1,2], name:'车位1091', //fnum:[1], color:'#FF0000'&#125;) 需要注意开发文档里指出的”一定要在地图加载完成事件之后才有效”。也就是说，changeModelColor()方法要在加载完成事件完成后调用，如下： 12345//地图加载完成事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.html map.on('loadComplete', function () &#123; map.changeModelColor()方法要在此调用！！！&#125;); 至此，我们就完成了地图页面展示，掌握了点击车位图标触发事件的方法和修改车位图标颜色的方法。 2. 创建停车位的数据表和后端api接口在我创建的车位数据表中，有这样几个主要字段： 车位标识id：由于在本案例我们使用的室内地图数据包中，所有车位对象的name属性在“车位1001~车位1102”，为了下一步地图车位对象和数据库记录的绑定，车位id的值也设置在此范围内。 车位所在停车场标识parkinglot_id：由于我的项目涉及到多个停车场，需要此字段，如果只是有一个停车场可以不用此字段。 车位状态标识in_use：若车位是空闲状态，取值0，若占用取1。 车牌号car_id：若车位占用，存车牌号，否则为空。 停车时间park_time：若车位占用，存此车进入车位的时间戳，否则为0。 创建好车位数据表之后，生成一些假数据（我是通过写了一个java类，按照给定格式随机生成记录，然后拼接字符串打印这条记录的insert语句，然后到数据库执行，后来网上了解一下，或许可以尝试使用Python的伪造数据生成器Faker），生成的部分假数据如下图展示。 image-20200410102612112 下一步，写一个Controller，完成车位查询的api接口，响应POST方法，为请求返回json数据，代码如下： 1234567891011121314151617181920212223242526/** * * @param parkinglot_id 停车场ID * @param parking_space_id 车位id * @return * 如果参数parking_space_id 为空，查找所有停车场ID为parkinglot_id的所有车位使用情况 * 如果参数parking_space_id非空，根据停车场id和车位id 查询一条记录。 */ @ResponseBody @PostMapping(\"/parkinglot/&#123;parkinglot_id&#125;/space\") private Object selectAllSpace(@PathVariable(name = \"parkinglot_id\") Integer parkinglot_id, @RequestParam(name = \"parking_space_id\",required = false) Integer parking_space_id )&#123; ParkingSpaceExample example = new ParkingSpaceExample(); if(parking_space_id!=null)&#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id) .andIdEqualTo(parking_space_id); &#125; else &#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id); &#125; List&lt;ParkingSpace&gt; parkingSpaces = parkingSpaceMapper.selectByExample(example); return parkingSpaces; &#125; 如果请求时携带了parking_space_id参数，就只查询车位id等于parking_space_id的那条车位记录，否则，查询该停车场的全部车位记录。请求参数携带车位标识和不携带车位标识这两种请求应用场景分别是：加载页面时，需要查询全部车位的车位状态，而用户点击地图的某个车位图标时，只需要查询这一个车位状态。 当不携带车位标识时，某次请求响应的部分json数据如下图展示。 image-20200410104637275 至此，我们就完成了车位数据表的建立和查询。 3. 将地图显示和数据库“绑定”这一步我们就完成可视化的任务，具体需要完成的功能有两个：功能一是加载车位详情页面的时候，查询车位数据表，根据车位状态为地图的车位图标“上色”（空位占用则红，车位空闲则为绿）；功能二是当用户点击车位图标时，查询数据库该车位的当前状态并显示出来（如果车位占用还会显示出当前的车牌号）。 有了步骤1、2的基础后，这一步就很简单了，简单地说，就是用步骤2的数据填充到步骤1的方法内。具体做法是在javascript脚本中使用ajax请求获取后端的车位数据，然后对这些数据按指定格式处理，作为调用Esmap sdk的配置参数。 以功能一的实现为例： 使用ajax向步骤2中编写好的用于查询车位的api接口发送请求，获得请求后的json数据后，遍历每条数据（对应车位数据表的一条记录），根据数据的inUse属性的取值来标识车位是占用还是空闲状态，然后拼接“车位”二字到数据的id属性的取值，就获得了这条记录对应在地图上车位图标对象的name属性（也就是说，数据库中的车位id为1001的车位记录对应地图上name=”车位1001”的地图对象)。设置js数组inUseNameList和notInUseNameList，它们分别是全部占用车位对应的地图车位图标的name属性数组、全部空闲车位对应的地图车位图标的name属性数组。调用 map.changeModelColor()方法设置地图车位图标的颜色时，指定name参数为inUseNameList，颜色设置成红色，指定name参数为notInUseNameList，颜色设置成绿色。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 完成功能一：当地图加载完成时，设置停车位的颜色 */function loadSpace() &#123; var inUseNameList = new Array(); //全部的占用车位对应的地图车位图标的name属性数组 var notInUseNameList = new Array(); //全部的空闲车位对应的地图车位图标的name属性数组 var pathname = window.location.pathname; var parkinglot_id = pathname.charAt(pathname.length-1); console.log(pathname); $.ajax(&#123; //使用ajax请求数据 method: \"POST\", url: \"/parkinglot/\"+parkinglot_id+\"/space\", &#125;) .done(function( spaceList ) &#123; // console.log(spaceList); //打印全部车位信息 $.each(spaceList,function(i,space)&#123; var spaceName = \"车位\"+space.id; if(space.inUse==1)&#123; //表示车位被使用了 inUseNameList.push(spaceName); &#125;else &#123; notInUseNameList.push(spaceName); &#125; &#125;); map.changeModelColor(&#123; //占用车位设置成绿色 name: inUseNameList, color: '#FF0000'&#125; ); map.changeModelColor(&#123; //空闲车位设置成绿色 name: notInUseNameList, color: '#00FF00'&#125; ); &#125;);&#125;","tags":[{"name":"项目","slug":"项目","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://hfq123.github.io/tags/JavaWeb/"}]},{"title":"《Head-First-设计模式》读书笔记charpter2","date":"2020-04-06T14:26:09.000Z","path":"2020/04/06/《Head-First-设计模式》读书笔记charpter2/","text":"本篇博客是《Head First 设计模式》第二章的读书笔记。 分享主题是设计模式中的 「观察者模式(Observer Pattern)」。 1、应用场景—气象监测应用书中给出的例子是：公司要建立一个气象监测应用，如下图，WeatherData对象会从气象检测站获取实时更新的气象数据（湿度、温度、气压），WeatherData对象要做的就是将这些数据及时“分发”到多个布告板，使得每个布告板能使用最新的气象数据以更新它的显示情况。除此之外，附加的需求是系统必须可扩展，能够让用户随心所欲地添加或删除布告板，也就是说，目前系统有“目前状况”、“气象统计”、“天气预报”三个布告板，以后可能会删除某个或者新增别的布告板，言外之意就是说，WeatherData对象要随时准备好停止向现有的布告板分发最新数据以及随时准备好向新的布告板分发最新数据。 image-20200406223021520 2 实现思路2.1 错误示范我们先来看一个很容易想到的思路，然而这被书中称之为“错误示范”（这也是我学习观察者模式之前的思路）。首先我们先约定：一旦气象站测量的气象数据更新，WeatherData类的measurementsChanged()方法就会被调用，在本文，我们不用关心它是怎么做的，只要知道在此方法下，我们要做的就是将这些数据及时“分发”到多个布告板类。 接下来我们就一起来看看这个简单自然但是错误的示例吧，如下图，在WeatherData类的中measurementsChanged()方法里，做的事情很简单，就是获得最新的气象数据，然后以此作为参数各个布告板类的更新方法。 image-20200406223736428 看似完全能实现我们的需求：当气象站检测到新的数据，measurementsChanged()被调用：获得最新的气象数据，然后分别调用各个不同的布告板的update()方法（在这个方法里，布告板会根据自己的需求使用最新数据来改变显示板，我们无需关注update()方法里究竟做了什么，只要知道它需要获得WeatherData类的最新气象数据，供它们更新自己的数据以改变显示屏）。 这样实现究竟有哪些错误呢？ 各个布告板类之间是独立的，没有一个共同的接口，是典型的“针对实现而非针对接口编程”的错误。 每当添加或删除新的布告板，我们都不得不修改方法体内的代码。比如说设计了一个新的testDisplay布告板，我们就要加上一行testDisplay.update(temp,humdity,pressure)，当testDisplay不再需要获取最新的气象状态，就要删除这行代码。 也正是因为每当添加或删除新的布告板，我们都不得不修改方法体内的代码，所以我们无法在运行时动态地增加或者删除布告板。 2.2 观察者模式引入观察者模式就能解决上述实现带来的问题。 先简单介绍一下什么是观察者模式，在观察者模式中，有两个主角，分别是主题(Subject)和观察者(Observer)，书上用了“出版者”和“订阅者”来类比观察者模式中的主题和观察者。出版者一旦出版新的报纸，他就要负责将新报纸分发到各个订阅者手中，而那些没有订阅报纸的人就不会收到，就和这里的例子一样，WeatherData类一旦获得新的气象数据，就要负责分发到各个布告板类中。观察者模式的概念是：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 借助下图，能够让我们清楚地看到观察者模式的“一对多依赖”。 image-20200406230651346 观察者模式为主题和观察者都创建了各自的接口。在主题接口中，定义了注册观察者(registerObserver)方法、撤销观察者(removeObserver)方法、更新所有观察者状态方法（notifyObservers,一旦主题状态改变会触发）；在观察者接口中，定义了更新观察者状态的方法(update)。 image-20200407002547510 我们再把目光转移到应用场景，前面我们已经分析了思路1实现带来的问题，接下来就要好好考虑怎么解决： 首先，我们可以考虑需要为所有布告板类创建一个观察者接口，因为在WeatherData类中，WeatherData不关心布告板是叫currentConditionDisplay还是叫statisticsDisplay，只关心它是否需要在气象数据更新时获得自己的最新气象数据，如果它实现了观察者接口并且注册了主题（相当于订报人完成了订阅动作），那么当WeatherData类的数据更新时，它就是分发数据的目标之一。 然后，我们可以在WeatherData类中维护一个所有观察者组成的列表，这样做能让WeatherData类轻松地获取所有观察者（布告板）。有了观察者列表之后，每当WeatherData类的数据更新，就遍历列表内的所有布告板，调用它们的update()方法即可，WeatherData类不用再关注有几个观察者布告板，它们叫什么名字。当需要添加或删除新的布告板的时候，只需要对列表做增删操作，而不用像思路1中那样改动measurementsChanged()方法体内的代码，同时，这也解决了不能运行时动态地增删布告板的问题，因为运行时可以动态的修改列表的元素（比如说系统运行了十分钟后将currentConditionDisplay公告板从观察者列表中移除）。 想到这些，引入观察者模式之后的模型就呼之欲出了。引入观察者模式之后，本气象站应用的的类图就如下图所示，WeatherData和各布告板分别实现主题接口和观察者接口。 image-20200407002514351 接下来我们从代码的层面上来考虑一下主题的方法是如何实现的。 registerObserver(Observer o)：将观察者对象o加入到WeatherData维护的观察者列表。 removeObserver(Observer o)：将观察者对象o从WeatherData维护的观察者列表中删除。 notifyObservers():遍历WeatherData维护的观察者列表，在循环体内调用每个观察者对象的update()方法。 对比思路1和思路2，可以发现，通过引入观察者模式，我们不仅能方便地实现布告板的增删：当有了新的布告板对象o要“监听”WeatherData的最新数据，就调用registerObserver(o)，当它不再需要获取最新气象数据，就调用removeObserver(o)，还能在运行时动态地增删布告板：，比如说为布告板对象o设置一个“监听”时间10分钟，在10分钟内，它需要监听主题的状态变化，10分钟以后，它就不需要再监听，那么就可以通过在到达10分钟的时候调用removeObserver(o)将其从观察者列表移除即可。 3、总结与思考从观察者模式的两个主角来看，主题拥有自己的一些状态(参考例子中WeatherData对象的天气数据)，而多个观察者想要获知这些状态来改变自身的状态，从而构成了一对多依赖。主题向全体观察者通知，观察者可以随时决定取消监听主题。 如果我们仔细体会本例中一下思路1到思路2的转变，会发现实现了一个松耦合的过程，在思路1中，主题需要关注观察者是谁，而引入观察者模式后，主题不需要知道观察者的具体类是谁，只知道观察者实现了某个接口，有新的观察者出现时，主题的代码不需要修改，二者并非紧耦合。改变主题或观察者其中一方，不会影响另外一方。 最后，本文以一条设计原则结尾。为了交互对象之间的松耦合设计而努力。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"20200406 算法题2则","date":"2020-04-06T14:21:31.000Z","path":"2020/04/06/20200406算法题2则/","text":"今天在牛客网刷了两道剑指offer关于二叉树的题，都比较简单，都可用分治法的思路解决。 题1：二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 我的解答12345678910public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); int max=leftDepth&gt;rightDepth?leftDepth:rightDepth; return max+1; &#125;&#125; 解析：略 题2：二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 &#x2F; \\ 6 10 &#x2F; \\ &#x2F; \\ 5 7 9 11 镜像二叉树 8 &#x2F; \\ 10 6 &#x2F; \\ &#x2F; \\ 11 9 7 5 我的解答：1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 解析：这里需要注意必须交换左子树根节点和右子树根节点的引用而非交换取值。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://hfq123.github.io/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"《Head First 设计模式》读书笔记charpter1","date":"2020-04-05T07:10:41.000Z","path":"2020/04/05/《Head-First-设计模式》读书笔记charpter1/","text":"本篇博客是《Head First 设计模式》第一章的读书笔记。 分享主题是设计模式中的 「策略模式(Strategy Pattern)」。 1、应用场景—一群鸭子引发的故事。书中给了这样一个例子作为应用场景引入：某公司有一套模拟鸭子游戏，游戏中会出现各种各样的鸭子，这些鸭子有一些动作：呱呱叫、戏水。按照面向对象的思想，系统设计为鸭子这一对象设计了一个名为Duck的超类，在这个类中，为实现动作呱呱叫、戏水分别设置了quack()、swim()方法，而各种不同种类的鸭子通过继承这一超类获得这些描述鸭子动作的方法。 接下来问题来了，系统引入了一个新的需求：让鸭子飞起来。开发人员需要为鸭子类加入描述飞行动作的方法，书中也是以实现此需求展开来引入策略模式的。 2、解决思路—继承还是接口 ？2.1 通过继承实现首先,我们很自然地想到，可以在超类Duck中加入一个fly()方法（就像quack()、swim()方法一样），子类通过继承获取描述鸭子飞的方法。 分析： 因为所有子类都会继承超类Duck的方法，即使是一些不能飞的鸭子如橡胶鸭也会继承fly()方法，这样做我们不得不在子类橡胶鸭中重写fly()方法以覆盖继承的方法，比如说，将其子类中不会飞的鸭子的fly()方法体修改成什么都不做。同理，如果有不会叫的鸭子，又需要在该子类中重写quack()方法。 评价：这种思路是最容易想到的,主要利用了面向对象的继承、多态（体现在重写方法）特性。在代码重用上有一定效果，因为子类可以重用父类的fly()方法，但是也存在了一些缺点： (ps:这四个缺点是书中的一道多选题，只给出了答案，具体解读为自己的想法，如有不对，欢迎指正)。 代码在多个子类中重复：假设鸭子有多种飞行方式，那么我们无法仅通过继承超类的fly()方法来描述所有鸭子的飞行方式。我们必须为所有与超类中fly()实现的飞行方式不一致的鸭子子类编写fly()的覆盖方法，而具有相同的飞行方式但不同于超类中fly()给出的飞行方式的众多鸭子子类的覆盖方法将会是一样的，导致代码重复。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们需要看完Duck超类的fly()方法和全部的鸭子子类覆盖的fly()方法才能知道鸭子全部的飞行方式。 运行时的行为不容易改变：通过继承实现，每一个特定的Duck对象的飞行方式都是确定的，这是因为在它的 fly()方法是写死的，每个Duck对象的飞行方式已经在其创建的时候确定了，也就是说，鸭子不能中途切换飞行方式。 改变会牵一发而动全身，造成其他鸭子不想要的改变：这是指如果修改了超类的fly()方法，会影响到其子类。 下文可以看到，通过使用策略模式能有效解决这些问题。 2.2 通过接口实现上面的解读以fly()举例，其实其他方法也可能存在类似的问题，比如说如果不同类的鸭子叫法不同，继承的quark()方法也会存在上述问题，有的鸭子这样飞、叫，有的鸭子那样飞、叫，有的鸭子不飞不叫。这时，我们就想到了将fly()、quark()从超类中取出来放进一个接口。如下图，以fly()为例，将其放进一个名为Flyable的接口。 image文件夹 *分析 *：这样一来，如果一个鸭子子类会飞则实现Flyable接口，将其fly()方法写到子类的方法体，如果不会飞则无需实现。 评价：从超类中分离出有些子类不需要的fly()、quack()方法，这样避免了部分子类继承它压根不需要的方法的情况。然而这样做的缺点也很明显，每次编写一个会飞的新的鸭子子类，都必须在子类中单独实现fly()方法（即使有和它飞行方式一样的其他子类），导致代码根本无法重用，所以这种方法非常不可取。 2.3 策略模式如何弥补思路1、2的缺陷，这就需要引入策略模式这一设计模式，讲策略模式之前，先引入2条设计原则。 设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 在本案例中，我们假设容易变化的方法是fly()和quack()，而每个鸭子的游泳方式是一样的，即swim()方法是不需要变化的。所以设法将fly()和quack()方法从超类中抽取出来建立一组新的结构来代表每个行为，而swim()方法继续保留在Duck超类中。 设计原则2：针对接口编程，而不是针对实现编程。 我们可以利用接口代表每个行为，比如说，引入接口FlyBehavior与QuackBehavior分别代表了飞行、呱呱叫的行为，通过实现FlyBehavior接口的fly()方法，建立各种各样飞行的行为类，来描述不同飞行方式。与思路2通过接口实现的区别在于，我们不再是直接在Duck或者是它的子类中实现不同的fly()方法，而是再另外引入一个实现了FlyBehavior接口的行为类来实现fly()方法。本系统中，每个飞行的行为类都实现了FlyBehavior接口，而在Duck类中，我们定义一个FlyBehavior接口型的成员变量，来保存其对应的行为类的指针，以调用其飞行方法。 image-20200406005221237 这样做就是策略模式的思路。使用策略模式后，本系统的全局类图如下图展示， 不变的方法swim()仍然在Duck超类中实现，而经常改变的fly()、quack()方法被抽离成为接口，再用具体的行为类去实现这些接口，在Duck超类中，保存对应的行为类一个对象的指针以确定该类鸭子的对应的fly、quack行为。 image-20200406003932396 为什么说引入了策略模式会解决上述继承的四个问题呢？ 代码在多个子类中重复：如果使用继承，如果鸭子的飞行方式与超类中给定的的不一致，即使是有同样飞行方式的鸭子子类，也不能重用代码，因为它们都要在各自的类里重写fly()方法。而引入策略模式后，只需要为有同样飞行方式的鸭子子类编写一个实现了FlyBehavior的行为类。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们只需要关注实现了FlyBehavior接口的所有类的fly()方法就能知道鸭子的全部行为。 运行时的行为不容易改变：通过改变Duck或其子类对象的行为类的指针，就可以实现运行时切换飞行方式，也就是说，在Duck类中创建一个setFlyBehavior()方法，就可以随时改变鸭子的行为。 改变会牵一发而动全身，造成其他鸭子不想要的改变：如果某种鸭子的飞行方式有所改变，只需要改变其行为类的引用，不影响其他鸭子子类。 3、总结与思考 image-20200406014158325 是时候给出策略模式的概念了（像本文一样，书中在本章节的最后才给出其概念，也就是讲完了所有细节再告诉你你已经不知不觉地学会了策略模式，我个人觉得这种学习方法比较适合人认识新事物的规律，否则，如果开头就先抛出这个晦涩的概念就能把人吓跑了！）： 策略（Strategy）模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 本项目中，我们可以把鸭子飞行的方式看作是策略，描述不同鸭子飞行方式的代码就构成了策略的算法族。之所以说策略模式让使“算法的变化独立于使用算法的客户”，是因为使用策略模式可以方便地更改客户正在使用的策略（通过更改Context类中对策略的引用）。如果认为使用思路1的继承方法，不厌其烦地在子类中编写fly()的覆盖方法、多写上几行重复代码是可以接受的话，那么，能够随时方便地为类替换策略这个优点就是你无法拒绝策略模式的理由。 这里也就引出了组合和继承(有一个VS是一个)的关系：使用策略模式之后 ，在Duck的子类中通过FlyBehavior、QuickBehavior接口间接地组合了飞行、呱呱叫的行为类，这是“有一个”的关系，理解成Duck的某个子类“有一个“飞行策略。而如果使用继承，则是”是一个“的关系，Duck的子类继承了父类的fly()方法或者重写后获得了自己的fly()方法，不能做到在运行时候动态地改变行为。在使用策略模式后，策略是以”行为类“的方式存在的，而如果使用继承，策略是以方法的形式写死在类里。使用策略模式后，当类的策略在运行时需要发生改变，只需要改变”有一个“的状态，由有一个策略A变成一个策略B，只需要修改其接口的引用（就像修改任何一个普通成员变量一样）。而如果使用继承，想要修改某个鸭子的飞行方式，需要通过修改其fly()方法的代码，当然也就做不到动态地完成改变行为了。综上对组合和继承的讲述，引出了一条新的设计原则： 设计原则3：多用组合，少用继承。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"笔记","slug":"笔记","permalink":"http://hfq123.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"我的第一篇博客","date":"2020-04-04T13:03:27.000Z","path":"2020/04/04/我的第一篇博客/","text":"引言我正在尝试使用Hexo搭建博客,其实早就有搭建博客的想法 ,然而一直没有去实现,今天刚做完一个SpringBoot项目。闲着无事心血来潮就开始了,完工后才发现原来搭建一个自己的博客这么简单且高效，有点相见恨晚的感觉。这第一篇博客就来简单记录一下我本次搭建博客的路线，以作纪念。以后我会更多地在此分享自己的学习内容，记录开发遇到的问题。 搭建环境本次博客搭建使用到的工具有 Hexo + Github。 Hexo是一个博客框架，让我们从渲染前端页面、部署JavaWeb开发环境中解脱出来，把更多的精力放在写博客这件事情本身上，如其官网介绍： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo的灵活性体现在其大部分前端显示内容都是通过参数来配置的，包括整个博客的主题、模板都可通过配置完成（下文会讲搭建好博客后如何更换主题）。 1586022290377 Github大家都比较熟悉，这里主要用到了它的Github Pages的功能来提供远端访问的支持，不使用Github，只使用Hexo工具也能搭建博客，不过只能在本地端口访问。 搭建步骤1 、安装Hexo 2、关联Github的库 3、更换自己喜欢的博客主题 本打算重做以详细记录一下这几个步骤，但是想想这次部署之后以后也没有必要重新部署了，再加上网上已经有很很详细的教程了，重新做一次对自己提升不大，就不浪费时间，所以直接贴教程：手把手教你用Hexo+Github 搭建属于自己的博客 遇到问题特别要注意在修改配置文件_config.xml中的配置项时的格式，正确格式形如：”属性: 空格 值”，如”title: 然后就的博客”。如果冒号和值之前没有空格隔开执行hexo命令时会报错。 以上就是本篇博客的全部内容了，没什么干货，差不多是简单的流水账，仅是为了纪念第一篇博客，以后争取只写高质量的博客！！！","tags":[{"name":"工具","slug":"工具","permalink":"http://hfq123.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","date":"2020-04-04T12:24:26.585Z","path":"2020/04/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]