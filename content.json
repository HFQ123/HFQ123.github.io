[{"title":"《Head-First-设计模式》读书笔记charpter3","date":"2020-04-18T02:12:57.000Z","path":"2020/04/18/《Head-First-设计模式》读书笔记charpter3/","text":"本篇博客是《Head First 设计模式》第三章的读书笔记。 分享主题是设计模式中的 「装饰者模式(Decorator pattern)」。 应用背景——种类繁多的饮料的“类爆炸”背景书中给出的例子是，一家饮品店的饮品种类繁多，且客户可以自行选择在饮品内加入收费的调料（也有多种）。即使是同一种的饮品，由于加入了不同的调料，价格也会有差异，如何计算饮品的价格就成了一个问题。如下图，书中给出的第一个尝试是列举所有饮品的可能情况来构成饮品的所有子类，如HouseBlendWithSoy(表示带调料Soy的HouseBlend饮品类)，由于饮品和调料的组合方式很多，这势必会造成”类爆炸”。 image-20200418103234825 但凡有点开发经验的都不会像上面这样做，我们往往都能想到通过继承解决类爆炸的常规思路，而继承解决会带来一些问题，就引出本文的主角装饰者模式了，一起来看看吧。 通过继承解决具体做法是：为饮品父类中添加一些布尔类型的成员变量(如milk、soy等,都是调料名)来表示是否有该调料，和它们对应的成员方法(如hasMilk())。在父类的计算饮品价格方法 cost()中，依次判断是否加入了各调料，也就是判断该调料的变量是否为true，如果true就在饮品的基础上加上这种调料的价格。如此一来，针对一个带特定调料的饮品对象，只需要设置它的这些成员变量的状态，调用cost()方法就能计算价格了。这种做法很简洁，然而可拓展性不好：如果客户需要在某饮品双倍的某种调料，就要修改现有的代码，在饮品的父类中再加入多个成员变量(如milkNum,soyNum)来记录饮品的调料数目，同时，也会父类计算价格的方法，因为现在还要乘上调料的数量。 通过装饰者模式解决现在我们还不用着急知道什么是装饰者模式，只需要知道它的思路就是：用一种种调料层层“包装”饮品。 如下图，是模拟加入了两种调料(Whip和Mocha)的DarkRoast饮品。 图2 如果这个饮品需要加入双倍的Whip调料，只需要再用一层Whip来包装。 装饰者模式装饰者模式思想再给出装饰者的定义之前，先来谈谈其“主要指导思想”，装饰者模式的指导思想是组合而非继承（在策略模式中也提到过）、开放关闭原则。 组合而非继承 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相关同的行为。然而，如果通过组合的做法扩展对象的行为，就可以在运行时动态地进行拓展。 开放关闭原则 含义：类应该对扩展开放，而对修改关闭。 解读：在不修改任何底层代码的情况下，给你的对象赋予新的职责。 这两条是书中引出装饰者模式的思想，现在理解不了没关系，先通读下文，再来回顾装饰者模式是如何遵循这两条思想的。 装饰者模式定义装饰者模式动态地将责任附加到对象上，若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。 装饰者模式UML图本案例中，使用装饰者模式后，uml图建模如下： 饮品是被装饰者（书中也叫做组件Component），可以被多种调料“包装”，它始终在最内层。 调料是装饰者，用来”包装“饮品，但是需要注意的是，调料同时也可能作为被装饰者，因为它外层可能还有别的调料来包装它。 在uml图中，我们特别需要关注的是饮品类和调料类的关系： 首先，调料子类里组合了饮品的对象。这个其实很好理解，就是记录装饰者包装了什么饮品。 其次，调料的父类继承了饮品父类，也就是说调料也是饮品的子类，这里可能会让我们疑惑，调料和饮品是不同的对象，不应该是继承的关系。以我的理解，这里的继承作用有两个:一是让调料类获得cost()方法，二是以便于其它的调料类包装调料类。 实际中的装饰者模式 java.io java.io包提供的众多输入输出流相关的类，就是装饰者模式的应用。 image-20200418111628569 输入流层层包装，外层流为内层流提供了新的服务。InputStream是被装饰者,FilterInputStream是一个装饰类，其中有一个InputStream类型的名为in的成员变量。 下面是给出的一个自定义InputStream的装饰类Demo,作用是将输入流字母变成小写。 12345678910111213141516171819202122232425/** * LowerCaseInputStream.class * @Created by hfq on 2020/4/18 * @used to: 编写自己的Java IO装饰者类,负责将输入流字母变成小写 * @return: */public class LowerCaseInputStream extends FilterInputStream &#123; /** * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt; * by assigning the argument &lt;code&gt;in&lt;/code&gt; * to the field &lt;code&gt;this.in&lt;/code&gt; so as * to remember it for later use. * * @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if * this instance is to be created without an underlying stream. */ protected LowerCaseInputStream(InputStream in) &#123; super(in); &#125; public int read() throws IOException &#123; int c = super.read(); return c==-1?c:Character.toLowerCase((char)c); &#125;&#125; 测试代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * JavaIoTest.class * @Created by hfq on 2020/4/18 * @used to: 测试代码 * @return: */public class JavaIoTest &#123; public static void main(String[] args) throws Exception &#123; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(\"designpatternlearning.iml\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"文件不存在！\"); &#125; System.out.println(\"读到的第一个字符是:\"+(char)inputStream.read()); DataInputStream dataInputStream = new DataInputStream(inputStream); //使用DataInputStream包装InputStream System.out.println(\"读到的一行字符是:\"+dataInputStream.readLine()); //使用自定义的DataInputStream包装InputStream LowerCaseInputStream lowerCaseInputStream = new LowerCaseInputStream(dataInputStream); int c = 0; System.out.println(\"剩下的字符【经过自定义IO流过滤大写字母为小写字母处理】：\"); while((c = lowerCaseInputStream.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; inputStream.close(); //长得更像装饰者模式的写法： InputStream in = new LowerCaseInputStream(new DataInputStream(new FileInputStream(\"designpatternlearning.iml\"))); while((c = in.read()) &gt; 0)&#123; System.out.printf(String.valueOf( (char)c) ); &#125; in.close(); &#125;&#125; 总结 装饰者模式的核心就是：装饰者既是一个(is-a)被装饰者，又有一个(has-a)被装饰者。 is-a 装饰者和被装饰者是相同的类型，这样做是为了利用继承达到“类型匹配”而不是为了利用继承“获得行为”。 has-a 在装饰者的类中组合了一个被装饰者对象。 感悟我觉得，书中这个这个例子其实并不是很好，调料类继承了饮品类，虽然知道它这样做是为了统一接口，但将调料作为饮品的子类的子类总归很别扭。 最后，以书中关于开放关闭原则的描述结尾： 代码应该如同晚霞中的莲花一样关闭（免于改变），如同晨曦中的莲花一样开发（能够扩展）。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"二叉搜索树学习笔记","date":"2020-04-10T05:33:29.000Z","path":"2020/04/10/二叉搜索树学习笔记/","text":"此系列是我数据结构的学习笔记，观看视频课程，网上有很详细的笔记了，所以很多地方没有再展开，着重写下自己的感悟以及记录一些细节。 本篇博客分享主题：「二叉搜索树」。 基本认识二叉搜索树(Binary Search Tree),又叫做二叉查找树、二叉排序树。 任意一个节点的值都大于其左子树所有节点的值。 任意一个节点的值都小于其右子树所有节点的值。 它的左右子树也是一颗二叉搜索树。 image-20200410222712471 为什么要引入二叉搜索树，需求是什么？ 在数组中插入元素，搜索操作平均时间复杂度O(n)，插入操作复杂度O(1) 排好序的数组，二分搜索，最坏时间复杂度O(logn),但插入、删除操作平均复杂度是O(n) 使用二叉搜索树，添加、删除、搜索的最坏事件复杂度均可优化至：O(logn) 从二叉搜索树的定义来看，涉及到比较操作，所以二叉搜索树存储的元素必须具备可比较性。 基本操作123456789101112131415161718public class BinarySearchTree&lt;E&gt;&#123; private int size; // 元素的个数 private Node&lt;E&gt; root; // 根节点 private Comparator&lt;E&gt; comparator; // 比较器 // 元素的数量 public int size() // 是否为空 public boolean isEmpty() // 清空所有元素 public void clear() // 添加元素 public void add(E element) // 删除元素 public void remove(E element) // 是否包含某元素 public boolean contains(E element) &#125; 详细实现思路点击这里。 实现接口时的注意细节 comparable和comparator？ add操作如果遇到相等的情况，为什么要覆盖？ 常用方法遍历(适用所有二叉树) image-20200411002614229 前序遍历(Preorder)，访问顺序： 根节点 -&gt; 前序遍历左子树 -&gt; 前序遍历右子树递归实现。非递归实现 ？！！！待解决 中序遍历(Inorder)，访问顺序：中序遍历左子树 -&gt; 根节点 -&gt; 中序遍历右子树 中序遍历的结果是有序的，因为根据BST的定义，左&lt;中&lt;右。 后序遍历(Postorder)，访问顺序：后序遍历左子树 -&gt; 后序遍历右子树 -&gt; 根节点 层序遍历(Level Order)，访问顺序：从上到下，从左到右依次访问节点。 引入新的问题： 我们是打印逻辑写死在遍历的方法体内，但是并不是所有遍历都是做打印操作，如何自定义对遍历的元素操作的方法？ 设计遍历接口。然后以此接口作为遍历方法的参数，在遍历方法内部调用该接口的遍历操作方法。以便动态指定遍历时对元素的操作。 再次引入新的需求: 遍历到指定条件就终止遍历。 陌生知识点Queue接口的 offer/poll。 感受比较器comparable与comparator的使用 详情 策略模式的体现！。 前中后层四种遍历。 非递归写法还没完成！！。。 为什么只给出前序和后序，不能唯一确定一个二叉树","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hfq123.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"cxsj项目-停车位使用情况可视化","date":"2020-04-10T00:53:18.000Z","path":"2020/04/10/cxsj项目-停车位使用情况可视化/","text":"需求分析在智慧停车管理平台(WEB端)项目中，为了清晰地展示当前停车场的车位使用情况，想到把车位的使用状态可视化地展示到室内停车场地图上。效果如下： image-20200410113840534 根据室内地图的车位图标颜色不同，用户可以看到停车场各个车位的使用状态。此外，当用户点击地图内的车位图标时，还能获取当前指定车位的状态（是否占用，如果占用，还会显示车牌号）。 实现技术前端：Jquery (ajax请求数据) 后端：SpringBoot Mybatis (数据库查询数据) 室内地图支持：Esmap （地图展示) 实现方案1. 引入Esmap的室内地图,熟悉其sdk首先，从下载室内地图的示例，以获得示例地图的数据包。我选择的是“基本地图显示”示例。 然后，在html中引入室内地图，这一步Esmap官网的开发文档有详细的流程我就不多介绍了。按照指示引入地图到html后，实现的初始效果如下： image-20200409174547260 示例默认的主题颜色比较单调，可以通过配置参数来修改主题样式（如地图背景颜色等）。 接下来，熟悉Esmap的sdk，本案例中，我们主要关注的就是：如何跟踪点击事件？(用户点击后停车位能够触发操作)，修改图标的颜色（加载车位可视化页面时根据车位的使用状态为车位图标设置不同的颜色），发现这分别对应开发文档中地图事件中的“地图点击返回事件”和常用方法中的“改变房子颜色”的changeModelColor()方法。 接下来我们就研究一下这两个方法。 方法1：地图点击返回事件12345//地图点击返回事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.htmlmap.on('mapClickNode', function(event) &#123; console.log(event); //打印事件&#125; 可以发现，当点击地图的车位图标时，打印的车位对象如下图。 image-20200410095433726 因为点击地图其他图标(比如说楼梯、道路)也会触发地图点击事件，而在本案例中我们只要关注点击车位事件，所以我们可以以地图点击返回事件event中的name属性里是否包含”车位”二字来区分被点击的图标是否为车位，如果判断是车位，才会触发后续的方法changeModelColor()来改变被点击车位的颜色。 方法2：改变房子颜色123456789//改变房子颜色(一定要在地图加载完成事件之后才有效)//id,name二选择一，都可以是数组, fnum可选择，参数color:'#FF0000'//https://www.esmap.cn/escopemap/content/cn/develope/map-fun.htmlmap.changeModelColor(&#123; //id:[1,2], name:'车位1091', //fnum:[1], color:'#FF0000'&#125;) 需要注意开发文档里指出的”一定要在地图加载完成事件之后才有效”。也就是说，changeModelColor()方法要在加载完成事件完成后调用，如下： 12345//地图加载完成事件//https://www.esmap.cn/escopemap/content/cn/develope/map-event.html map.on('loadComplete', function () &#123; map.changeModelColor()方法要在此调用！！！&#125;); 至此，我们就完成了地图页面展示，掌握了点击车位图标触发事件的方法和修改车位图标颜色的方法。 2. 创建停车位的数据表和后端api接口在我创建的车位数据表中，有这样几个主要字段： 车位标识id：由于在本案例我们使用的室内地图数据包中，所有车位对象的name属性在“车位1001~车位1102”，为了下一步地图车位对象和数据库记录的绑定，车位id的值也设置在此范围内。 车位所在停车场标识parkinglot_id：由于我的项目涉及到多个停车场，需要此字段，如果只是有一个停车场可以不用此字段。 车位状态标识in_use：若车位是空闲状态，取值0，若占用取1。 车牌号car_id：若车位占用，存车牌号，否则为空。 停车时间park_time：若车位占用，存此车进入车位的时间戳，否则为0。 创建好车位数据表之后，生成一些假数据（我是通过写了一个java类，按照给定格式随机生成记录，然后拼接字符串打印这条记录的insert语句，然后到数据库执行，后来网上了解一下，或许可以尝试使用Python的伪造数据生成器Faker），生成的部分假数据如下图展示。 image-20200410102612112 下一步，写一个Controller，完成车位查询的api接口，响应POST方法，为请求返回json数据，代码如下： 1234567891011121314151617181920212223242526/** * * @param parkinglot_id 停车场ID * @param parking_space_id 车位id * @return * 如果参数parking_space_id 为空，查找所有停车场ID为parkinglot_id的所有车位使用情况 * 如果参数parking_space_id非空，根据停车场id和车位id 查询一条记录。 */ @ResponseBody @PostMapping(\"/parkinglot/&#123;parkinglot_id&#125;/space\") private Object selectAllSpace(@PathVariable(name = \"parkinglot_id\") Integer parkinglot_id, @RequestParam(name = \"parking_space_id\",required = false) Integer parking_space_id )&#123; ParkingSpaceExample example = new ParkingSpaceExample(); if(parking_space_id!=null)&#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id) .andIdEqualTo(parking_space_id); &#125; else &#123; example.createCriteria() .andParkinglotIdEqualTo(parkinglot_id); &#125; List&lt;ParkingSpace&gt; parkingSpaces = parkingSpaceMapper.selectByExample(example); return parkingSpaces; &#125; 如果请求时携带了parking_space_id参数，就只查询车位id等于parking_space_id的那条车位记录，否则，查询该停车场的全部车位记录。请求参数携带车位标识和不携带车位标识这两种请求应用场景分别是：加载页面时，需要查询全部车位的车位状态，而用户点击地图的某个车位图标时，只需要查询这一个车位状态。 当不携带车位标识时，某次请求响应的部分json数据如下图展示。 image-20200410104637275 至此，我们就完成了车位数据表的建立和查询。 3. 将地图显示和数据库“绑定”这一步我们就完成可视化的任务，具体需要完成的功能有两个：功能一是加载车位详情页面的时候，查询车位数据表，根据车位状态为地图的车位图标“上色”（空位占用则红，车位空闲则为绿）；功能二是当用户点击车位图标时，查询数据库该车位的当前状态并显示出来（如果车位占用还会显示出当前的车牌号）。 有了步骤1、2的基础后，这一步就很简单了，简单地说，就是用步骤2的数据填充到步骤1的方法内。具体做法是在javascript脚本中使用ajax请求获取后端的车位数据，然后对这些数据按指定格式处理，作为调用Esmap sdk的配置参数。 以功能一的实现为例： 使用ajax向步骤2中编写好的用于查询车位的api接口发送请求，获得请求后的json数据后，遍历每条数据（对应车位数据表的一条记录），根据数据的inUse属性的取值来标识车位是占用还是空闲状态，然后拼接“车位”二字到数据的id属性的取值，就获得了这条记录对应在地图上车位图标对象的name属性（也就是说，数据库中的车位id为1001的车位记录对应地图上name=”车位1001”的地图对象)。设置js数组inUseNameList和notInUseNameList，它们分别是全部占用车位对应的地图车位图标的name属性数组、全部空闲车位对应的地图车位图标的name属性数组。调用 map.changeModelColor()方法设置地图车位图标的颜色时，指定name参数为inUseNameList，颜色设置成红色，指定name参数为notInUseNameList，颜色设置成绿色。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 完成功能一：当地图加载完成时，设置停车位的颜色 */function loadSpace() &#123; var inUseNameList = new Array(); //全部的占用车位对应的地图车位图标的name属性数组 var notInUseNameList = new Array(); //全部的空闲车位对应的地图车位图标的name属性数组 var pathname = window.location.pathname; var parkinglot_id = pathname.charAt(pathname.length-1); console.log(pathname); $.ajax(&#123; //使用ajax请求数据 method: \"POST\", url: \"/parkinglot/\"+parkinglot_id+\"/space\", &#125;) .done(function( spaceList ) &#123; // console.log(spaceList); //打印全部车位信息 $.each(spaceList,function(i,space)&#123; var spaceName = \"车位\"+space.id; if(space.inUse==1)&#123; //表示车位被使用了 inUseNameList.push(spaceName); &#125;else &#123; notInUseNameList.push(spaceName); &#125; &#125;); map.changeModelColor(&#123; //占用车位设置成绿色 name: inUseNameList, color: '#FF0000'&#125; ); map.changeModelColor(&#123; //空闲车位设置成绿色 name: notInUseNameList, color: '#00FF00'&#125; ); &#125;);&#125;","tags":[{"name":"项目","slug":"项目","permalink":"http://hfq123.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://hfq123.github.io/tags/JavaWeb/"}]},{"title":"《Head-First-设计模式》读书笔记charpter2","date":"2020-04-06T14:26:09.000Z","path":"2020/04/06/《Head-First-设计模式》读书笔记charpter2/","text":"本篇博客是《Head First 设计模式》第二章的读书笔记。 分享主题是设计模式中的 「观察者模式(Observer Pattern)」。 1、应用场景—气象监测应用书中给出的例子是：公司要建立一个气象监测应用，如下图，WeatherData对象会从气象检测站获取实时更新的气象数据（湿度、温度、气压），WeatherData对象要做的就是将这些数据及时“分发”到多个布告板，使得每个布告板能使用最新的气象数据以更新它的显示情况。除此之外，附加的需求是系统必须可扩展，能够让用户随心所欲地添加或删除布告板，也就是说，目前系统有“目前状况”、“气象统计”、“天气预报”三个布告板，以后可能会删除某个或者新增别的布告板，言外之意就是说，WeatherData对象要随时准备好停止向现有的布告板分发最新数据以及随时准备好向新的布告板分发最新数据。 image-20200406223021520 2 实现思路2.1 错误示范我们先来看一个很容易想到的思路，然而这被书中称之为“错误示范”（这也是我学习观察者模式之前的思路）。首先我们先约定：一旦气象站测量的气象数据更新，WeatherData类的measurementsChanged()方法就会被调用，在本文，我们不用关心它是怎么做的，只要知道在此方法下，我们要做的就是将这些数据及时“分发”到多个布告板类。 接下来我们就一起来看看这个简单自然但是错误的示例吧，如下图，在WeatherData类的中measurementsChanged()方法里，做的事情很简单，就是获得最新的气象数据，然后以此作为参数各个布告板类的更新方法。 image-20200406223736428 看似完全能实现我们的需求：当气象站检测到新的数据，measurementsChanged()被调用：获得最新的气象数据，然后分别调用各个不同的布告板的update()方法（在这个方法里，布告板会根据自己的需求使用最新数据来改变显示板，我们无需关注update()方法里究竟做了什么，只要知道它需要获得WeatherData类的最新气象数据，供它们更新自己的数据以改变显示屏）。 这样实现究竟有哪些错误呢？ 各个布告板类之间是独立的，没有一个共同的接口，是典型的“针对实现而非针对接口编程”的错误。 每当添加或删除新的布告板，我们都不得不修改方法体内的代码。比如说设计了一个新的testDisplay布告板，我们就要加上一行testDisplay.update(temp,humdity,pressure)，当testDisplay不再需要获取最新的气象状态，就要删除这行代码。 也正是因为每当添加或删除新的布告板，我们都不得不修改方法体内的代码，所以我们无法在运行时动态地增加或者删除布告板。 2.2 观察者模式引入观察者模式就能解决上述实现带来的问题。 先简单介绍一下什么是观察者模式，在观察者模式中，有两个主角，分别是主题(Subject)和观察者(Observer)，书上用了“出版者”和“订阅者”来类比观察者模式中的主题和观察者。出版者一旦出版新的报纸，他就要负责将新报纸分发到各个订阅者手中，而那些没有订阅报纸的人就不会收到，就和这里的例子一样，WeatherData类一旦获得新的气象数据，就要负责分发到各个布告板类中。观察者模式的概念是：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 借助下图，能够让我们清楚地看到观察者模式的“一对多依赖”。 image-20200406230651346 观察者模式为主题和观察者都创建了各自的接口。在主题接口中，定义了注册观察者(registerObserver)方法、撤销观察者(removeObserver)方法、更新所有观察者状态方法（notifyObservers,一旦主题状态改变会触发）；在观察者接口中，定义了更新观察者状态的方法(update)。 image-20200407002547510 我们再把目光转移到应用场景，前面我们已经分析了思路1实现带来的问题，接下来就要好好考虑怎么解决： 首先，我们可以考虑需要为所有布告板类创建一个观察者接口，因为在WeatherData类中，WeatherData不关心布告板是叫currentConditionDisplay还是叫statisticsDisplay，只关心它是否需要在气象数据更新时获得自己的最新气象数据，如果它实现了观察者接口并且注册了主题（相当于订报人完成了订阅动作），那么当WeatherData类的数据更新时，它就是分发数据的目标之一。 然后，我们可以在WeatherData类中维护一个所有观察者组成的列表，这样做能让WeatherData类轻松地获取所有观察者（布告板）。有了观察者列表之后，每当WeatherData类的数据更新，就遍历列表内的所有布告板，调用它们的update()方法即可，WeatherData类不用再关注有几个观察者布告板，它们叫什么名字。当需要添加或删除新的布告板的时候，只需要对列表做增删操作，而不用像思路1中那样改动measurementsChanged()方法体内的代码，同时，这也解决了不能运行时动态地增删布告板的问题，因为运行时可以动态的修改列表的元素（比如说系统运行了十分钟后将currentConditionDisplay公告板从观察者列表中移除）。 想到这些，引入观察者模式之后的模型就呼之欲出了。引入观察者模式之后，本气象站应用的的类图就如下图所示，WeatherData和各布告板分别实现主题接口和观察者接口。 image-20200407002514351 接下来我们从代码的层面上来考虑一下主题的方法是如何实现的。 registerObserver(Observer o)：将观察者对象o加入到WeatherData维护的观察者列表。 removeObserver(Observer o)：将观察者对象o从WeatherData维护的观察者列表中删除。 notifyObservers():遍历WeatherData维护的观察者列表，在循环体内调用每个观察者对象的update()方法。 对比思路1和思路2，可以发现，通过引入观察者模式，我们不仅能方便地实现布告板的增删：当有了新的布告板对象o要“监听”WeatherData的最新数据，就调用registerObserver(o)，当它不再需要获取最新气象数据，就调用removeObserver(o)，还能在运行时动态地增删布告板：，比如说为布告板对象o设置一个“监听”时间10分钟，在10分钟内，它需要监听主题的状态变化，10分钟以后，它就不需要再监听，那么就可以通过在到达10分钟的时候调用removeObserver(o)将其从观察者列表移除即可。 3、总结与思考从观察者模式的两个主角来看，主题拥有自己的一些状态(参考例子中WeatherData对象的天气数据)，而多个观察者想要获知这些状态来改变自身的状态，从而构成了一对多依赖。主题向全体观察者通知，观察者可以随时决定取消监听主题。 如果我们仔细体会本例中一下思路1到思路2的转变，会发现实现了一个松耦合的过程，在思路1中，主题需要关注观察者是谁，而引入观察者模式后，主题不需要知道观察者的具体类是谁，只知道观察者实现了某个接口，有新的观察者出现时，主题的代码不需要修改，二者并非紧耦合。改变主题或观察者其中一方，不会影响另外一方。 最后，本文以一条设计原则结尾。为了交互对象之间的松耦合设计而努力。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":":20200406算法题2则","date":"2020-04-06T14:21:31.000Z","path":"2020/04/06/20200406算法题2则/","text":"今天在牛客网刷了两道剑指offer关于二叉树的题，都比较简单，都可用分治法的思路解决。 题1：二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 我的解答12345678910public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); int max=leftDepth&gt;rightDepth?leftDepth:rightDepth; return max+1; &#125;&#125; 解析：略 题2：二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 &#x2F; \\ 6 10 &#x2F; \\ &#x2F; \\ 5 7 9 11 镜像二叉树 8 &#x2F; \\ 10 6 &#x2F; \\ &#x2F; \\ 11 9 7 5 我的解答：1234567891011public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 解析：这里需要注意必须交换左子树根节点和右子树根节点的引用而非交换取值。","tags":[{"name":"算法刷题","slug":"算法刷题","permalink":"http://hfq123.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"}]},{"title":"《Head First 设计模式》读书笔记charpter1","date":"2020-04-05T07:10:41.000Z","path":"2020/04/05/《Head-First-设计模式》读书笔记charpter1/","text":"本篇博客是《Head First 设计模式》第一章的读书笔记。 分享主题是设计模式中的 「策略模式(Strategy Pattern)」。 1、应用场景—一群鸭子引发的故事。书中给了这样一个例子作为应用场景引入：某公司有一套模拟鸭子游戏，游戏中会出现各种各样的鸭子，这些鸭子有一些动作：呱呱叫、戏水。按照面向对象的思想，系统设计为鸭子这一对象设计了一个名为Duck的超类，在这个类中，为实现动作呱呱叫、戏水分别设置了quack()、swim()方法，而各种不同种类的鸭子通过继承这一超类获得这些描述鸭子动作的方法。 接下来问题来了，系统引入了一个新的需求：让鸭子飞起来。开发人员需要为鸭子类加入描述飞行动作的方法，书中也是以实现此需求展开来引入策略模式的。 2、解决思路—继承还是接口 ？2.1 通过继承实现首先,我们很自然地想到，可以在超类Duck中加入一个fly()方法（就像quack()、swim()方法一样），子类通过继承获取描述鸭子飞的方法。 分析： 因为所有子类都会继承超类Duck的方法，即使是一些不能飞的鸭子如橡胶鸭也会继承fly()方法，这样做我们不得不在子类橡胶鸭中重写fly()方法以覆盖继承的方法，比如说，将其子类中不会飞的鸭子的fly()方法体修改成什么都不做。同理，如果有不会叫的鸭子，又需要在该子类中重写quack()方法。 评价：这种思路是最容易想到的,主要利用了面向对象的继承、多态（体现在重写方法）特性。在代码重用上有一定效果，因为子类可以重用父类的fly()方法，但是也存在了一些缺点： (ps:这四个缺点是书中的一道多选题，只给出了答案，具体解读为自己的想法，如有不对，欢迎指正)。 代码在多个子类中重复：假设鸭子有多种飞行方式，那么我们无法仅通过继承超类的fly()方法来描述所有鸭子的飞行方式。我们必须为所有与超类中fly()实现的飞行方式不一致的鸭子子类编写fly()的覆盖方法，而具有相同的飞行方式但不同于超类中fly()给出的飞行方式的众多鸭子子类的覆盖方法将会是一样的，导致代码重复。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们需要看完Duck超类的fly()方法和全部的鸭子子类覆盖的fly()方法才能知道鸭子全部的飞行方式。 运行时的行为不容易改变：通过继承实现，每一个特定的Duck对象的飞行方式都是确定的，这是因为在它的 fly()方法是写死的，每个Duck对象的飞行方式已经在其创建的时候确定了，也就是说，鸭子不能中途切换飞行方式。 改变会牵一发而动全身，造成其他鸭子不想要的改变：这是指如果修改了超类的fly()方法，会影响到其子类。 下文可以看到，通过使用策略模式能有效解决这些问题。 2.2 通过接口实现上面的解读以fly()举例，其实其他方法也可能存在类似的问题，比如说如果不同类的鸭子叫法不同，继承的quark()方法也会存在上述问题，有的鸭子这样飞、叫，有的鸭子那样飞、叫，有的鸭子不飞不叫。这时，我们就想到了将fly()、quark()从超类中取出来放进一个接口。如下图，以fly()为例，将其放进一个名为Flyable的接口。 image文件夹 *分析 *：这样一来，如果一个鸭子子类会飞则实现Flyable接口，将其fly()方法写到子类的方法体，如果不会飞则无需实现。 评价：从超类中分离出有些子类不需要的fly()、quack()方法，这样避免了部分子类继承它压根不需要的方法的情况。然而这样做的缺点也很明显，每次编写一个会飞的新的鸭子子类，都必须在子类中单独实现fly()方法（即使有和它飞行方式一样的其他子类），导致代码根本无法重用，所以这种方法非常不可取。 2.3 策略模式如何弥补思路1、2的缺陷，这就需要引入策略模式这一设计模式，讲策略模式之前，先引入2条设计原则。 设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 在本案例中，我们假设容易变化的方法是fly()和quack()，而每个鸭子的游泳方式是一样的，即swim()方法是不需要变化的。所以设法将fly()和quack()方法从超类中抽取出来建立一组新的结构来代表每个行为，而swim()方法继续保留在Duck超类中。 设计原则2：针对接口编程，而不是针对实现编程。 我们可以利用接口代表每个行为，比如说，引入接口FlyBehavior与QuackBehavior分别代表了飞行、呱呱叫的行为，通过实现FlyBehavior接口的fly()方法，建立各种各样飞行的行为类，来描述不同飞行方式。与思路2通过接口实现的区别在于，我们不再是直接在Duck或者是它的子类中实现不同的fly()方法，而是再另外引入一个实现了FlyBehavior接口的行为类来实现fly()方法。本系统中，每个飞行的行为类都实现了FlyBehavior接口，而在Duck类中，我们定义一个FlyBehavior接口型的成员变量，来保存其对应的行为类的指针，以调用其飞行方法。 image-20200406005221237 这样做就是策略模式的思路。使用策略模式后，本系统的全局类图如下图展示， 不变的方法swim()仍然在Duck超类中实现，而经常改变的fly()、quack()方法被抽离成为接口，再用具体的行为类去实现这些接口，在Duck超类中，保存对应的行为类一个对象的指针以确定该类鸭子的对应的fly、quack行为。 image-20200406003932396 为什么说引入了策略模式会解决上述继承的四个问题呢？ 代码在多个子类中重复：如果使用继承，如果鸭子的飞行方式与超类中给定的的不一致，即使是有同样飞行方式的鸭子子类，也不能重用代码，因为它们都要在各自的类里重写fly()方法。而引入策略模式后，只需要为有同样飞行方式的鸭子子类编写一个实现了FlyBehavior的行为类。 很难知道所有鸭子的全部行为：如果鸭子有多种飞行方式，我们只需要关注实现了FlyBehavior接口的所有类的fly()方法就能知道鸭子的全部行为。 运行时的行为不容易改变：通过改变Duck或其子类对象的行为类的指针，就可以实现运行时切换飞行方式，也就是说，在Duck类中创建一个setFlyBehavior()方法，就可以随时改变鸭子的行为。 改变会牵一发而动全身，造成其他鸭子不想要的改变：如果某种鸭子的飞行方式有所改变，只需要改变其行为类的引用，不影响其他鸭子子类。 3、总结与思考 image-20200406014158325 是时候给出策略模式的概念了（像本文一样，书中在本章节的最后才给出其概念，也就是讲完了所有细节再告诉你你已经不知不觉地学会了策略模式，我个人觉得这种学习方法比较适合人认识新事物的规律，否则，如果开头就先抛出这个晦涩的概念就能把人吓跑了！）： 策略（Strategy）模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 本项目中，我们可以把鸭子飞行的方式看作是策略，描述不同鸭子飞行方式的代码就构成了策略的算法族。之所以说策略模式让使“算法的变化独立于使用算法的客户”，是因为使用策略模式可以方便地更改客户正在使用的策略（通过更改Context类中对策略的引用）。如果认为使用思路1的继承方法，不厌其烦地在子类中编写fly()的覆盖方法、多写上几行重复代码是可以接受的话，那么，能够随时方便地为类替换策略这个优点就是你无法拒绝策略模式的理由。 这里也就引出了组合和继承(有一个VS是一个)的关系：使用策略模式之后 ，在Duck的子类中通过FlyBehavior、QuickBehavior接口间接地组合了飞行、呱呱叫的行为类，这是“有一个”的关系，理解成Duck的某个子类“有一个“飞行策略。而如果使用继承，则是”是一个“的关系，Duck的子类继承了父类的fly()方法或者重写后获得了自己的fly()方法，不能做到在运行时候动态地改变行为。在使用策略模式后，策略是以”行为类“的方式存在的，而如果使用继承，策略是以方法的形式写死在类里。使用策略模式后，当类的策略在运行时需要发生改变，只需要改变”有一个“的状态，由有一个策略A变成一个策略B，只需要修改其接口的引用（就像修改任何一个普通成员变量一样）。而如果使用继承，想要修改某个鸭子的飞行方式，需要通过修改其fly()方法的代码，当然也就做不到动态地完成改变行为了。综上对组合和继承的讲述，引出了一条新的设计原则： 设计原则3：多用组合，少用继承。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://hfq123.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://hfq123.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"我的第一篇博客","date":"2020-04-04T13:03:27.000Z","path":"2020/04/04/我的第一篇博客/","text":"引言我正在尝试使用Hexo搭建博客,其实早就有搭建博客的想法 ,然而一直没有去实现,今天刚做完一个SpringBoot项目。闲着无事心血来潮就开始了,完工后才发现原来搭建一个自己的博客这么简单且高效，有点相见恨晚的感觉。这第一篇博客就来简单记录一下我本次搭建博客的路线，以作纪念。以后我会更多地在此分享自己的学习内容，记录开发遇到的问题。 搭建环境本次博客搭建使用到的工具有 Hexo + Github。 Hexo是一个博客框架，让我们从渲染前端页面、部署JavaWeb开发环境中解脱出来，把更多的精力放在写博客这件事情本身上，如其官网介绍： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo的灵活性体现在其大部分前端显示内容都是通过参数来配置的，包括整个博客的主题、模板都可通过配置完成（下文会讲搭建好博客后如何更换主题）。 1586022290377 Github大家都比较熟悉，这里主要用到了它的Github Pages的功能来提供远端访问的支持，不使用Github，只使用Hexo工具也能搭建博客，不过只能在本地端口访问。 搭建步骤1 、安装Hexo 2、关联Github的库 3、更换自己喜欢的博客主题 本打算重做以详细记录一下这几个步骤，但是想想这次部署之后以后也没有必要重新部署了，再加上网上已经有很很详细的教程了，重新做一次对自己提升不大，就不浪费时间，所以直接贴教程：手把手教你用Hexo+Github 搭建属于自己的博客 遇到问题特别要注意在修改配置文件_config.xml中的配置项时的格式，正确格式形如：”属性: 空格 值”，如”title: 然后就的博客”。如果冒号和值之前没有空格隔开执行hexo命令时会报错。 以上就是本篇博客的全部内容了，没什么干货，差不多是简单的流水账，仅是为了纪念第一篇博客，以后争取只写高质量的博客！！！","tags":[{"name":"工具","slug":"工具","permalink":"http://hfq123.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","date":"2020-04-04T12:24:26.585Z","path":"2020/04/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]