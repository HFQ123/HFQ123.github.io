---
title: :20200406算法题2则
date: 2020-04-06 22:21:31
tags: 算法刷题
---

今天在牛客网刷了两道剑指offer关于二叉树的题，都比较简单，都可用分治法的思路解决。





## 题1：[二叉树的深度](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

### 题目描述

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。


### 我的解答
```java
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root==null)
            return 0;
        int leftDepth = TreeDepth(root.left);
        int rightDepth = TreeDepth(root.right);
        int max=leftDepth>rightDepth?leftDepth:rightDepth;
        return max+1;
    }
}
```



解析：略





## 题2：[二叉树的镜像](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

### 题目描述

操作给定的二叉树，将其变换为源二叉树的镜像。

### 输入描述:

```
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
```



### 我的解答：

```java
public class Solution {
    public void Mirror(TreeNode root) {
      if(root==null)
          return;
      TreeNode temp = root.left;
      root.left = root.right;
      root.right = temp;
      Mirror(root.left);
      Mirror(root.right);
    }
}
```

解析：这里需要注意必须交换左子树根节点和右子树根节点的引用而非交换取值。

