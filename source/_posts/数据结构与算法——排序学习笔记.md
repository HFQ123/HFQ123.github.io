---
title: 数据结构与算法——排序学习笔记
date: 2020-05-24 10:55:31
tags: 算法
---

本篇博客是记录我学习十大排序算法的学习笔记。

每种排序算法的介绍都从**排序思路、实例计算、代码实现、算法分析**几个角度展开，请注意本文提到的排序全都默认是升序排序。



## 冒泡排序（Bubble Sort）

### 排序思路

每一轮冒泡过程依次比较每两个相邻的元素，将值大的元素交换到右边，经过一轮冒泡过程后，最大的元素就被交换到了最后一位，进行下一轮冒泡过程时，忽略上一轮最后一位的元素，循环直到所有元素有序（也就是经过了n-1轮冒泡）。

### 实例计算

下图给出了使用冒泡排序对数组{3，2，4，1}进行排序的过程。

![冒泡排序的实例计算过程](/images/image-20200524113440074.png)

以上图的第一轮冒泡为例讲解详细冒泡过程：首先进行比较①：比较3和2，发现3比2大，所以交换，数组变成2，3，4，1；然后进行比较②，注意此时第二个元素已经变成3了，所以这里比较②比较的是3和4，发现3比4小，所以无需交换，数组仍然是2，3，4，1；然后进行比较③，发现4比1大，所以交换，数组变成了2，3，1，4。

经过第一轮排序后，数组中最大的元素放到了数组的末尾，所以第二次冒泡不用再考虑这个元素。也就是说，第二次冒泡的只需要进行两次比较了，以此类推。

### 代码实现

```java
    /**
     * 冒泡排序的实现
     * @param array 需要升序排序的整型数组
     */
    public static void bubbleSort(Integer[] array) {
        for (int end = array.length - 1; end > 0; end--) {
            for (int begin = 1; begin <= end; begin++) {
                //这相邻的两个元素中，如果前面的元素比后面的元素大，交换
                if (array[begin] < array[begin - 1]) {
                    swap(array, begin, begin - 1);
                }
            }
        }
    }
```

### 算法分析

时间复杂度：O(n^2)。

针对冒泡排序还有一种针对最后一些元素局部有序的优化思路，如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数，这里不展开了。

空间复杂度：O(1)

稳定性: 稳定





## 选择排序（Selection Sort）

### 排序思路

每轮选择遍历数组中的未排序部分选出最大的数，与数组中最后一个未排序的元素交换位置，如此一来，没经过一轮选择，最大的数字就被交换到了未排序元素的最后，这个元素就可以被认为是有序的了，下一轮选择时忽略这个已排序的数字，循环直到所有元素有序（也就是经过了n-1轮选择）。

### 实例计算

下图给出了使用选择排序对数组{3，2，4，1}进行排序的过程。

![选择排序的实例计算过程](/images/image-20200524114253609.png)

以上图第一轮选择为例：遍历发现4是最大的元素，就交换元素4和末尾元素1的位置，得到3，2，1，4。



### 代码实现

```java
    /**
     * 选择排序的实现
     *
     * @param array 需要升序排序的整型数组
     */
    public static void selectionSort(Integer[] array) {
        //end记录当前数组中未排序部分的最后一个元素的下标
        for (int end = array.length - 1; end > 0; end--) {
            //记录这一轮选择中的最大元素的下标
            int indexOfMax = 0;
            for (int i = 1; i <= end; i++) {
                if (array[i] > array[indexOfMax]) {
                    indexOfMax = i;
                }
                swap(array, indexOfMax, end);
            }
        }
    }

```



### 算法分析

时间复杂度：O（n^2），选择排序的流程和冒泡排序的流程类似，都是每经过一轮，可以获得数组中当前未排序部分的最大元素，但是可以看到，选择排序的交换(swap)次数远小于冒泡排序的交换次数，所以平均性能会更好一点。

空间复杂度：O（1）

稳定性： **不稳定**。

需要注意选择排序是不稳定的！比如说数组是： 3a ,2a,2b,3b。按照上面选择排序的代码来执行， 经过第一轮选择后变成了：3b,2a,2b,3a,而经过第一轮选择后，3a就固定在了最后一位，也就是说3a的位置本来在3b的前面，经过排序后，位置变成了在3b的后面，所以说这种排序算法是不稳定的。

探究其原因，这是因为当前最大值初始是3a（indexOfMax=0），即使后面遇到了3b，因为不满足array[i] > array[indexOfMax]条件，最大值依旧被认为是3a而不是3b。这时候你可能会想到，把代码中的判断条件改成 array[i] > =array[indexOfMax]，如此一来，第一轮选择的结果就变成了：3a,2a,2b,3b，这样的话3a和3b的相对顺序就不会被破坏,但是别着急下结论，以此类推， 第二轮选择的结果是：2b,2a,3a,3b,第三轮的选择是：2b,2a,3a,3b。选择排序结束，可以看到2b和2a的相对顺序发生了改变，也就是说，即使判断条件改了，还是可能不稳定！



## 堆排序 (Heap Sort)

### 排序思路

其实堆排序的思路和选择排序的思路类似：也是想办法先从数组中未排序部分找出最大值，然后放到数组的末尾，只不过找未排序部分中的最大值的策略不一样：选择排序中，由于未排序部分没有什么特殊的性质，只能直接通过遍历一遍，来找到最大值，显然这一过程的时间复杂度是O(n)，而在堆排序中巧妙地用到了最大堆的特性，把数组中未排序部分建成一个最大堆，这样找最大元素值的复杂度就变成了O（1）（不过为维持最大堆的特性就需要额外的O(logn)开销）。

如果对最大堆的含义和性质、建立过程还不清楚的话，可以参考我的这篇博客： [数据结构与算法—二叉堆学习笔记]([https://hfq123.github.io/2020/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%80%BB%E7%BB%93](https://hfq123.github.io/2020/05/22/数据结构与算法—二叉堆学习笔记/#总结))。

总体来说，堆排序的排序流程是这样的：

+ 第一步：对需要排序的数组原地建最大堆(heapify操作)。

  这一步可以通过自下而上（从最后一个非叶子结点开始递减至根节点）的下沉操作完成，时间复杂度是O(n)。

+ 第二步：开始进行**选择未排序部分中的最大元素操作，并交换到未排序部分的最后**，循环下面三步操作直到堆的大小减小为1。

  + 2.1 交换堆顶元素和堆中的最后一个元素。
  + 2.2 堆的大小减小1，也就是说，上一步操作被放到最后的元素被排除在堆外。
  + 2.3 对现在的堆顶元素（也就是空降上来的、2.1步中的最后一个元素）进行sinkDown下沉操作。

  可以看到，每进行一轮第二步的操作（2.1、2.2、2.3），就会选出未排序部分中的最大值放到未排序数组的末尾，这样一来最后一个元素就成为有序的了，这也是为什么堆的size减小的原因，因为最大堆只维护未经排序的部分。

### 实例计算

下图给出了使用堆排序对数组{3，2，4，1}进行排序的过程。

![堆排序的实例计算过程](/images/image-20200524134559695.png)

注意：图上红色结点是已经不属于当前堆的结点，因为它们已经是排序了的，而堆中只会保留当前所有未被排序的部分。

## 代码实现

这里给出了堆排序要用到的的核心方法：siftDown下沉操作，在堆排序的第一步建堆和第二步排序中都会用到。

```java
   /** 堆排序的实现
     * @param array 要排序的整型数组
     */
    public static void heapSort(Integer array[]) {

        //堆排序的第一步：在array数组上原地建堆
        heapify(array);
        //记录当前未排序部分构成的堆的大小，初始大小为待排序数组的长度
        int heapSize = array.length;
        //堆排序的第二步:
        while (heapSize > 1) {
            swap(array, 0, heapSize - 1);
            heapSize--;
            siftDown(array, heapSize, 0);
        }
        
    }


	/** 最大堆的下沉操作
     * @param heap  存储最大堆的数组
     * @param size  当前最大堆的大小
     * @param index 要下沉的结点在数组中的下标
     */
    public static void siftDown(Integer[] heap, int size, int index) {
        //2*i+1<size说明
        int leftChildIndex = 2 * index + 1;
        //记录index结点的左右孩子中较大的孩子的下标
        int bigChildIndex;
        while (leftChildIndex < size) {
            //大孩子下标默认为左孩子下标
            bigChildIndex = leftChildIndex;
            //如果右孩子存在且右孩子的值大于左孩子
            if (leftChildIndex + 1 < size && heap[leftChildIndex + 1] > heap[leftChildIndex]) {
                bigChildIndex = leftChildIndex + 1;
            }
            //然后当前结点和大孩子进行比较,如果小于大孩子需要交换
            if (heap[index] >= heap[bigChildIndex]) {
                break;
            }
            swap(heap, index, bigChildIndex);
            index = bigChildIndex;
            leftChildIndex = 2 * index + 1;
        }
    }

    /**把一个任意整型数组建成最大堆（利用数次下沉操作）
     * @param array 要被建立成最大堆的整型数组
     */
    public static void heapify(Integer[] array) {
        //从最后一个非叶子结点开始下沉操作
        for (int i = array.length / 2; i >= 0; i--) {
            //array表示堆存储的数组，array.length表示堆的大小
            siftDown(array, array.length, i);
        }
    }

```

## 算法分析

时间复杂度：第一步通过自下而上的下沉的建堆过程的时间复杂度是O(n)，而第二步每一轮（2.1、2.2、2.3的三个操作）时间复杂度是O(logn)，第二部会循环次数约为n次（实际上是n-1次，每次选个未排序中的最大元素使其有序），所以堆排序第二步的时间复杂度是n*O(logn)。所以总的来说，时间复杂度是O(n)+nO(logn)。

综上所述，**堆排序最好最坏时间都是复杂度：nO(logn)**，说的更精确一点就是O(n)+nO(logn)。

空间复杂度：O(1)

稳定性：不稳定。 10a,10b会被排序成10b，10a。

