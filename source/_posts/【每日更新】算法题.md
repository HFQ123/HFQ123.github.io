---
title: 【每日更新】算法题
date: 2020-04-21 20:17:21
tags: [算法刷题,剑指Offer]
---
# 20200428 晴

## [题1]()

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
/**
 * @Created by hfq on 2020/4/28
 * @used to: 字符串的排列-递归解法  https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7
 */
public class LeetCode {
    public static ArrayList<String> Permutation(String str) {
        if(str == null ||str.length()==0){
            return  new ArrayList<>();
        }
        //为 str 排序,这步操作只需要进行一次（因为str排好序后其子串必定是有序的），所以无需放在递归里
        char [] chars = str.toCharArray();
        Arrays.sort(chars);
        return f(String.valueOf(chars));
    }

    //f(str) 即求f(str)的所有排列，如果要按照字典序打印，前提是str必须是有序的
    public static ArrayList <String> f(String str){
        if(str==null){
            ArrayList <String> list = new ArrayList<>();
            list.add("");
            return list;
        }
        if(str.length()==0){
            ArrayList <String> list = new ArrayList<>();
            list.add("");
            return list;
        }
        char [] chars = str.toCharArray();
        str = String.valueOf(chars);

        ArrayList <String> list = new ArrayList<>();
        HashSet <Character> set= new HashSet();
        for(int i = 0; i<chars.length; i++){  //这个字符的下标是i
            boolean success = set.add(chars[i]);
            if(success){
                ArrayList <String> subs = f(str.substring(0,i)+str.substring(i+1)); //subs存放剔除该字符后的全排列结果
                    for(String sub : subs){
                        list.add(chars[i] + sub);
                    }
            }
        }
        return list;
    }

    public static void main(String[] args) {
        ArrayList<String> list = Permutation("cab");
        System.out.println(list);
    }
}
```





# 20200427 晴

## 题1 [按之字形顺序打印二叉树](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0)

### 思路

这题和昨天做的”[把二叉树打印成多行](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288)“很像。都是用层序遍历的思路，区别就在于当访问行数是偶数，要将该行元素的ArrayList反转。

### 细节

+ Collections.reverse(arrayList); import java.util.Collections;
+ arrayList.add() ,queue.offer()。一开始没注意写了arrayList.offer()报错了

```java
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;
import java.util.Collections;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if(pRoot == null){
            return   new ArrayList<>();          
        }
        ArrayList<ArrayList<Integer> > rows = new ArrayList<>();
        Queue <TreeNode> queue = new LinkedList<>();
        queue.offer(pRoot);
        ArrayList<Integer> row = new ArrayList<>();
        int nextLevelNum = 1; //记录还要访问几个元素可以到下一层，即每层元素的个数，初始化是1
        boolean needReverse = false; //记录当前行是否需要反转
        while(!queue.isEmpty()){
            //队首节点出队列
            TreeNode node = queue.poll();
            //将节点值加入row
            row.add(node.val);
            if(node.left!=null){
                queue.offer(node.left);
            }
            if(node.right!=null){
                queue.offer(node.right);
            }
            nextLevelNum--;
            if(nextLevelNum == 0){//说明该层访问完了
                if(needReverse){
                    Collections.reverse(row);
                }
                rows.add(row);
                row = new ArrayList<>();
                //重新设定nextLevelNum和needReverse
                nextLevelNum = queue.size();
                needReverse = !needReverse;
            }
           
        }
        return rows;

    }

}
```



## 题2 [平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222)

### 思路

我的思路就是根据平衡二叉树的定义解决：一棵树是平衡二叉树，则其左右子树高度差不大于1且左右子树都是平衡二叉树。这种做法是最直观的，但是效率一般（不过也能AC）。

### 代码

```代码
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null)
            return true;
        int balanceFactor = treeHeight(root.left) - treeHeight(root.right);
        return Math.abs(balanceFactor) <= 1 && IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
    }
    public int treeHeight(TreeNode node){
        if(node == null)
            return 0;
        int leftHeight = treeHeight(node.left);
        int rightHeight =  treeHeight(node.right);
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```

### 分析

在计算每个节点的深度的时候，进行了多次的重复计算，这样计算的开销还是比较大的。（类比递归求斐波那契数列的重复计算）

又注意到实际上在计算树高时（上面的treeHeight方法）就要计算左右子树高度，这时候就可以判断是否平衡。

### 改进

参考了[博客](https://blog.csdn.net/dawn_after_dark/article/details/81702988)。

核心：**把求树的深度与判断树的平衡融合在一起。**

改进思路就是在计算root高度的同时，就判断是否出现过不平衡的节点，使用一个成员变量isBalance存放结果（作为全局变量），一旦出现了不平衡节点，isBalance被置为false,则可以停止后续的递归计算。这样做效率比原思路好，只要调用一次treeHeight(root)即可。

```java
public class Solution {
    boolean isBalance;
    public boolean IsBalanced_Solution(TreeNode root) {
        //当root=null，返回isBalance=true。
        isBalance = true;  //默认为true
        treeHeight(root);
        return isBalance;
    }
    public int treeHeight(TreeNode node){
        if(node == null || isBalance == false) //如果isBalance已被置为false，可以直接返回，不用再判断了
            return 0;
        int leftHeight = treeHeight(node.left);
        int rightHeight =  treeHeight(node.right);
        if(Math.abs(leftHeight-rightHeight) > 1){  //判断root是否不平衡
            isBalance = false;
        }
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```



## 题3[矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13)

### 思路

其实该模型符合斐波那契数列。

f(n) = f(n-1)+f(n-2)，

n=0的时候

+ 0种

n = 1 的时候

- 只能横着覆盖，一种

n = 2 的时候

- 可以横着和竖着覆盖，两种

n = 3 的时候

- 第三级竖着覆盖，用了一级，剩下 n = 2，有两种覆盖方法
- 第三级横着覆盖，用了两级，剩下 n = 1，有一种覆盖方法
- 总共有 3 种

n = 4 的时候

- 第 4 级竖着覆盖，用了一级，剩下 n = 3，有三种覆盖方法
- 第 4 级横着覆盖，用了两级，剩下 n = 2，有两种覆盖方法
- 总共有 5 种方法

n = n 的时候

- 第 n 级竖着覆盖，用了一级，剩下 n = n - 1，所以关注第 n - 1 种有几种覆盖方法
- 第 n 级横着覆盖，用了两级，剩下 n = n - 2，所以关注第 n - 2 种有几种覆盖方法
- 总和为两种情况的总和

### 代码

```java
public class Solution {
    public int RectCover(int target) {
        if(target == 0){
            return 0;
        }else if(target == 1){
            return 1;
        }else if(target == 2){
            return 2;
        }
        return RectCover(target-1) + RectCover(target-2);
    }
}
```



![第n级竖着放](/images/image-20200427235728192.png)

![第n级横着放](/images/image-20200427235839863.png)

### 改进

递归做会有多次的重复计算，可以考虑空间换时间，动态规划求斐波那契数列。

此处略。



## ## 【待解决】题4[二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8)

### 思路

题目要求是求整数的补码中的1的个数。

我们知道，对于正数，其补码就是原码。如十进制数9的补码=10的原码=0，1001（首位0是符号位）。

而十进制数-9的原码=1，1001（首位1是符号位），其补码是：1，0111

我一开始想的是先算出补码的二进制表示，再计算1的个数，这种效率太低了，要用位运算，这块知识有些忘了，还要再复习一下。



## ## 【待解决】题4 [数组中只出现一次的数字]()

### 思路

位运算。

位运算异或（XOR）的特点：

+ 0 ^ 0 = 0		1 ^ 1 = 0		1 ^ 0 = 1	        0 ^ 1 = 1 

+ a  ^  a = 0 ,因为a的二进制^a的二进制每一位异或结果都是0。
+ a  ^ 0 = a , 因为a的二进制的每一位与0的异或结果都是本身 

+ 结合上述两点，a ^ b ^ a = b



---

# 20200426 晴

## 题1 [把二叉树打印成多行](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288)

## 思路

显然，此题是层序遍历的应用。二叉树的层序遍历很简单，使用队列就能完成，本题要在层序遍历的基础上使用一个变量，来记录下一层的元素个数，每当遍历完了一层，就更新这个值，且换行。

## 提示

+ 题目给的方法返回值是 ArrayList<ArrayList<Integer> > ，一开始没反应过来，后来仔细一想，是每行的元素单独保存在一个ArrayList里，再返回所有行的元素。

```java
import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;


/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if(pRoot==null)
            return new ArrayList <>();
        int nextLevelNum = 1; //记录还要访问几个元素才到下一层,初始值为1,因为第一层肯定只有根节点一个元素
        Queue <TreeNode> queue = new LinkedList<>();
        queue.offer(pRoot);
        ArrayList<ArrayList<Integer>> rows = new ArrayList<>(); 
        ArrayList <Integer> row = new ArrayList<>();
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();//当前队头节点出队列
            row.add(node.val);    //将节点的元素值加入到row列表
            if(node.left!=null){ //并将其非空子节点加入队列
                queue.offer(node.left);
            }
            if(node.right!=null){
                queue.offer(node.right);
            }
            nextLevelNum--;  //每访问完了一个节点，nextLevelNum就减1
            if(nextLevelNum == 0){ //说明这一层已经访问完了，要重新设置它的取值,它的取值其实就是当前队列的元素个数
                nextLevelNum = queue.size();
                rows.add(row);
                row = new ArrayList<>(); 
            }
        }
        return rows;
    
    }
    
}
```

### 细节：

+ 队列操作的API、导入所在包，nextLevelNum这个变量是本题精髓！

+ ```java
      if(pRoot==null)
          return new ArrayList <>();  一开始写的return null，无法通过！
  ```







---



# 20200425 晴

## 题1[复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba)

### 做题前思路

首先要注意要求是复制结点，而不是复制引用。

其次要注意random属性。



## 题2 [序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84)

### 思路

层序遍历。 

在序列化操作的时候，要注意左右子树的空结点也要加入队列。

在反序列化的时候，用一个结点数组保存所有节点（包含左右空节点）。



```java
import java.util.Queue;
import java.util.LinkedList;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    String Serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        Queue <TreeNode> queue = new  LinkedList <>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode currentNode = queue.poll();
            if(currentNode != null){
                sb.append(currentNode.val+",");
                queue.offer(currentNode.left); //不管是否为空都会加入队列
                queue.offer(currentNode.right);
            }else{
                sb.append("#"+",");
            }
        }
        return sb.toString();
        
  }
    TreeNode Deserialize(String str) {
        String [] nodeVals = str.split(",");
        TreeNode [] nodes = new TreeNode[nodeVals.length];
        for(int i = 0; i<nodeVals.length; i++){
            if(!nodeVals[i].equals("#")){
               nodes[i] = new TreeNode(Integer.valueOf(nodeVals[i]));
            }
        }
        int i=1;
        for(TreeNode node : nodes){
            if(node != null){
                node.left=nodes[i++];
                node.right=nodes[i++];
            }
        }
        return nodes[0] ;
       
  }
}
```



## 题3 [数组中重复的数字](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8)

### 思路

HashSet 时间复杂度O(n)  空间复杂度O(n)

参考别人的：重排数组 ：时间复杂度O(n)，空间复杂度O(1)。

```java
public class Solution数组中重复的数字 {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(numbers == null){
            return false;
        }
        HashSet <Integer> set = new HashSet <>();
        for (int i = 0; i<numbers.length ; i++){
            if(!set.contains(numbers[i])){
                set.add(numbers[i]);
            }else{
                duplication[0] = numbers[i];
                return true;
            }
        }
        return false;
    }
}
```





## 【待解决】题4 [数组中的逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5)

### 思路

+ 暴力求解：从第一个元素开始，判断后面比它小的元素的个数  O(n^2)，不出所料，运行超时，通过50%的用例。
+ 【待学习】提示：归并的改进

---





# 20200422

## 题1 [二叉搜索树的第k个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a)

### 做题前思路

给定一棵二叉搜索树，请找出其中的第k小的结点。根据BST中序遍历结果是升序的这一性质，可以中序遍历，直到遍历到第k个结点。

### 按照此思路的代码：

```java
//中序递归，成功AC
public class Solution {
    int num;    //num表示当前中序遍历已经访问了几个元素
    TreeNode node; //node存放结果
    TreeNode KthNode(TreeNode pRoot, int k)
    {
       inorder(pRoot,k);
       return this.node;
    }
    void inorder(TreeNode node,int k){
        if(node==null){
            return;
        }
        inorder(node.left,k);
        num++;
        if(num==k){
            this.node=node;
            return;  //结束后续的访问
        }
        inorder(node.right,k);
    }
}
```

分析：就算找到了Kth结点也会遍历完整个BST。时间复杂度是O(N)

改进：可以考虑非递归实现中序遍历，这样就能在找到Kth结点后结束遍历。





## 【待解决】题2 [字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720)

## 做题前思路

hashmap



## 知识点
+ LinkedHashMap和HashMap的差别
  + LinkedHashMap
  + [Hashmap遍历方法](https://www.cnblogs.com/lykbk/p/dfdfdffd34534343434.html)





## 题3 [统计一个数字在排序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2) 

### 做题前思路

+ 法1：二分查找定位该数字，再找左边和右边相等的元素个数。

+ [多种方法改进参考文章](https://www.cnblogs.com/lishanlei/p/10707678.html)
  + 最后采用的方法：因为数组中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。



```java
/**
 * @Created by hfq on 2020/4/23
 * @used to:
 */
public class Solution数字在排序数组中出现的次数 {
    public int GetNumberOfK(int [] array , int k) {
        return BinarySearch(array,(float)(k+0.5)) - BinarySearch(array,(float)(k-0.5));
    }
    //返回目标t插入array的位置
    public static int BinarySearch(int [] array , float t){
        int i = 0;
        int j = array.length-1;
        int mid = 0;
        while(i<=j){   //<= 等号不可遗漏！！
            mid = j+(i-j)/2;
            if(array[mid] > t){  //在左边查找
                j = mid-1;
            }else if(array[mid] < t){ //在右边查找
                i = mid+1;
            }else{
                //实际上不可能发生，可以和上面的else if合并
            }
        }
        return i;   //array[mid]在array[i]和array[j]中添加
    }

    public static void main(String[] args) {
//        int [] a = {3,3,3,3};
        int [] a = {3,3,3,3};
        System.out.println(BinarySearch(a, (float) 2.5));
        System.out.println(BinarySearch(a, (float) 3.5));
    }
}
```



分析：这种做法在各种情况下效率都比较高。 

当数组是：[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]，如果采用法1，效率退化成O(n),而这种方法时间复杂度还是O(lgn)级别的

---





# 20200421 

## 题1：[栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106)

### 代码：

```java
import java.util.ArrayList;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA==null||pushA.length==0)
            return true;
        int stack [] = new int[pushA.length];
        int size = 0;
        int pushIndex=0;
        stack[size++] = pushA[pushIndex++];
        int current = 0;
        while(pushIndex<pushA.length)
        {
            if(stack[size-1]!=popA[current])
            {
                stack[size++] = pushA[pushIndex++];
            }else{ 
                size--;
                current++;
            }
        }
        while (size!=0){
            if(stack[size-1]!=popA[current]) {
                return false;
            }
            else {
                size--;
                current++;
            }
        }
        if(size==0)
            return true;
        return false;
    }
}
```

### 解析：

以输入{1,2,3,4,5}，{4,5,3,2,1}为例。

借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。

 我的代码没有用JDK提供的Stack，而是用一个数组+size模拟栈。

## 题2：[二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e)
### 代码
```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        TreeLinkNode successor = null; //表示后续结点，保存返回结果
        //当这个结点有右子树，那么其后续结点必然在其右子树中的最小的元素
        if(pNode.right!=null){
            successor = pNode.right;  
            while(successor.left!=null){
                successor = successor.left;  //一直向左走找最小的元素
            }
        }else if(pNode.next != null){  //没有右子树但是有根节点
            successor = pNode;  
            while(successor.next != null && successor == successor.next.right){
                successor = successor.next; //当此结点始终是其父节点的右子树的时候，逐级找父节点
            }
            successor = successor.next;
        }
        return successor;
    }
}
```

### 解析：

求二叉树某一结点的后续结点。

![image-20200421205013742](/images/image-20200421205013742.png)

根据这个pNode结点的状态，分为三种情况求解:

+ pNode存在右子树，那么其后续结点必然在其右子树中。
  - 这是由中序遍历的定义决定的：若某节点存在右子树，那么访问完这个结点后访问的下一个结点必然是右子树中的某个结点。
  - 返回结果是 pNode.right.left.left.left.... 
+ pNode不存在右子树，但存在父节点，那么其后续结点是其祖父结点，或者是null
+ 既不存在右子树，也不存在父节点，返回null

提示：

+ 可以借助二叉树的一种特殊情况——二叉搜索树思考这题，上述代码的注释就是这样做的，表面看我们考虑的是特殊情况，但是实际上这样做对二叉树具有普遍性。

+ 另外提一下，这道题目有点坑的地方是：包含指向父结点的指针的变量名是next，不是parent，注意一下。



## 【待解决】题3:[顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a)

被这道题虐了很久。。

一直会忽略某些情况。



```java
package com.hfq;

import java.util.ArrayList;
public class Main {
    public static ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList <Integer> list = new ArrayList<>();
        addElementToList(matrix,0,matrix.length-1,0,matrix[0].length-1,list);
        return list;
    }

    public static void addElementToList(int [][] matrix,int rowsMin,int rowsMax,int colsMin,int colsMax,ArrayList list) {
        if(colsMax<0 && rowsMax<0){
            return;
        }

        for(int i = colsMin; i<=colsMax ; i++){ //从左往右
            list.add(matrix[rowsMin][i]);
           // System.out.println(matrix[rowsMin][i]);
        }

        if(rowsMax>rowsMin){
            for(int i = rowsMin+1; i<=rowsMax ; i++){ //从上往下
//            System.out.println("i="+i+",colsMax"+colsMax);
                list.add(matrix[i][colsMax]);
                //System.out.println(matrix[i][colsMax]);
            }
        }

        if(colsMax-1>colsMin){
            for(int i = colsMax-1; i>=colsMin ; i--){  //从右往左
                list.add(matrix[rowsMax][i]);
               // System.out.println(matrix[rowsMax][i]);
            }
        }

        if(colsMax-colsMin>=1 && colsMax > colsMin ){
            for(int i = rowsMax-1; i>=rowsMin+1 ; i--){ //从下往上
                list.add(matrix[i][colsMin]);
              //  System.out.println(matrix[i][colsMin]);
            }
        }
        addElementToList(matrix,rowsMin+1,rowsMax-1,colsMin+1,colsMax-1,list);
    }


    public static void main(String[] args) {
//        int a [][] ={{1},{2},{3},{4},{5}};
//        int a [][] ={{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
        int a [][] ={{1,2},{3,4},{5,6},{7,8},{9,10}};
        ArrayList<Integer> integers = printMatrix(a);
        for(Integer integer:integers){
            System.out.printf(integer+",");
        }
    }

}
```



## 题4:[包含min函数的栈](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49)

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。

### 思路

一开始我的想法很简单，用一个使用一个变量记录当前的最小元素，如果新压入栈的元素更小，就更新它。

但是仔细一想，这种做法有一个问题，假如记录的最小元素出栈了，就没办法以O(1）的时间复杂度获取新的最小元素了，所以在保存最小元素的同时，有必要保存最小元素出栈后次要小的元素，同理，也要保存第三小的元素....

所以，要用一个辅助栈来保存当前的最小元素以及之前的的最小元素，栈顶就是当前栈的最小元素，栈顶元素的下一个元素就是这个元素出栈后的新的最小元素。

+ 每次压栈时，如果压入的元素小于当前最小元素，则也将其压入辅助栈，否则，则将上一个最小元素压入辅助栈。
+ 每次出栈时，弹出元素的同时也弹出辅助栈的元素。



### 知识点复习

Stack的API

+ peek()
+ size()
+ pop()
+ push()

### 代码

```java
import java.util.Stack;

public class Solution {
    public Stack <Integer> stack = new Stack<>();  //数据栈 
    public Stack <Integer> minStack = new Stack<>();; //辅助栈

    public void push(int node) {
        stack.push(node);
        if(stack.size()==1){  //现在是1，说明压栈前是0。
            minStack.push(node);
        }else{
            minStack.push(node<minStack.peek() ? node : minStack.peek());
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

### 题解

关键字 ：最小值辅助栈



## 题5 [把数组排成最小的数](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993)

没啥思路，借鉴了网上的[解法](https://blog.csdn.net/xiaoxingxing1744/article/details/84191277)，觉得很妙。

关键字：自定义比较大小的方法。

### 提示

转成字符串，自定义比较器后排序

### 知识点复习

+ int类型转成String类型
  - String.valueOf(i)
  - Integer.toString(i)
  - i+""

+ 比较字符串大小

+ 拼接字符串 （StringBuilder）

  + sb.append()
  + sb.toString()

+ 代码细节

  - Arrays.sort()

    - import java.util.Arrays;
  - Comparator
  - import java.util.Comparator;

  ```java
  new Comparator<String>() {
      @Override
          public int compare(String str1, String str2) {   //3  12  312 123
          	return 0;
      }
  }
  ```

### 代码

```java
/**
 * https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993
 * @Created by hfq on 2020/4/22
 * @used to:
 * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
 * 打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
 */
public class Solution把数组排成最小的数 {
    public static String PrintMinNumber(int [] numbers) {
        StringBuilder sb = new StringBuilder();
        String numString [] = new String[numbers.length];
        for (int i=0; i<numbers.length; i++){
            numString[i]=String.valueOf(numbers[i]); //将整数转成字符串
        }
        Arrays.sort(numString, new Comparator<String>() {
            @Override
            public int compare(String str1, String str2) {   //3  12  312 123
                return 0;
            }
        });
        for (String str : numString){
            sb.append(str);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        int[]numbers={3,32,321};
        System.out.println(PrintMinNumber(numbers));
    }
}

```



进度：25题/67题。



