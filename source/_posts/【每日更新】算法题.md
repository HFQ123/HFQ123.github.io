---
title: 【每日更新】算法题
date: 2020-04-21 20:17:21
tags: [算法刷题,剑指Offer]
---
# 20200428 晴

## 题1[字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7)

### 提示

记f(str)方法返回一个ArrayList， 即返回字符串str的所有排列。

求f(str)时，确定第一个字符str[i]（for循环），递归调用f(str-str[i])（表示从str字符串中剔除str[i]字符后获得的子串）以获取后面的字符的排列，for循环内部再写一个foreach遍历子串的所有排列情况，拼接后加入ArrayList，返回。

### 思路

{% blockquote %} 

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

{% endblockquote %} 

可以用递归解决。先通过演算示例**“求字符串s=“abc”的所有排列”**，来理解本题中如何使用递归：

分析：“abc”的排列包括了：    ( 结果abc , acb ,bac ,  bca,  cab , cba )

+ a + "bc"的排列                                                                结果：abc , acb										
  + “bc”的排列包括了 b+"c"的排列                                           结果：bc
  + “bc”的排列包括了 c+"b"的排列                                           结果：cb
+ b + "ac"的排列                                                                结果：bac , bca
  + “ac”的排列包括了 a+"c"的排列                                           结果：ac
  + “ac”的排列包括了 c+"a"的排列                                           结果：ca 
+ c + "ab"的排列                                                                 结果： cab , cba
  + “ab”的排列包括了 a+"b"的排列                                          结果： ab
  + “ab”的排列包括了 b+"a"的排列                                          结果： ba



通过上述的分析，可以看到我们**把原问题分解成了若干个**(实际上是s.length()个，如果不考虑重复字符的话，下文会考虑到有重复的情况)**子问题**，通过求解子问题并合并子问题的解，就得到原问题的解，其实采用了**分治法**的思想。

字符串s可以由s[i]和s-s[i]拼接而成，（0<=i<s.length()，其中s[i]表示字符串s中的某个字符，s-s[i]表示字符串s截取掉字符s[i]后生成的字符串）。

如上例“求abc的所有排列”这个原问题的其中一个子问题是**求a + "bc"的排列**，可以理解为：abc排列结果的第一位确定下来是a，**后面2位的排列待定，其实它是长度比原字符串小1的子串**（也就是bc，因为a已经排列在第一位了，所以把已经确定位置的字符a从原字符串abc中剔除，得到bc）**的排列结果**，同理地，求字符串bc这个问题又可以分解成 b+"c"的排列和 c+"b"的排列两个子问题。

我们知道，在分治法的思想中，当子问题规模较大时继续采用递归求解子问题，当子问题规模变小时直接求解，以免持续递归无法终止。在本例中，递归的终止条件就是当求解的子问题的字符串长度为1时，只有其自身一种排列结果，直接返回，无需继续递归。

写代码之前，还需要关注到题目中的两个细节：

+ 排列结果按字典序打印

比如说如果要求字符串"cba"的排列结果，我们可以先对字符串内部的字符排序，变成“abc”，再求结果。

+ 可能有重复字符

比如说要求字符串"aab"的排列结果，按照上述案例的思路分析，如果分解成三个问题：a +"ab"的排列，a+"ab"的排列，b+“aa”的排列，可以发现第一种情况和第二种情况重复了，所以为避免重复，实际上在这只需要分解成两个子问题：a +"ab"的排列，b+“aa”的排列。在编程的时候，用一个HashSet保存第一个字符，来保证不重复。

说了这么多，接下来看看代码怎么写吧。



f(str)=str[0]f(str-)+str[1]f(str-)

str-

### 代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

public class Solution {
    public ArrayList<String> Permutation(String str) {
       if(str == null)
           return new  ArrayList<>();
       char [] chars = str.toCharArray();
       Arrays.sort(chars);
       return f(String.valueOf(chars));
    }
    
    /**此函数用于求字符串str的所有排列
    */
    public ArrayList <String> f(String str){
        ArrayList <String> list = new ArrayList <>();
        if(str.length() == 1){
            list.add(str);
            return list;
        }
        HashSet <Character> set = new HashSet(); 
        for(int i=0; i< str.length();i++){
            boolean success = set.add(str.charAt(i));//表示当前字符是否第一次出现
            if(success){  
                //排列的第一位已确定为str.charAt(i)，递归获得后几位，剔除已确定的第一位的子串的所有排列
                ArrayList <String> subList = f(str.substring(0,i)+str.substring(i+1));
                for(String sub : subList){
                    list.add(str.charAt(i)+sub);
                }
            }
            
        }
        return list;
    }
}
```



### 知识点

+ String和char[]的转化

  + char [] chars = str.toCharArray()  
  + String.valueOf(chars)

+ boolean success = set.add(str.charAt(i));

  + set是HashSet类型，插入成功（插入前不存在这个元素），set.add()的返回值才为true

+ substring的用法

  + str.substring(0,i) 包含str[0]~~str[i-1]，不包含str[i]

  + str.substring(i+1)，包含str[i+1]~~str的末尾

## 题2 [变态跳台阶](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387)

   <%blockquote%>

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

 <%endblockquote%>

## 提示

dp====>数学归纳

### 思路

回顾一下 “跳台阶”这题。

 <%blockquote%>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 <%endblockquote%>

一开始不好理解，先按照题意举几个例子：

当n=1， 1种跳法（直接跳1）

当n=2,    2种跳法，（先跳1，再跳1）+(直接跳2级)

当n=3，

+ 第一步先跳1级，剩下2级，有2种跳法（查看上面当n=2的情况=2）
+ 第一步先跳2级，剩下1级，有1种跳法（查上面当n=1的情况=1）
+ 所以说，当n=3，总共有2+1=3种

总结出一个通用的式子：记n阶台阶的跳法有f(n)种，都可以有两种做法：

+ 先跳1级，剩下了n-1级,  【f(n-1)种跳法】

  + 而剩下的n-1级的跳法又有以下两种情况
    + 先跳1级，再跳n-2级
    + 先跳2级，再跳n-3级

+ 先跳2级，剩下了n-2级， 【f(n-2)种跳法】

  ​	........................

所以f(n)=f(n-1)+f(n-2)，其实这个模型符合斐波那契数列。

---

回到这题。

先写几个找找规律

+ 当 n = 0, 0种

+ 当 n = 1 ,跳1级 1种
+ 当 n = 2   2种
  + 先跳1，剩1级，1种
  + 先跳2，剩0级，1种 
+ 当 n =3  结果：4种
  + 先跳1级，剩2级，  f(2) = 2种
  + 先跳2级,  剩1级，  f(1) = 1种
  + 先跳3级, 剩0级， 1种
+ 当 n =4  结果：8种
  + 先跳1级，剩3级，f(3) =4种
  + 先跳2级，剩2级，f(2) = 2种
  + 先跳3级，剩1级， f(1) =  1种
  + 先跳4级，剩0级， 1种
+ 可以看出，如下规律 f(n) = f(n-1)+f(n-2) +...f(1)+1，为了让式子看起来和谐一点，我们可以让f(0)=1,则式子可以表示成f(n) = f(n-1)+f(n-2) +...f(1)+f(0)。 不难发现 ，f(n-1) = f(n-2)+f(n-3)+....f(0)，所以f(n) = 2 *f(n-1) 





### 代码

```java
public class Solution {
    public int JumpFloorII(int target) {
        if(target<=2)
            return target;
        int dp[]=new int[target]; // dp[i]表示剩下i级时的跳法
        dp[0] = 1;  //默认为1，可以表示剩0级的时候有1种跳法
        dp[1] = 1;
        dp[2] = 2;

        for(int i=3;i<target;i++){
            dp[i] = 2*dp[i-1];
        }
        return 2*dp[target-1];
    }
}
```

数学归纳后的代码:

```java
public class Solution {
    public int JumpFloorII(int target) {
        if(target<=0)
            return target;
        return (int)Math.pow(2,target-1);
    }
}
```

### 反思

有了“跳台阶”这题的基础，其实很容易想到上述的归纳。

最开始做这题可能会想到递归-->然后发现递归会多次重复计算，可以动态规划--->贪心-->而又发现这题又可以用公式归纳出来，直接求解。



## 题3 [左旋转字符串](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec)

## 思路

根据定义求解，一步一个脚印

```java
public class Solution {
    public String LeftRotateString(String str,int n) {
        if(str==null || str.length()==0 || n<=0)
            return str;
        while(n!=0){
            char first = str.charAt(0);
            String sub = str.substring(1);  //截取字符串
            str = sub+first;
            n--;
        }
        return str;
        
    }
}
```

改进后：一步到位

```java
public class Solution {
    public String LeftRotateString(String str,int n) {
        if(str==null || str.length()==0 || n<=0)
            return str;
        n = n % str.length();  //把这句注释竟然也可以。
        return str.substring(n) + str.substring(0,n); 
    }
}
```



##  题4 [构建乘积数组]()

### 思路

一开始没什么思路。先写一个暴力解决，观察哪里有改进的空间。

```java
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        //暴力解法O(n^2)
        int [] B = new int [A.length];
        for(int i = 0;i < A.length ;i++){
            int mul = 1;
            for(int j = 0; j< A.length;j++ ){
                if(j!=i)
                    mul*=A[j];
            }
            B[i] = mul;
        }
        return B;
    }
}
```

这种做法完全是使用定义做的，比如说当A[n]=5，则B[3] = A[0]XA[1]XA[2]XA[4]，B[4]=A[0]XA[1]XA[2]XA[3]，可以看到计算B[3]和B[4]时有重叠计算的部分（A[0]XA[1]XA[2]）。要想优化，我们就看看是否可以只计算一次重叠的部分。

确实有这样的优化方法，可以将时间复杂度从O(n^2)优化成O(n)。

![image-20200428213947621](../images/image-20200428213947621.png)

上图参考了《剑指Offer》，基于此思路的改进代码如下：

```java
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        int left [] = new int [A.length];    //左下角计算的中间结果(含对角线)
        int right[] = new int [A.length];    //右下角计算的中间结果(含对角线)
        int B[] = new int [A.length];        //返回结果
        for(int i = 0; i < A.length; i++){
            if(i==0){
                left[i]=1;
            }
            else{
                left[i] = left[i-1] * A[i-1];
            }
        }
        for(int i = A.length-1; i >=0 ; i--){
            if(i==A.length-1){
                right[i] = 1; 
            }else{
                right[i] = right[i+1] * A[i+1];
            }
            B[i] = left [i] *right [i]; //在这个循环就可以直接出B[i]，不用再重新写一个for循环。
        }
        return B;
    }
}
```

进一步改进

进一步观察，会发现其实没必要设置left、right这两个辅助数组，可以直接在B[]数组上操作。

```java
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        int B[] = new int [A.length];        //返回结果
        B[0] = 1;
        for(int i = 1; i < A.length; i++){  //计算 B[i]左边的乘积（含对角线）
            B[i] = B[i-1] * A[i-1];
        }
        
        int temp = 1; //temp记录B[i]右边的乘积
        for(int i = A.length-2; i >=0 ; i--){    
            temp = temp * A[i+1];
            B[i] *= temp;
        }
        return B;
    }
}
```

## 题5  [和为S的连续正数序列](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe)

一开始没啥思路，暴力解决。

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
       ArrayList<ArrayList<Integer> > arrayList = new  ArrayList<ArrayList<Integer>>();
       //i=sum是想当然的，可以优化
        for(int i = sum; i>=2; i--){ //设i个连续数字，x,x+1,x+2.....x+(i-1)的和为sum，
           int temp = sum;
            //可以利用等差数列公式，不用这么麻烦
           for(int j = 0; j<i ;j++){  //减去每个数字的常数项，以求出x的取值 
               temp -= j;		// temp-0-1-2-...(i-1)，可以直接算出temp - (i/2)*(i-1),不过写的时候要写temp - i*(i-1)/2,否则i为奇数时就不对了。
           }
           int x = temp/i;
           if(temp % i == 0 && x>0){   //temp / i的结果必须是整数，且题目要求是正数
               ArrayList <Integer> list = new ArrayList<>();
               for(int j = 0 ; j<i ;j++){ //逐个将x,x+1....x+(i-1)加入list
                   list.add(x+j);
               }
               arrayList.add(list);
           }
       }
        return arrayList;
    }
    
}
```

使用数学知识（等差数列求和公式变形），对上面的代码改进：

```java
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
       ArrayList<ArrayList<Integer> > arrayList = new  ArrayList<ArrayList<Integer>>();
       for(int i = (int) Math.sqrt(2 * sum) ; i>=2; i--){ //i表示连续数字的个数
           int temp = sum - i*(i-1)/2;  //减去常数项
           if(temp % i == 0 && temp/i>0){
               int x = temp/i;
               ArrayList <Integer> list = new ArrayList<>();
               for(int j = 0 ; j<i ;j++){
                   list.add(x+j);
               }
               arrayList.add(list);
           }
       }
        return arrayList;
    }
      
}
```

这样做，复杂度变成了O(根号s)

还有一个思路是 双指针，控制滑动窗口，可以试试看。

## 题6 【待改进-贪心】 [剪绳子]()

最近递归的题目做的多，思路挺顺的了，这题没想多久，自然而然就想到了。

```java
public class Solution {
    public int cutRope(int target) {
        int max =0;
        for(int  m =2 ;m<=target; m++){ //剪几刀
            if(cut(target,m) >max)
                max = cut(target,m);
        }
        return max;
    }
    //计算n段绳子剪去m段的最大值
    public int cut(int n,int m){ //剪下长度为n的绳子，剪m段,每段最少为1
       if(m == 0){    //m=0表示不需要剪了，直接返回
            return 1;      //这里要是return 0，做乘法后结果就都是0了，不对
        }
        int max = 0;
        for(int i =1 ;i<= n-(m-1);i++){ //第一刀剪掉i，i最少为1，最多为n-(m-1)以确保后面剩余的m-1刀每次都能剪1
            if(i * cut(n-i,m-1) >max)
                max = i * cut(n-i,m-1);
        }
        return max; //返回 i* 的最大值
    }
}
```

**截至今日结束，进度： 40/67**

# 20200427 晴

## 题1 [按之字形顺序打印二叉树](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0)

### 思路

这题和昨天做的”[把二叉树打印成多行](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288)“很像。都是用层序遍历的思路，区别就在于当访问行数是偶数，要将该行元素的ArrayList反转。

### 细节

+ Collections.reverse(arrayList); import java.util.Collections;
+ arrayList.add() ,queue.offer()。一开始没注意写了arrayList.offer()报错了

```java
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;
import java.util.Collections;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if(pRoot == null){
            return   new ArrayList<>();          
        }
        ArrayList<ArrayList<Integer> > rows = new ArrayList<>();
        Queue <TreeNode> queue = new LinkedList<>();
        queue.offer(pRoot);
        ArrayList<Integer> row = new ArrayList<>();
        int nextLevelNum = 1; //记录还要访问几个元素可以到下一层，即每层元素的个数，初始化是1
        boolean needReverse = false; //记录当前行是否需要反转
        while(!queue.isEmpty()){
            //队首节点出队列
            TreeNode node = queue.poll();
            //将节点值加入row
            row.add(node.val);
            if(node.left!=null){
                queue.offer(node.left);
            }
            if(node.right!=null){
                queue.offer(node.right);
            }
            nextLevelNum--;
            if(nextLevelNum == 0){//说明该层访问完了
                if(needReverse){
                    Collections.reverse(row);
                }
                rows.add(row);
                row = new ArrayList<>();
                //重新设定nextLevelNum和needReverse
                nextLevelNum = queue.size();
                needReverse = !needReverse;
            }
           
        }
        return rows;

    }

}
```



## 题2 [平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222)

### 思路

我的思路就是根据平衡二叉树的定义解决：一棵树是平衡二叉树，则其左右子树高度差不大于1且左右子树都是平衡二叉树。这种做法是最直观的，但是效率一般（不过也能AC）。

### 代码

```代码
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null)
            return true;
        int balanceFactor = treeHeight(root.left) - treeHeight(root.right);
        return Math.abs(balanceFactor) <= 1 && IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
    }
    public int treeHeight(TreeNode node){
        if(node == null)
            return 0;
        int leftHeight = treeHeight(node.left);
        int rightHeight =  treeHeight(node.right);
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```

### 分析

在计算每个节点的深度的时候，进行了多次的重复计算，这样计算的开销还是比较大的。（类比递归求斐波那契数列的重复计算）

又注意到实际上在计算树高时（上面的treeHeight方法）就要计算左右子树高度，这时候就可以判断是否平衡。

### 改进

参考了[博客](https://blog.csdn.net/dawn_after_dark/article/details/81702988)。

核心：**把求树的深度与判断树的平衡融合在一起。**

改进思路就是在计算root高度的同时，就判断是否出现过不平衡的节点，使用一个成员变量isBalance存放结果（作为全局变量），一旦出现了不平衡节点，isBalance被置为false,则可以停止后续的递归计算。这样做效率比原思路好，只要调用一次treeHeight(root)即可。

```java
public class Solution {
    boolean isBalance;
    public boolean IsBalanced_Solution(TreeNode root) {
        //当root=null，返回isBalance=true。
        isBalance = true;  //默认为true
        treeHeight(root);
        return isBalance;
    }
    public int treeHeight(TreeNode node){
        if(node == null || isBalance == false) //如果isBalance已被置为false，可以直接返回，不用再判断了
            return 0;
        int leftHeight = treeHeight(node.left);
        int rightHeight =  treeHeight(node.right);
        if(Math.abs(leftHeight-rightHeight) > 1){  //判断root是否不平衡
            isBalance = false;
        }
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```



## 题3[矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13)

### 思路

其实该模型符合斐波那契数列。

f(n) = f(n-1)+f(n-2)，

n=0的时候

+ 0种

n = 1 的时候

- 只能横着覆盖，一种

n = 2 的时候

- 可以横着和竖着覆盖，两种

n = 3 的时候

- 第三级竖着覆盖，用了一级，剩下 n = 2，有两种覆盖方法
- 第三级横着覆盖，用了两级，剩下 n = 1，有一种覆盖方法
- 总共有 3 种

n = 4 的时候

- 第 4 级竖着覆盖，用了一级，剩下 n = 3，有三种覆盖方法
- 第 4 级横着覆盖，用了两级，剩下 n = 2，有两种覆盖方法
- 总共有 5 种方法

n = n 的时候

- 第 n 级竖着覆盖，用了一级，剩下 n = n - 1，所以关注第 n - 1 种有几种覆盖方法
- 第 n 级横着覆盖，用了两级，剩下 n = n - 2，所以关注第 n - 2 种有几种覆盖方法
- 总和为两种情况的总和

### 代码

```java
public class Solution {
    public int RectCover(int target) {
        if(target == 0){
            return 0;
        }else if(target == 1){
            return 1;
        }else if(target == 2){
            return 2;
        }
        return RectCover(target-1) + RectCover(target-2);
    }
}
```



![第n级竖着放](/images/image-20200427235728192.png)

![第n级横着放](/images/image-20200427235839863.png)

### 改进

递归做会有多次的重复计算，可以考虑空间换时间，动态规划求斐波那契数列。

此处略。



## ## 【待解决】题4[二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8)

### 思路

题目要求是求整数的补码中的1的个数。

我们知道，对于正数，其补码就是原码。如十进制数9的补码=10的原码=0，1001（首位0是符号位）。

而十进制数-9的原码=1，1001（首位1是符号位），其补码是：1，0111

我一开始想的是先算出补码的二进制表示，再计算1的个数，这种效率太低了，要用位运算，这块知识有些忘了，还要再复习一下。



## ## 【待解决】题4 [数组中只出现一次的数字]()

### 思路

位运算。

位运算异或（XOR）的特点：

+ 0 ^ 0 = 0		1 ^ 1 = 0		1 ^ 0 = 1	        0 ^ 1 = 1 

+ a  ^  a = 0 ,因为a的二进制^a的二进制每一位异或结果都是0。
+ a  ^ 0 = a , 因为a的二进制的每一位与0的异或结果都是本身 

+ 结合上述两点，a ^ b ^ a = b



---

# 20200426 晴

## 题1 [把二叉树打印成多行](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288)

## 思路

显然，此题是层序遍历的应用。二叉树的层序遍历很简单，使用队列就能完成，本题要在层序遍历的基础上使用一个变量，来记录下一层的元素个数，每当遍历完了一层，就更新这个值，且换行。

## 提示

+ 题目给的方法返回值是 ArrayList<ArrayList<Integer> > ，一开始没反应过来，后来仔细一想，是每行的元素单独保存在一个ArrayList里，再返回所有行的元素。

```java
import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;


/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if(pRoot==null)
            return new ArrayList <>();
        int nextLevelNum = 1; //记录还要访问几个元素才到下一层,初始值为1,因为第一层肯定只有根节点一个元素
        Queue <TreeNode> queue = new LinkedList<>();
        queue.offer(pRoot);
        ArrayList<ArrayList<Integer>> rows = new ArrayList<>(); 
        ArrayList <Integer> row = new ArrayList<>();
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();//当前队头节点出队列
            row.add(node.val);    //将节点的元素值加入到row列表
            if(node.left!=null){ //并将其非空子节点加入队列
                queue.offer(node.left);
            }
            if(node.right!=null){
                queue.offer(node.right);
            }
            nextLevelNum--;  //每访问完了一个节点，nextLevelNum就减1
            if(nextLevelNum == 0){ //说明这一层已经访问完了，要重新设置它的取值,它的取值其实就是当前队列的元素个数
                nextLevelNum = queue.size();
                rows.add(row);
                row = new ArrayList<>(); 
            }
        }
        return rows;
    
    }
    
}
```

### 细节：

+ 队列操作的API、导入所在包，nextLevelNum这个变量是本题精髓！

+ ```java
      if(pRoot==null)
          return new ArrayList <>();  一开始写的return null，无法通过！
  ```







---



# 20200425 晴

## 题1[复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba)

### 做题前思路

首先要注意要求是复制结点，而不是复制引用。

其次要注意random属性。



## 题2 [序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84)

### 思路

层序遍历。 

在序列化操作的时候，要注意左右子树的空结点也要加入队列。

在反序列化的时候，用一个结点数组保存所有节点（包含左右空节点）。



```java
import java.util.Queue;
import java.util.LinkedList;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    String Serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        Queue <TreeNode> queue = new  LinkedList <>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode currentNode = queue.poll();
            if(currentNode != null){
                sb.append(currentNode.val+",");
                queue.offer(currentNode.left); //不管是否为空都会加入队列
                queue.offer(currentNode.right);
            }else{
                sb.append("#"+",");
            }
        }
        return sb.toString();
        
  }
    TreeNode Deserialize(String str) {
        String [] nodeVals = str.split(",");
        TreeNode [] nodes = new TreeNode[nodeVals.length];
        for(int i = 0; i<nodeVals.length; i++){
            if(!nodeVals[i].equals("#")){
               nodes[i] = new TreeNode(Integer.valueOf(nodeVals[i]));
            }
        }
        int i=1;
        for(TreeNode node : nodes){
            if(node != null){
                node.left=nodes[i++];
                node.right=nodes[i++];
            }
        }
        return nodes[0] ;
       
  }
}
```



## 题3 [数组中重复的数字](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8)

### 思路

HashSet 时间复杂度O(n)  空间复杂度O(n)

参考别人的：重排数组 ：时间复杂度O(n)，空间复杂度O(1)。

```java
public class Solution数组中重复的数字 {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(numbers == null){
            return false;
        }
        HashSet <Integer> set = new HashSet <>();
        for (int i = 0; i<numbers.length ; i++){
            if(!set.contains(numbers[i])){
                set.add(numbers[i]);
            }else{
                duplication[0] = numbers[i];
                return true;
            }
        }
        return false;
    }
}
```





## 【待解决】题4 [数组中的逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5)

### 思路

+ 暴力求解：从第一个元素开始，判断后面比它小的元素的个数  O(n^2)，不出所料，运行超时，通过50%的用例。
+ 【待学习】提示：归并的改进

---





# 20200422

## 题1 [二叉搜索树的第k个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a)

### 做题前思路

给定一棵二叉搜索树，请找出其中的第k小的结点。根据BST中序遍历结果是升序的这一性质，可以中序遍历，直到遍历到第k个结点。

### 按照此思路的代码：

```java
//中序递归，成功AC
public class Solution {
    int num;    //num表示当前中序遍历已经访问了几个元素
    TreeNode node; //node存放结果
    TreeNode KthNode(TreeNode pRoot, int k)
    {
       inorder(pRoot,k);
       return this.node;
    }
    void inorder(TreeNode node,int k){
        if(node==null){
            return;
        }
        inorder(node.left,k);
        num++;
        if(num==k){
            this.node=node;
            return;  //结束后续的访问
        }
        inorder(node.right,k);
    }
}
```

分析：就算找到了Kth结点也会遍历完整个BST。时间复杂度是O(N)

改进：可以考虑非递归实现中序遍历，这样就能在找到Kth结点后结束遍历。





## 【待解决】题2 [字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720)

## 做题前思路

hashmap



## 知识点
+ LinkedHashMap和HashMap的差别
  + LinkedHashMap
  + [Hashmap遍历方法](https://www.cnblogs.com/lykbk/p/dfdfdffd34534343434.html)





## 题3 [统计一个数字在排序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2) 

### 做题前思路

+ 法1：二分查找定位该数字，再找左边和右边相等的元素个数。

+ [多种方法改进参考文章](https://www.cnblogs.com/lishanlei/p/10707678.html)
  + 最后采用的方法：因为数组中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。



```java
/**
 * @Created by hfq on 2020/4/23
 * @used to:
 */
public class Solution数字在排序数组中出现的次数 {
    public int GetNumberOfK(int [] array , int k) {
        return BinarySearch(array,(float)(k+0.5)) - BinarySearch(array,(float)(k-0.5));
    }
    //返回目标t插入array的位置
    public static int BinarySearch(int [] array , float t){
        int i = 0;
        int j = array.length-1;
        int mid = 0;
        while(i<=j){   //<= 等号不可遗漏！！
            mid = j+(i-j)/2;
            if(array[mid] > t){  //在左边查找
                j = mid-1;
            }else if(array[mid] < t){ //在右边查找
                i = mid+1;
            }else{
                //实际上不可能发生，可以和上面的else if合并
            }
        }
        return i;   //array[mid]在array[i]和array[j]中添加
    }

    public static void main(String[] args) {
//        int [] a = {3,3,3,3};
        int [] a = {3,3,3,3};
        System.out.println(BinarySearch(a, (float) 2.5));
        System.out.println(BinarySearch(a, (float) 3.5));
    }
}
```



分析：这种做法在各种情况下效率都比较高。 

当数组是：[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]，如果采用法1，效率退化成O(n),而这种方法时间复杂度还是O(lgn)级别的

---





# 20200421 

## 题1：[栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106)

### 代码：

```java
import java.util.ArrayList;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA==null||pushA.length==0)
            return true;
        int stack [] = new int[pushA.length];
        int size = 0;
        int pushIndex=0;
        stack[size++] = pushA[pushIndex++];
        int current = 0;
        while(pushIndex<pushA.length)
        {
            if(stack[size-1]!=popA[current])
            {
                stack[size++] = pushA[pushIndex++];
            }else{ 
                size--;
                current++;
            }
        }
        while (size!=0){
            if(stack[size-1]!=popA[current]) {
                return false;
            }
            else {
                size--;
                current++;
            }
        }
        if(size==0)
            return true;
        return false;
    }
}
```

### 解析：

以输入{1,2,3,4,5}，{4,5,3,2,1}为例。

借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。

 我的代码没有用JDK提供的Stack，而是用一个数组+size模拟栈。

## 题2：[二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e)
### 代码
```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        TreeLinkNode successor = null; //表示后续结点，保存返回结果
        //当这个结点有右子树，那么其后续结点必然在其右子树中的最小的元素
        if(pNode.right!=null){
            successor = pNode.right;  
            while(successor.left!=null){
                successor = successor.left;  //一直向左走找最小的元素
            }
        }else if(pNode.next != null){  //没有右子树但是有根节点
            successor = pNode;  
            while(successor.next != null && successor == successor.next.right){
                successor = successor.next; //当此结点始终是其父节点的右子树的时候，逐级找父节点
            }
            successor = successor.next;
        }
        return successor;
    }
}
```

### 解析：

求二叉树某一结点的后续结点。

![image-20200421205013742](/images/image-20200421205013742.png)

根据这个pNode结点的状态，分为三种情况求解:

+ pNode存在右子树，那么其后续结点必然在其右子树中。
  - 这是由中序遍历的定义决定的：若某节点存在右子树，那么访问完这个结点后访问的下一个结点必然是右子树中的某个结点。
  - 返回结果是 pNode.right.left.left.left.... 
+ pNode不存在右子树，但存在父节点，那么其后续结点是其祖父结点，或者是null
+ 既不存在右子树，也不存在父节点，返回null

提示：

+ 可以借助二叉树的一种特殊情况——二叉搜索树思考这题，上述代码的注释就是这样做的，表面看我们考虑的是特殊情况，但是实际上这样做对二叉树具有普遍性。

+ 另外提一下，这道题目有点坑的地方是：包含指向父结点的指针的变量名是next，不是parent，注意一下。



## 【待解决】题3:[顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a)

被这道题虐了很久。。

一直会忽略某些情况。



```java
package com.hfq;

import java.util.ArrayList;
public class Main {
    public static ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList <Integer> list = new ArrayList<>();
        addElementToList(matrix,0,matrix.length-1,0,matrix[0].length-1,list);
        return list;
    }

    public static void addElementToList(int [][] matrix,int rowsMin,int rowsMax,int colsMin,int colsMax,ArrayList list) {
        if(colsMax<0 && rowsMax<0){
            return;
        }

        for(int i = colsMin; i<=colsMax ; i++){ //从左往右
            list.add(matrix[rowsMin][i]);
           // System.out.println(matrix[rowsMin][i]);
        }

        if(rowsMax>rowsMin){
            for(int i = rowsMin+1; i<=rowsMax ; i++){ //从上往下
//            System.out.println("i="+i+",colsMax"+colsMax);
                list.add(matrix[i][colsMax]);
                //System.out.println(matrix[i][colsMax]);
            }
        }

        if(colsMax-1>colsMin){
            for(int i = colsMax-1; i>=colsMin ; i--){  //从右往左
                list.add(matrix[rowsMax][i]);
               // System.out.println(matrix[rowsMax][i]);
            }
        }

        if(colsMax-colsMin>=1 && colsMax > colsMin ){
            for(int i = rowsMax-1; i>=rowsMin+1 ; i--){ //从下往上
                list.add(matrix[i][colsMin]);
              //  System.out.println(matrix[i][colsMin]);
            }
        }
        addElementToList(matrix,rowsMin+1,rowsMax-1,colsMin+1,colsMax-1,list);
    }


    public static void main(String[] args) {
//        int a [][] ={{1},{2},{3},{4},{5}};
//        int a [][] ={{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
        int a [][] ={{1,2},{3,4},{5,6},{7,8},{9,10}};
        ArrayList<Integer> integers = printMatrix(a);
        for(Integer integer:integers){
            System.out.printf(integer+",");
        }
    }

}
```



## 题4:[包含min函数的栈](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49)

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。

### 思路

一开始我的想法很简单，用一个使用一个变量记录当前的最小元素，如果新压入栈的元素更小，就更新它。

但是仔细一想，这种做法有一个问题，假如记录的最小元素出栈了，就没办法以O(1）的时间复杂度获取新的最小元素了，所以在保存最小元素的同时，有必要保存最小元素出栈后次要小的元素，同理，也要保存第三小的元素....

所以，要用一个辅助栈来保存当前的最小元素以及之前的的最小元素，栈顶就是当前栈的最小元素，栈顶元素的下一个元素就是这个元素出栈后的新的最小元素。

+ 每次压栈时，如果压入的元素小于当前最小元素，则也将其压入辅助栈，否则，则将上一个最小元素压入辅助栈。
+ 每次出栈时，弹出元素的同时也弹出辅助栈的元素。



### 知识点复习

Stack的API

+ peek()
+ size()
+ pop()
+ push()

### 代码

```java
import java.util.Stack;

public class Solution {
    public Stack <Integer> stack = new Stack<>();  //数据栈 
    public Stack <Integer> minStack = new Stack<>();; //辅助栈

    public void push(int node) {
        stack.push(node);
        if(stack.size()==1){  //现在是1，说明压栈前是0。
            minStack.push(node);
        }else{
            minStack.push(node<minStack.peek() ? node : minStack.peek());
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

### 题解

关键字 ：最小值辅助栈



## 题5 [把数组排成最小的数](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993)

没啥思路，借鉴了网上的[解法](https://blog.csdn.net/xiaoxingxing1744/article/details/84191277)，觉得很妙。

关键字：自定义比较大小的方法。

### 提示

转成字符串，自定义比较器后排序

### 知识点复习

+ int类型转成String类型
  - String.valueOf(i)
  - Integer.toString(i)
  - i+""

+ 比较字符串大小

+ 拼接字符串 （StringBuilder）

  + sb.append()
  + sb.toString()

+ 代码细节

  - Arrays.sort()

    - import java.util.Arrays;
  - Comparator
  - import java.util.Comparator;

  ```java
  new Comparator<String>() {
      @Override
          public int compare(String str1, String str2) {   //3  12  312 123
          	return 0;
      }
  }
  ```

### 代码

```java
/**
 * https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993
 * @Created by hfq on 2020/4/22
 * @used to:
 * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
 * 打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
 */
public class Solution把数组排成最小的数 {
    public static String PrintMinNumber(int [] numbers) {
        StringBuilder sb = new StringBuilder();
        String numString [] = new String[numbers.length];
        for (int i=0; i<numbers.length; i++){
            numString[i]=String.valueOf(numbers[i]); //将整数转成字符串
        }
        Arrays.sort(numString, new Comparator<String>() {
            @Override
            public int compare(String str1, String str2) {   //3  12  312 123
                return 0;
            }
        });
        for (String str : numString){
            sb.append(str);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        int[]numbers={3,32,321};
        System.out.println(PrintMinNumber(numbers));
    }
}

```



进度：25题/67题。



