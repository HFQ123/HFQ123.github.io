---
title: 再谈单例模式
date: 2020-05-06 23:20:09
tags: [设计模式,并发,推荐阅读]
---

之前，学设计模式的时候，接触了单例模式的四种实现方法，那个时候还不怎么理解，糊里糊涂地整理了[笔记]([https://hfq123.github.io/2020/04/18/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0charpter5/](https://hfq123.github.io/2020/04/18/《Head-First-设计模式》读书笔记charpter5/))。

现在学了JVM和并发编程后，对单例模式的实现细节有了更好的掌握。借此机会回顾一下DCL(Double Check Lock，即双重检查锁)实现单例和静态内部类实现单例。



## DCL单例模式

### 经典懒汉单例模式的实现

```java
public final class Singleton{
    private Singleton(){}
    
    private static Singleton instance;
    
    public synchronized static Singleton getInstance(){
            if(instance==null)
                return new Singleton();
        return instance;
    }

}
```

在此代码，重点关注**synchronized**关键字，它修饰了获取单例的静态方法。

之所以在这里要用synchronized，是因为防止多线程情况下，如果多个线程同时执行到了if(instance==null)，判断都是true，将会导致在多个不同的线程创建了多个不同实例，违背了单例模式的目标，所以需要使用synchronized保证这块代码的**原子性**，也就是在一个线程创建实例的时候避免其他线程的干扰。



## 一步步改进

我们知道，synchronized关键字修饰静态方法，就相当于修饰了所在类.Class对象，所以上述代码等价于如下代码:

```java
public final class Singleton{
    private Singleton(){}
    
    private static Singleton instance;
    
    public static Singleton getInstance(){
        synchronized (Singleton.class){ 
            if(instance==null)
                return new Singleton();
        }
        return instance;
    }

}
```

这种方法虽然实现了懒惰实例化，需要用到单例时才会创建，而且也保证了线程安全。

但是性能上存在缺陷：

原因是，在此实现中，每次进入getInstance方法获取单例时，都要进入先synchronized修饰的同步代码块。但实际上**只有在首次创建单例（第一次调用getInstance方法）的时候，有线程安全的问题**，一旦创建了单例后，多个线程获取单例不会有线程安全的问题，而synchronized加锁是有性能开销的，这样做就相当于把一部分不需要加锁的情况，也加了锁。

根据此思路，我们对这段代码改进，就会得到DCL单例模式的初步实现：

```java
public final class Singleton{
    private Singleton(){}
    
    private static Singleton instance;
    
    public static Singleton getInstance(){
		if(instance==null){  //根据分析，只有首次创建（也就是当前instance为空）时，需要进入同步代码块
            synchronized (Singleton.class){ 
                if(instance==null)
                    return new Singleton();
            }
        }
        return instance;
    }

}
```

在此实现中，先后两次对instance进行是否为空的判断，这也是“double check“这个名字的由来。

细心的读者会看到上文我说，这一种是DCL的”初步实现“，看似完美的实现有什么不足呢？

这就要从字节码的角度分析了。

指令重排。

先调用构造方法再内存指向，先内存指向再调用构造方法都有可能！！。

其他线程执行第一个检查的时候，判断instance==null的条件不成立，直接返回了instance对象，而对比经典的单例模式实现中，synchronized关键字修饰了，只有获得了对象监视器的线程可以访问instance 。

不会影响本线程，但是可能影响其他线程



说了这么多，如何解决呢？

​    private static **volatile** Singleton instance;

饿汉：类加载时就会创建单例对象。（静态成员变量会初始化阶段赋值）

懒汉：类加载时不会导致单例对象被创建，而是首次使用该对象才会创建。







