---
title: JVM学习笔记-JVM内存区域
date: 2020-04-30 00:38:18
tags: [JVM,笔记]
---



学习JVM有一段时间了，消化后整理了此笔记便于自己复习，此系列定位为“笔记”，一些地方就写得比较精简了，适合已经系统学习过JVM的读者翻阅。


主要参考材料是《深入理解Java虚拟机》第二版。

## JVM内存区域



### 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，每个区域有各自的用途。

根据该区域是否是线程私有，可以分为线程私有的区域和线程共享的区域。

#### 线程私有的内存区域

##### 程序计数器
它的作用是指示当前线程要执行的字节码的行号（字节码指令的地址）。  java多线程是通过线程轮流切换实现的，线程被挂起后下次需要恢复到正确的执行位置，所以每个线程都需要一个独立的程序计数器。

除了线程私有，程序计数器区域的另一个特点是占用内存空间很小，唯一的一个不会OOM的区域。

#### Java虚拟机栈

既然它是栈，那么栈元素是什么呢？答案是栈帧。栈帧用于存放局部变量表、操作数栈 、动态链接、方法出口等信息。每调用一个Java方法，与之对应的一个栈帧入栈，执行完成，出栈。

此区域有两种内存溢出的情形：

- StackoverflowError

  栈中加入的元素（栈帧）过多造成栈溢出，也就是调用的方法过多，一直没有返回），比如说持续递归会造成这种情况 。

- OutOfMemoryError

    如果虚拟机栈支持动态扩展，扩展时无法申请足够的内存，就会出现此情况OOM。

#### 本地方法栈

这一内存区域与 Java虚拟机栈类似，不过其服务的对象是本地方法（一般是由C/C++实现的）而非Java方法。



#### 线程共享的内存区域

#### 堆

此内存区域唯一的目的就是**存放对象实例**，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也就变得不那么绝对了。

如果从垃圾回收的角度考虑，由于大部分JVM实现都采用了分代收集的回收算法，把堆空间进一步划分成新生代和老年代,其中新生代包括了Eden空间，From Survivor空间，To Survivor空间。

#### 方法区

方法区存放**已被虚拟机加载的类**的元数据（类信息、常量、静态变量、编译后的代码等等）。

- 永久代、元空间、方法区 [三者关系](https://blog.csdn.net/weixin_42740530/article/details/105288701)

  方法区是内存区域的一种规范，永久代和元空间都是方法区的一种实现。JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

- 运行时常量池是方法区的一部分

  Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用），类加载后Class文件中的常量池信息就进入了方法区的运行时常量池。

