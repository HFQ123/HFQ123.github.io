---
title: JVM学习笔记-JVM内存区域
date: 2020-04-30 00:38:18
tags: [JVM,笔记]
---



学习JVM有一段时间了，消化后整理了此笔记便于自己复习，此系列定位为“笔记”，一些地方就写得比较精简了，适合已经系统学习过JVM的读者翻阅。


主要参考材料是《深入理解Java虚拟机》第二版。

## JVM内存区域



### 运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，每个区域有各自的用途。

根据该区域是否是线程私有，可以分为线程私有的区域和线程共享的区域。

#### 线程私有的内存区域

##### 程序计数器
它的作用是指示当前线程要执行的字节码的行号（字节码指令的地址）。  java多线程是通过线程轮流切换实现的，线程被挂起后下次需要恢复到正确的执行位置，所以每个线程都需要一个独立的程序计数器。

除了线程私有，程序计数器区域的另一个特点是占用内存空间很小，唯一的一个不会OOM的区域。

##### Java虚拟机栈

既然它是栈，那么栈元素是什么呢？答案是栈帧。栈帧用于存放局部变量表、操作数栈 、动态链接、方法出口等信息。每调用一个Java方法，与之对应的一个栈帧入栈，执行完成，出栈。

此区域有两种内存溢出的情形：

- StackoverflowError

  栈中加入的元素（栈帧）过多造成栈溢出，也就是调用的方法过多，一直没有返回），比如说持续递归会造成这种情况 。

- OutOfMemoryError

    如果虚拟机栈支持动态扩展，扩展时无法申请足够的内存，就会出现此情况OOM。

##### 本地方法栈

这一内存区域与 Java虚拟机栈类似，不过其服务的对象是本地方法（一般是由C/C++实现的）而非Java方法。



#### 线程共享的内存区域

##### 堆

此内存区域唯一的目的就是**存放对象实例**，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也就变得不那么绝对了。

如果从垃圾回收的角度考虑，由于大部分JVM实现都采用了分代收集的回收算法，把堆空间进一步划分成新生代和老年代,其中新生代包括了Eden空间，From Survivor空间，To Survivor空间。

##### 方法区

方法区存放**已被虚拟机加载的类**的元数据（类信息、常量、静态变量、编译后的代码等等）。

- 永久代、元空间、方法区 [三者关系](https://blog.csdn.net/weixin_42740530/article/details/105288701)

  方法区是内存区域的一种规范，永久代和元空间都是方法区的一种实现。JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

- 运行时常量池是方法区的一部分

  Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用），类加载后Class文件中的常量池信息就进入了方法区的运行时常量池。

## HotSpot虚拟机对象探秘

《深入理解Java虚拟机》书中详细地介绍在HotSpot虚拟机在堆中对象分配、布局和访问的全过程。

### 对象的创建

对象的创建总体上有这几个步骤：

+ 类加载检查

  虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

+ 为新生对象分配内存

  在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

+ 初始化为零值

  内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

+ 对象头的设置

  初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到**类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息**。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

+ 执行init方法

  把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**，如哈希码、GC 分代年龄、锁状态标志等等,被官方称作Mark Word，**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 对象的大小必须是 8 字节的整数倍。

### 对象的访问

建立对象就是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**使用句柄**和**直接指针**两种。

这两种对象访问方式各有优势，使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

。。。此处待上图。。。

## 实战:OutOfMemoryError异常

上面讲的都是理论，在实战中，可能会遇到OOM的问题，我们开发人员要做的就是快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常该如何处理。

| 内存溢出区域 |报错信息| 可能的原因 | 解决方法 |
| ------------ | ---------- | ------------ | ------------ |
| 堆       | OOM java heap space ||调节堆大小(-Xms,-Xmx)<br />检查代码对象的生命周期是否合理|
| 栈 | StackoverflowError |||
|              | OutOfMemoryError |||
| 方法区 |  |||
| |  |||

