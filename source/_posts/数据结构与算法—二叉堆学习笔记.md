---
title: 数据结构与算法—二叉堆学习笔记
date: 2020-05-22 12:36:36
tags: 数据结构
---

本篇博客是我学习数据结构与算法的笔记，分享主题是「二叉堆」。

## 引入

二叉堆是什么？以下给出一些二叉堆的定义：

堆（Heap）是一种树状的数据结构，它有一个重要性质：任意节点的值总是`大于等于`或`小于等于`子节点的值。

- 如果任意节点的值总是`大于等于`子节点的值，称为`最大堆`。
- 如果任意节点的值总是`小于等于`子节点的值，称为`最小堆`。

而**二叉堆的逻辑结构就是一颗完全二叉树**，由于完全二叉树的一些性质，代码实现时可以用数组存储，下文会详细介绍。

![一个最大堆示例](/images/image-20200522202352727.png)

为什么要引入二叉堆这个数据结构？

想象这样一个场景：我们要设计一种数据结构，用来存放未知数量的整数，我们可以随时向其添加任意整数，在使用时,我们特别关注它的最大值，而不关心其他值, 除了添加元素操作之外，还有两个操作分别是：获取当前这个数据结构的最大值、删除最大值。

这个数据结构可以用线性表、BBST（如AVL、RBT）实现，它们的时间复杂度分析如下表：

| 数据结构       | 获取最大值时间复杂度 | 删除最大值时间复杂度 | 添加元素时间复杂度 |
| -------------- | -------------------- | -------------------- | ------------------ |
| 有序的动态数组 | O（1）               | O(1)                 | O(n)               |
| 红黑树         | O(logN)              | O(logN)              | O(logN)            |

针对此需求，有没有更优的数据结构？

我们发现，无论是维护元素顺序的动态数组还是红黑树都考虑了整个数据结构的顺序。有序数组不用多说，至于红黑树，构建时也间接维护了每个元素之间大小关系，其中序遍历结果是有序的。

而在需求中，我们重点关注对象的是这个数据结构的最大值，不在乎其他元素的大小顺序，维护整个数据结构的顺序显得有些“杀鸡用牛刀”的感觉。

实际上，这一需求就能用**最大堆**来实现，使获取最大值、添加元素、删除最大值这三个操作都有不错的效率：

获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn)。



## 代码实现

此部分以最大堆为例，给出代码实现。

在写代码前，先研究一下二叉堆的特性，前面已经提到了二叉堆的逻辑结构就是一棵完全二叉树，完全二叉树的结构可以存储在数组里，根据索引的关系就能计算出每个结点的父结点、子结点：

![二叉堆的特性](/images/image-20200522162621139.png)

在二叉堆的接口设计中：重点关注这三个操作：获取最大值、添加元素、删除最大值。



**获取最大值**这一操作很简单，根据最大堆的定义，任意节点的值总是`大于等于`子节点的值，所以根节点的值就是最大值，也就是说，数组的首元素就是最大值。



**添加元素**时，直接添加到最大堆的最后，但是这可能会破坏最大堆的结构，所以需要上浮(sift up)操作：如果插入的结点元素值比父节点元素值大，就要交换两者位置，循环直到插入结点的元素值不大于父节点的值或者插入结点已经上浮成为根节点（也就是说此节点没有父节点了）退出循环。

```java
/**
 * 添加元素到最大堆
 * @param element 要插入的元素值
 */
void add (E element){
    elements[size]=element;	    //插入到数组的最后
    siftUp(size);				//对刚才添加的元素执行“上浮”操作
	size++;
}

/**
 * 上浮操作，调整插入元素的位置
 * @param index 需要上浮操作的数组元素的索引
 */
void siftUp(int index){
    int pIndex = 0;                            //父节点的索引
    E value = elements[index],pValue;          //自己的元素值和父节点的元素值
    while (index>0){                           //只要还有父节点，就循环
        pIndex = (index-1)/2;                  //父节点的索引
        pValue = elements[pIndex];             //父节点的元素值
        if(cmp(value,pValue)<=0){		       //cmp函数用于比较两个元素的大小
            break;
        }
        //如果大于父结点，就交换。
        //E tmp = elements[index];			---标注1
        elements[index] = elements[pIndex];
        //elements[pIndex] = tmp;			---标注2
        index = pIndex;
    }
    elements[index] = value;				//----标注3
}
```

在上述代码，处理上浮操作的时候有一个小细节：在循环中，如果插入结点元素值比父节点要大，就要交换当前结点和父节点的位置，按理说交换操作应该是三步走：临时变量保存本结点的元素值（代码中标注1），本结点元素值=父节点元素值，父节点元素值=临时值（代码中标注2），然而这里由于每次比较的都是父节点和待插入结点的值，**所以可以将新添加节点备份，确定最终位置才摆放上去**（代码中标注3）。



**删除最大值**时，并不是直接删除根节点，而是先用最后一个结点的值覆盖根节点的值，然后再删除最后一个结点。

最后一个结点的值覆盖根节点的值这可能又会破坏最大堆的结构，所以需要下沉(sift down)操作。

```java
    /**
     * 移除最大值（也就是数组的首个元素）
     */
    void remove(){
        if(size==0) {
            return;
        }
        elements[0] = elements[size-1];     //用最后一个元素值覆盖首结点的元素值
        elements[size-1] = null;            //真正移除的是最后一个元素
        size--;
        siftDown(0);
    }

    /**
     * 下沉操作，删除最大值后调用
     * @param index
     */
    void siftDown(int index){
        int leftChild;
        int bigChild;  //记录左右孩子中较大的那个的索引
        E value = elements[index];
        while(index<size/2){ //只要还有子结点 也就是左孩子索引2i+1<size，也就是i<(size-1)/2
            leftChild = 2*index+1;//左孩子索引
            bigChild = leftChild;   //大孩子默认为左孩子（因为右孩子可能不存在）
            if(leftChild+1<size && cmp(elements[leftChild+1],elements[leftChild])>0){   //第一个条件表示右孩子存在，第二个条件表示右孩子比左孩子大
                bigChild = leftChild +1;
            }
            if(cmp(elements[bigChild],value)<=0){
                break;
            }
            //如果大孩子的值比自己大，才进行后续操作
            elements[index] = elements[bigChild];
            index = bigChild;
        }
        //退出循环时，要么就是该节点已经下沉到最底了(没有子结点了)，要么就是该节点已经到了大于等于所有子结点的位置
        elements[index] = value;
    }
```

二叉堆的接口设计中，除了上面这三个最重要的方法，还有一些别的方法：

+ replace(E element)

  删除最大值的同时插入一个新元素：用元素element代替根节点的值，然后进行下沉(siftDown)操作。

+ 批量建堆,也就是把一个没有规律的数组建立成堆： 有两种办法。

  方法1：自上而下的上浮O(nlogn)：本质是一个个添加

```java
    /**
     * 自上而下的上浮
     */
    void heapify1(){
        for(int i=1;i<size;i++){
            siftUp(i);
        }
    }
```

​	方法2：自下而上的下沉O(n)。

```java
    /**
     * 自下而上的下沉
     */
    void heapify2(){
        for(int i=size/2;i>=0;i--){ //从非叶子结点开始下沉
            siftDown(i);
        }
    }
```

注意：自上而下的下沉或者自下而上的上浮都不能作为批量建堆的方法。



## 应用

1、Top K问题

从n个数里找出最大的k个数。（k<<n）

◼ 如果使用排序算法（如快速排序）进行**全排序**，需要 O(nlogn) 的时间复杂度。

把所有数都排序了，杀鸡用牛刀。

◼ 如果使用进行k次**局部排序**（每次选出未处理的元素中的最大值放到前面），需要 O(n*k) 的时间复杂度。

处理完毕后，最大的k个数也排序了，需求中这最大的k个元素也不需要排序，似乎多此一举。

◼而如果使用二叉堆（最小堆）来解决，可以使用 O(nlogk) 的时间复杂度来解决。

建立一个大小为k的堆，先把数组n中的前k个元素添加到堆，然后对剩余元素做如下处理：

如果n数组中的当前元素大于堆顶元素，就用它代替最小堆堆顶元素，并进行sift down操作，以维护堆的性质。

如果当前元素小于堆顶元素，什么都不用做，继续访问下一个元素。

最后，堆中的k个数字就是最大的K个数，完美解决。



2、优先级队列

jdk的PriorityQueue就是二叉堆（最小堆）实现的。

这里截取部分代码看看：这不就是我们的siftUp上浮操作吗！

![JDK的PriorityQueue实现部分代码截图](/images/image-20200523113011879.png)

另外多说一句，在我写代码的时候，直接把两个元素的比较逻辑封装起来——在二叉堆类中组合了一个比较器对象(Compartor类型)，如果有外部比较器，就用外部比较器的逻辑比较，否则强制转成Comparable接口比较，像下面这样：

```java
    int cmp(E e1,E e2){
        if(comparator!=null){
            return comparator.compare(e1,e2);
        }
        return ((Comparable)e1).compareTo(e2);
    }
```

这样把比较逻辑封装起来之后的好处就是写代码时很简洁，但是仔细一想也有缺点：每次比较任何两个元素时都会判断比较器是否为空，再决定这两个元素比较的逻辑，这其实是没必要的，做了很多多余的判断，这也是为什么JDK实现中分为了siftUpComparable和siftUpUsingComparator，看上去有些啰嗦，实际上减少了判断次数。

关于优先级队列的更详细内容，推荐阅读:[PriorityQueue详解](https://www.jianshu.com/p/f1fd9b82cb72)。





## 总结

最后做一个简单总结。

+ 用于维护二叉堆性质的的上浮和下沉操作：

sift up 上浮：添加元素时直接添加到数组末尾，可能会破坏二叉堆性质——每个结点元素值必须大于子结点元素值，所以要上浮找到新元素的合适插入位置，想象一下如果把一个最大的元素值插入到了数组末尾后，会一直上浮到根节点。

sift down 下沉: 当要删除最大值的时候，直接让最后一个元素”空降“替代最大值，这种”空降“也可能会破坏二叉堆性质，所以要下沉，直到让”空降“的末尾节点找到合适的位置。

+ 最大堆和最小堆的”无缝切换“

另外值得一提的是，我上面写的代码是最大堆的实现，如何在此基础上修改成最小堆呢？

实际上不用修改封装好了的二叉堆类的代码，只要调用代码处指定自定义的比较器就好了。