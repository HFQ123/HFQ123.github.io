---
title: 《Head-First-设计模式》读书笔记charpter2
date: 2020-04-06 22:26:09
tags: [设计模式,笔记]
category: 设计模式 
---

本篇博客是《Head First 设计模式》第二章的读书笔记。

分享主题是设计模式中的 「观察者模式(Observer Pattern)」。



## 1、应用场景—气象监测应用

书中给出的例子是：公司要建立一个气象监测应用，如下图，WeatherData对象会从气象检测站获取实时更新的气象数据（湿度、温度、气压），WeatherData对象要做的就是将这些数据及时“分发”到多个布告板，使得每个布告板能使用最新的气象数据以更新它的显示情况。除此之外，附加的需求是系统必须可扩展，能够让用户随心所欲地添加或删除布告板，也就是说，目前系统有“目前状况”、“气象统计”、“天气预报”三个布告板，以后可能会删除某个或者新增别的布告板，言外之意就是说，WeatherData对象要随时准备好停止向现有的布告板分发最新数据以及随时准备好向新的布告板分发最新数据。

![image-20200406223021520](/images/image-20200406223021520.png)



## 2 实现思路

### 2.1 错误示范

我们先来看一个很容易想到的思路，然而这被书中称之为“错误示范”（这也是我学习观察者模式之前的思路）。首先我们先约定：一旦气象站测量的气象数据更新，WeatherData类的measurementsChanged()方法就会被调用，在本文，我们不用关心它是怎么做的，只要知道在此方法下，我们要做的就是将这些数据及时“分发”到多个布告板类。

接下来我们就一起来看看这个简单自然但是错误的示例吧，如下图，在WeatherData类的中measurementsChanged()方法里，做的事情很简单，就是获得最新的气象数据，然后以此作为参数各个布告板类的更新方法。

![image-20200406223736428](/images/image-20200406223736428.png)

看似完全能实现我们的需求：当气象站检测到新的数据，measurementsChanged()被调用：获得最新的气象数据，然后分别调用各个不同的布告板的update()方法（在这个方法里，布告板会根据自己的需求使用最新数据来改变显示板，我们无需关注update()方法里究竟做了什么，只要知道它需要获得WeatherData类的最新气象数据，供它们更新自己的数据以改变显示屏）。

这样实现究竟有哪些错误呢？

+ 各个布告板类之间是独立的，没有一个共同的接口，是典型的“针对实现而非针对接口编程”的错误。

+ 每当添加或删除新的布告板，我们都不得不修改方法体内的代码。比如说设计了一个新的testDisplay布告板，我们就要加上一行testDisplay.update(temp,humdity,pressure)，当testDisplay不再需要获取最新的气象状态，就要删除这行代码。
+ 也正是因为每当添加或删除新的布告板，我们都不得不修改方法体内的代码，所以我们无法在运行时动态地增加或者删除布告板。



### 2.2 观察者模式

引入观察者模式就能解决上述实现带来的问题。

先简单介绍一下什么是观察者模式，在观察者模式中，有两个主角，分别是**主题(Subject)**和**观察者(Observer)**，书上用了“出版者”和“订阅者”来类比观察者模式中的主题和观察者。出版者一旦出版新的报纸，他就要负责将新报纸分发到各个订阅者手中，而那些没有订阅报纸的人就不会收到，就和这里的例子一样，WeatherData类一旦获得新的气象数据，就要负责分发到各个布告板类中。观察者模式的概念是：{% blockquote %}观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。{% endblockquote %} 借助下图，能够让我们清楚地看到观察者模式的“一对多依赖”。

![image-20200406230651346](/images/image-20200406230651346.png)

观察者模式为主题和观察者都创建了各自的接口。在主题接口中，定义了注册观察者(registerObserver)方法、撤销观察者(removeObserver)方法、更新所有观察者状态方法（notifyObservers,一旦主题状态改变会触发）；在观察者接口中，定义了更新观察者状态的方法(update)。

![image-20200407002547510](/images/image-20200407002547510.png)

我们再把目光转移到应用场景，前面我们已经分析了思路1实现带来的问题，接下来就要好好考虑怎么解决：

首先，我们可以考虑需要**为所有布告板类创建一个观察者接口**，因为在WeatherData类中，WeatherData不关心布告板是叫currentConditionDisplay还是叫statisticsDisplay，只关心它是否需要在气象数据更新时获得自己的最新气象数据，如果它实现了观察者接口并且注册了主题（相当于订报人完成了订阅动作），那么当WeatherData类的数据更新时，它就是分发数据的目标之一。

然后，我们可以**在WeatherData类中维护一个所有观察者组成的列表**，这样做能让WeatherData类轻松地获取所有观察者（布告板）。有了观察者列表之后，每当WeatherData类的数据更新，就遍历列表内的所有布告板，调用它们的update()方法即可，WeatherData类不用再关注有几个观察者布告板，它们叫什么名字。当需要添加或删除新的布告板的时候，只需要对列表做增删操作，而不用像思路1中那样改动measurementsChanged()方法体内的代码，同时，这也解决了不能运行时动态地增删布告板的问题，因为运行时可以动态的修改列表的元素（比如说系统运行了十分钟后将currentConditionDisplay公告板从观察者列表中移除）。

想到这些，引入观察者模式之后的模型就呼之欲出了。引入观察者模式之后，本气象站应用的的类图就如下图所示，WeatherData和各布告板分别实现主题接口和观察者接口。

![image-20200407002514351](/images/image-20200407002514351.png)

接下来我们从代码的层面上来考虑一下主题的方法是如何实现的。

registerObserver(Observer o)：将观察者对象o加入到WeatherData维护的观察者列表。

removeObserver(Observer o)：将观察者对象o从WeatherData维护的观察者列表中删除。

notifyObservers():遍历WeatherData维护的观察者列表，在循环体内调用每个观察者对象的update()方法。



**对比思路1和思路2，可以发现，通过引入观察者模式，我们不仅能方便地实现布告板的增删**：当有了新的布告板对象o要“监听”WeatherData的最新数据，就调用registerObserver(o)，当它不再需要获取最新气象数据，就调用removeObserver(o)，**还能在运行时动态地增删布告板**：，比如说为布告板对象o设置一个“监听”时间10分钟，在10分钟内，它需要监听主题的状态变化，10分钟以后，它就不需要再监听，那么就可以通过在到达10分钟的时候调用removeObserver(o)将其从观察者列表移除即可。



## 3、总结与思考

从观察者模式的两个主角来看，主题拥有自己的一些状态(参考例子中WeatherData对象的天气数据)，而多个观察者想要获知这些状态来改变自身的状态，从而构成了一对多依赖。主题向全体观察者通知，观察者可以随时决定取消监听主题。

如果我们仔细体会本例中一下思路1到思路2的转变，会发现实现了一个**松耦合**的过程，在思路1中，主题需要关注观察者是谁，而引入观察者模式后，主题不需要知道观察者的具体类是谁，只知道观察者实现了某个接口，有新的观察者出现时，主题的代码不需要修改，二者并非紧耦合。改变主题或观察者其中一方，不会影响另外一方。

最后，本文以一条设计原则结尾。{% blockquote %}为了交互对象之间的松耦合设计而努力。{% endblockquote %} 