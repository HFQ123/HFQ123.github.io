---
title: 每日总结面试题
tags: 面试
---

有些知识点自己感觉很清楚但是不知道怎么表达，此文档用于每日总结一些面试题。



死锁的四个条件：

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。



为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：

1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
2. **破坏请求与保持条件** ：一次性申请所有的资源。
3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。



sleep和wait的区别：

Thread、Object

Wait 通常被用于线程间交互通信，与notify配合使用，sleep 通常被用于暂停执行。

调用时机：任意vs只有在sychrnoized代码块内部可以调用，否则会抛异常

wait会让获得锁的线程释放锁，而sleep不会



synchorinized关键字的理解

作用：

使用方式：修饰对象，修饰方法。

对象monitorenter、monitorexit，ASC_SYNCHRONIZED

原理： 每个对象都有一个监视器锁，获得了锁的线程...没获得锁的线程。。。。

进阶原理：锁升级过程。 jdk1.5前，以后。

另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

常见应用：保证单例对象的线程安全。

双重检查锁（+volatile）模式