---
title: 【每日更新】算法题
date: 2020-04-21 20:17:21
tags: [算法刷题,剑指Offer]
---



# 20200425 晴

## 题1[复杂链表的复制](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba)

### 做题前思路

首先要注意要求是复制结点，而不是复制引用。

其次要注意random属性。

# 20200422

## 题1 [二叉搜索树的第k个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a)

### 做题前思路

给定一棵二叉搜索树，请找出其中的第k小的结点。根据BST中序遍历结果是升序的这一性质，可以中序遍历，直到遍历到第k个结点。

### 按照此思路的代码：

```java
//中序递归，成功AC
public class Solution {
    int num;    //num表示当前中序遍历已经访问了几个元素
    TreeNode node; //node存放结果
    TreeNode KthNode(TreeNode pRoot, int k)
    {
       inorder(pRoot,k);
       return this.node;
    }
    void inorder(TreeNode node,int k){
        if(node==null){
            return;
        }
        inorder(node.left,k);
        num++;
        if(num==k){
            this.node=node;
            return;  //结束后续的访问
        }
        inorder(node.right,k);
    }
}
```

分析：就算找到了Kth结点也会遍历完整个BST。时间复杂度是O(N)

改进：可以考虑非递归实现中序遍历，这样就能在找到Kth结点后结束遍历。





## 题2 [字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720)

## 做题前思路

hashmap



## 知识点
+ LinkedHashMap和HashMap的差别
  + LinkedHashMap
  + [Hashmap遍历方法](https://www.cnblogs.com/lykbk/p/dfdfdffd34534343434.html)





## 题3 [统计一个数字在排序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2) 

### 做题前思路

+ 法1：二分查找定位该数字，再找左边和右边相等的元素个数。

+ [多种方法改进参考文章](https://www.cnblogs.com/lishanlei/p/10707678.html)
  + 最后采用的方法：因为数组中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。



```java
/**
 * @Created by hfq on 2020/4/23
 * @used to:
 */
public class Solution数字在排序数组中出现的次数 {
    public int GetNumberOfK(int [] array , int k) {
        return BinarySearch(array,(float)(k+0.5)) - BinarySearch(array,(float)(k-0.5));
    }
    //返回目标t插入array的位置
    public static int BinarySearch(int [] array , float t){
        int i = 0;
        int j = array.length-1;
        int mid = 0;
        while(i<=j){   //<= 等号不可遗漏！！
            mid = j+(i-j)/2;
            if(array[mid] > t){  //在左边查找
                j = mid-1;
            }else if(array[mid] < t){ //在右边查找
                i = mid+1;
            }else{
                //实际上不可能发生，可以和上面的else if合并
            }
        }
        return i;   //array[mid]在array[i]和array[j]中添加
    }

    public static void main(String[] args) {
//        int [] a = {3,3,3,3};
        int [] a = {3,3,3,3};
        System.out.println(BinarySearch(a, (float) 2.5));
        System.out.println(BinarySearch(a, (float) 3.5));
    }
}
```



分析：这种做法在各种情况下效率都比较高。 

当数组是：[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]，如果采用法1，效率退化成O(n),而这种方法时间复杂度还是O(lgn)级别的

---





# 20200421 

## 题1：[栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106)

### 代码：

```java
import java.util.ArrayList;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA==null||pushA.length==0)
            return true;
        int stack [] = new int[pushA.length];
        int size = 0;
        int pushIndex=0;
        stack[size++] = pushA[pushIndex++];
        int current = 0;
        while(pushIndex<pushA.length)
        {
            if(stack[size-1]!=popA[current])
            {
                stack[size++] = pushA[pushIndex++];
            }else{ 
                size--;
                current++;
            }
        }
        while (size!=0){
            if(stack[size-1]!=popA[current]) {
                return false;
            }
            else {
                size--;
                current++;
            }
        }
        if(size==0)
            return true;
        return false;
    }
}
```

### 解析：

以输入{1,2,3,4,5}，{4,5,3,2,1}为例。

借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。

 我的代码没有用JDK提供的Stack，而是用一个数组+size模拟栈。

## 题2：[二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e)
### 代码
```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        TreeLinkNode successor = null; //表示后续结点，保存返回结果
        //当这个结点有右子树，那么其后续结点必然在其右子树中的最小的元素
        if(pNode.right!=null){
            successor = pNode.right;  
            while(successor.left!=null){
                successor = successor.left;  //一直向左走找最小的元素
            }
        }else if(pNode.next != null){  //没有右子树但是有根节点
            successor = pNode;  
            while(successor.next != null && successor == successor.next.right){
                successor = successor.next; //当此结点始终是其父节点的右子树的时候，逐级找父节点
            }
            successor = successor.next;
        }
        return successor;
    }
}
```

### 解析：

求二叉树某一结点的后续结点。

![image-20200421205013742](/images/image-20200421205013742.png)

根据这个pNode结点的状态，分为三种情况求解:

+ pNode存在右子树，那么其后续结点必然在其右子树中。
  - 这是由中序遍历的定义决定的：若某节点存在右子树，那么访问完这个结点后访问的下一个结点必然是右子树中的某个结点。
  - 返回结果是 pNode.right.left.left.left.... 
+ pNode不存在右子树，但存在父节点，那么其后续结点是其祖父结点，或者是null
+ 既不存在右子树，也不存在父节点，返回null

提示：

+ 可以借助二叉树的一种特殊情况——二叉搜索树思考这题，上述代码的注释就是这样做的，表面看我们考虑的是特殊情况，但是实际上这样做对二叉树具有普遍性。

+ 另外提一下，这道题目有点坑的地方是：包含指向父结点的指针的变量名是next，不是parent，注意一下。



## 【待解决】题3:[顺时针打印矩阵](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a)

被这道题虐了很久。。

一直会忽略某些情况。



```java
package com.hfq;

import java.util.ArrayList;
public class Main {
    public static ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList <Integer> list = new ArrayList<>();
        addElementToList(matrix,0,matrix.length-1,0,matrix[0].length-1,list);
        return list;
    }

    public static void addElementToList(int [][] matrix,int rowsMin,int rowsMax,int colsMin,int colsMax,ArrayList list) {
        if(colsMax<0 && rowsMax<0){
            return;
        }

        for(int i = colsMin; i<=colsMax ; i++){ //从左往右
            list.add(matrix[rowsMin][i]);
           // System.out.println(matrix[rowsMin][i]);
        }

        if(rowsMax>rowsMin){
            for(int i = rowsMin+1; i<=rowsMax ; i++){ //从上往下
//            System.out.println("i="+i+",colsMax"+colsMax);
                list.add(matrix[i][colsMax]);
                //System.out.println(matrix[i][colsMax]);
            }
        }

        if(colsMax-1>colsMin){
            for(int i = colsMax-1; i>=colsMin ; i--){  //从右往左
                list.add(matrix[rowsMax][i]);
               // System.out.println(matrix[rowsMax][i]);
            }
        }

        if(colsMax-colsMin>=1 && colsMax > colsMin ){
            for(int i = rowsMax-1; i>=rowsMin+1 ; i--){ //从下往上
                list.add(matrix[i][colsMin]);
              //  System.out.println(matrix[i][colsMin]);
            }
        }
        addElementToList(matrix,rowsMin+1,rowsMax-1,colsMin+1,colsMax-1,list);
    }


    public static void main(String[] args) {
//        int a [][] ={{1},{2},{3},{4},{5}};
//        int a [][] ={{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};
        int a [][] ={{1,2},{3,4},{5,6},{7,8},{9,10}};
        ArrayList<Integer> integers = printMatrix(a);
        for(Integer integer:integers){
            System.out.printf(integer+",");
        }
    }

}
```



## 题4:[包含min函数的栈](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49)

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。

### 思路

一开始我的想法很简单，用一个使用一个变量记录当前的最小元素，如果新压入栈的元素更小，就更新它。

但是仔细一想，这种做法有一个问题，假如记录的最小元素出栈了，就没办法以O(1）的时间复杂度获取新的最小元素了，所以在保存最小元素的同时，有必要保存最小元素出栈后次要小的元素，同理，也要保存第三小的元素....

所以，要用一个辅助栈来保存当前的最小元素以及之前的的最小元素，栈顶就是当前栈的最小元素，栈顶元素的下一个元素就是这个元素出栈后的新的最小元素。

+ 每次压栈时，如果压入的元素小于当前最小元素，则也将其压入辅助栈，否则，则将上一个最小元素压入辅助栈。
+ 每次出栈时，弹出元素的同时也弹出辅助栈的元素。



### 知识点复习

Stack的API

+ peek()
+ size()
+ pop()
+ push()

### 代码

```java
import java.util.Stack;

public class Solution {
    public Stack <Integer> stack = new Stack<>();  //数据栈 
    public Stack <Integer> minStack = new Stack<>();; //辅助栈

    public void push(int node) {
        stack.push(node);
        if(stack.size()==1){  //现在是1，说明压栈前是0。
            minStack.push(node);
        }else{
            minStack.push(node<minStack.peek() ? node : minStack.peek());
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

### 题解

关键字 ：最小值辅助栈



## 题5 [把数组排成最小的数](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993)

没啥思路，借鉴了网上的[解法](https://blog.csdn.net/xiaoxingxing1744/article/details/84191277)，觉得很妙。

关键字：自定义比较大小的方法。

### 提示

转成字符串，自定义比较器后排序

### 知识点复习

+ int类型转成String类型
  - String.valueOf(i)
  - Integer.toString(i)
  - i+""

+ 比较字符串大小

+ 拼接字符串 （StringBuilder）

  + sb.append()
  + sb.toString()

+ 代码细节

  - Arrays.sort()

    - import java.util.Arrays;
  - Comparator
  - import java.util.Comparator;

  ```java
  new Comparator<String>() {
      @Override
          public int compare(String str1, String str2) {   //3  12  312 123
          	return 0;
      }
  }
  ```

### 代码

```java
/**
 * https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993
 * @Created by hfq on 2020/4/22
 * @used to:
 * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
 * 打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
 */
public class Solution把数组排成最小的数 {
    public static String PrintMinNumber(int [] numbers) {
        StringBuilder sb = new StringBuilder();
        String numString [] = new String[numbers.length];
        for (int i=0; i<numbers.length; i++){
            numString[i]=String.valueOf(numbers[i]); //将整数转成字符串
        }
        Arrays.sort(numString, new Comparator<String>() {
            @Override
            public int compare(String str1, String str2) {   //3  12  312 123
                return 0;
            }
        });
        for (String str : numString){
            sb.append(str);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        int[]numbers={3,32,321};
        System.out.println(PrintMinNumber(numbers));
    }
}

```



进度：25题/67题。



