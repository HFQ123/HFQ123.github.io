<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>6月每日更新-算法题 | 然后就的博客 | 飘风不终朝,骤雨不终日。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="算法刷题">
    <meta name="description" content="20200614 晴天坚持每日刷3题已经：32天。 题1 【待完善】 回文链表 请判断一个链表是否为回文链表。 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？  常规解法很简单：用到了栈保存链表的逆序状态，所以说空间复杂度是O(n)。 12345678910111213141516171819 &#x2F;&#x2F;空间复杂度O(n)，时间复杂度O(n)class Solution &amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="6月每日更新-算法题">
<meta property="og:url" content="http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/index.html">
<meta property="og:site_name" content="然后就的博客">
<meta property="og:description" content="20200614 晴天坚持每日刷3题已经：32天。 题1 【待完善】 回文链表 请判断一个链表是否为回文链表。 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？  常规解法很简单：用到了栈保存链表的逆序状态，所以说空间复杂度是O(n)。 12345678910111213141516171819 &#x2F;&#x2F;空间复杂度O(n)，时间复杂度O(n)class Solution &amp;#12">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200614212316072.png">
<meta property="og:image" content="http://hfq123.github.io/2020/06/01/images/image-20200614234205912.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200613200236645.png">
<meta property="og:image" content="http://hfq123.github.io/2020/06/01/images/image-20200612221247121.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200607153758932.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200605204055096.png">
<meta property="og:image" content="http://hfq123.github.io/2020/06/01/images/image-20200603123358618.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200602223938161.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200601234129746.png">
<meta property="article:published_time" content="2020-06-01T15:01:23.000Z">
<meta property="article:modified_time" content="2020-06-14T15:42:37.046Z">
<meta property="article:author" content="然后就">
<meta property="article:tag" content="算法刷题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hfq123.github.io/images/image-20200614212316072.png">
    
        <link rel="alternate" type="application/atom+xml" title="然后就的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/images/hfq-favcation.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/images/hfq-favicon.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">然后就</h5>
          <a href="mailto:1184586992@qq.com" title="1184586992@qq.com" class="mail">1184586992@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/HFQ123" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/aboutMe" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">6月每日更新-算法题</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">6月每日更新-算法题</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-06-01T15:01:23.000Z" itemprop="datePublished" class="page-time">
  2020-06-01
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200614-晴天"><span class="post-toc-number">1.</span> <span class="post-toc-text">20200614 晴天</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-【待完善】-回文链表"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">题1 【待完善】 回文链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-合并K个排序链表"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">题2 合并K个排序链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-【待熟练】-根据身高重建队列"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">题3 【待熟练】 根据身高重建队列</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200613-晴天"><span class="post-toc-number">2.</span> <span class="post-toc-text">20200613 晴天</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-【待改进】完全平方数"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">题1 【待改进】完全平方数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-打家劫舍"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">题2 打家劫舍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-【值得体会】-买卖股票的最佳时机"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">题3 【值得体会】 买卖股票的最佳时机</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200612-晴"><span class="post-toc-number">3.</span> <span class="post-toc-text">20200612 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-【待优化】-每日温度"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">题1 【待优化】 每日温度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-【待优化】-接雨水"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">题2 【待优化】 接雨水</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-盛最多水的容器"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">题3 盛最多水的容器</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200611-雨"><span class="post-toc-number">4.</span> <span class="post-toc-text">20200611 雨</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-把二叉搜索树转换为累加树"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">题1 把二叉搜索树转换为累加树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-【待改进】-路径总和-III"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">题2 【待改进】 路径总和 III</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-【待熟练】-相交链表"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">题3 【待熟练】 相交链表</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200610-雨"><span class="post-toc-number">5.</span> <span class="post-toc-text">20200610 雨</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-【待熟练】二叉树展开为链表"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">题1 【待熟练】二叉树展开为链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-【待解决】-寻找重复数"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">题2 【待解决】 寻找重复数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-前-K-个高频元素"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">题3 前 K 个高频元素</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题4-找到所有数组中消失的数字"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">题4 找到所有数组中消失的数字</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200609-晴"><span class="post-toc-number">6.</span> <span class="post-toc-text">20200609 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-【待熟练】-下一个较大排列"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">题1 【待熟练】 下一个较大排列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-根据中序和后序序列求二叉树"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">题2 根据中序和后序序列求二叉树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-【待熟练】3-sum"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">题3 【待熟练】3-sum</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200608-晴"><span class="post-toc-number">7.</span> <span class="post-toc-text">20200608 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-回文数"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">题1 回文数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-【待熟练】-不同的BST种数"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">题2 【待熟练】 不同的BST种数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-字符串二进制数的加法"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">题3 字符串二进制数的加法</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200607-晴"><span class="post-toc-number">8.</span> <span class="post-toc-text">20200607 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-三角形最小路径和"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">题1 三角形最小路径和</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-丑数"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">题2 丑数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-【待熟练】数据流中的中位数"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">题3 【待熟练】数据流中的中位数</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200606-晴"><span class="post-toc-number">9.</span> <span class="post-toc-text">20200606 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-汉明距离"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">题1 汉明距离</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-合并二叉树"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">题2 合并二叉树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-比特位计数"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">题3  比特位计数</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200605-多云"><span class="post-toc-number">10.</span> <span class="post-toc-text">20200605 多云</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-爬楼梯"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">题1 爬楼梯</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-格雷码"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">题2 格雷码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-反转整数"><span class="post-toc-number">10.3.</span> <span class="post-toc-text">题3 反转整数</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200604-多云"><span class="post-toc-number">11.</span> <span class="post-toc-text">20200604 多云</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-unique-paths"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">题1 unique-paths</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-unique-paths-ii"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">题2 unique-paths-ii</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-minimum-path-sum"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">题3 minimum-path-sum</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200603-雨"><span class="post-toc-number">12.</span> <span class="post-toc-text">20200603 雨</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-sqrtx"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">题1 sqrtx</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-【待优化】-跳跃游戏"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">题2 【待优化】 跳跃游戏</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-可能重复的全排列"><span class="post-toc-number">12.3.</span> <span class="post-toc-text">题3 可能重复的全排列</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200602-晴"><span class="post-toc-number">13.</span> <span class="post-toc-text">20200602 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-跳跃最少步数"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">题1 跳跃最少步数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-最大子数组（最大连续子序列）"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">题2 最大子数组（最大连续子序列）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-合法的BST"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">题3 合法的BST</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200601-晴"><span class="post-toc-number">14.</span> <span class="post-toc-text">20200601 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-二叉树中和为某一值的路径"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">题1 二叉树中和为某一值的路径</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-机器人的运动范围"><span class="post-toc-number">14.2.</span> <span class="post-toc-text">题2 机器人的运动范围</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-待解决-矩阵中的路径"><span class="post-toc-number">14.3.</span> <span class="post-toc-text">题3  待解决 矩阵中的路径</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-6月每日更新-算法题"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">6月每日更新-算法题</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-06-01 23:01:23" datetime="2020-06-01T15:01:23.000Z"  itemprop="datePublished">2020-06-01</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="20200614-晴天"><a href="#20200614-晴天" class="headerlink" title="20200614 晴天"></a>20200614 晴天</h1><p>坚持每日刷3题已经：<strong>32</strong>天。</p>
<h2 id="题1-【待完善】-回文链表"><a href="#题1-【待完善】-回文链表" class="headerlink" title="题1 【待完善】 回文链表"></a>题1 【待完善】 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h2><blockquote>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
</blockquote>
<p>常规解法很简单：用到了栈保存链表的逆序状态，所以说空间复杂度是O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//空间复杂度O(n)，时间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack &lt;Integer&gt; stack =  <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125; </span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val != stack.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶解法其实和<strong>原地反转链表</strong>的思路是一样的，不过这里不需要反转整个链表，只需要反转后半部分链表然后与前半部分链表进行比较。待解决。</p>
<h2 id="题2-合并K个排序链表"><a href="#题2-合并K个排序链表" class="headerlink" title="题2 合并K个排序链表"></a>题2 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></h2><blockquote>
<p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
</blockquote>
<p>基本思路:两两合并，list[0]不断“滚雪球”，和其他k-1个链表合并，合并后，把其他链表吸收到list[0]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">            <span class="comment">//两两合并</span></span><br><span class="line">            lists[<span class="number">0</span>] =mergeTwoList(lists[<span class="number">0</span>],lists[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原地合并两个排序链表h1,h2，时间复杂度O(m+n),m+n分别为两个链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoList</span><span class="params">(ListNode h1,ListNode h2)</span></span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>),tail = dummy;		</span><br><span class="line">        <span class="keyword">int</span> h1Value,h2Value;</span><br><span class="line">        <span class="keyword">while</span>(h1!=<span class="keyword">null</span> || h2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            h1Value = h1==<span class="keyword">null</span>?Integer.MAX_VALUE:h1.val;</span><br><span class="line">            h2Value = h2==<span class="keyword">null</span>?Integer.MAX_VALUE:h2.val;</span><br><span class="line">            <span class="keyword">if</span>(h1Value&lt;=h2Value)&#123;</span><br><span class="line">                tail.next = h1;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                h1 = h1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tail.next = h2;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对合并两个链表的函数代码稍加改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个排序链表h1,h2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoList</span><span class="params">(ListNode h1,ListNode h2)</span></span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>),tail = dummy;</span><br><span class="line">    <span class="keyword">int</span> h1Value,h2Value;</span><br><span class="line">    <span class="keyword">while</span>(h1!=<span class="keyword">null</span> &amp;&amp; h2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.val&lt;=h2.val)&#123;</span><br><span class="line">            tail.next = h1;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            h1 = h1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = h2;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            h2 = h2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.next = h1==<span class="keyword">null</span>?h2:h1;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度：O(n) ，时间复杂度不太好分析： 可以参考下图（截自LeetCode官方题解）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200614212316072.png" alt="此题的时间复杂度分析" title="">
                </div>
                <div class="image-caption">此题的时间复杂度分析</div>
            </figure>

<p>思路2：优先级队列（最小堆）</p>
<p>注意，不需要把所有结点一次性加入到优先级队列，只需要加入每个<strong>非空链表</strong>的首结点即可。</p>
<p>时间复杂度<em>O</em>(n*logk) ,这里的n是结点的总个数，因为此优先级队列最大大小为k，所以说插入1个元素的时间复杂度是logk。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span> || lists.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>),tail = dummy,tmp;</span><br><span class="line">        <span class="comment">//优先级队列,最小堆，这个堆的大小初始化为k即可</span></span><br><span class="line">        PriorityQueue &lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length,(node1,node2)-&gt;node1.val-node2.val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i]!=<span class="keyword">null</span>)&#123; <span class="comment">//如果不加这个判断，通过不过[[]]这个测试用例（也就是说通不过有空的）</span></span><br><span class="line">                queue.offer(lists[i]);  <span class="comment">//优先级队列插入元素的时间复杂度是O(logk)，k</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            tmp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(tmp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(tmp.next);</span><br><span class="line">            &#125;</span><br><span class="line">            tail.next = tmp;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-【待熟练】-根据身高重建队列"><a href="#题3-【待熟练】-根据身高重建队列" class="headerlink" title="题3 【待熟练】 根据身高重建队列"></a>题3 【待熟练】 <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></h2><blockquote>
<p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p>
<p>注意：<br>总人数少于1100人。</p>
<p>示例</p>
<p>输入:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>输出:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>
</blockquote>
<p>解此题的关键是理解：如果高的人已经排好了，随着矮的人的加入，一定不会影响高的人的相对顺序。</p>
<p>如三个高的人排列好了：如[7,0],[7,1],[7,2]，这时候再来了一个[6,1]，则把它插入到[7,0]的后面，队列变成了：[7,0],[6,1],[7,1]，[7,2] ，<strong>可以看到[6,1]的加入对于原来高度为7的人的相对位置不会产生任何影响（性质①），而且[6,1]插入的位置就是原队列索引为1的地方。（性质②）</strong></p>
<p>所以可以用贪心的方法去做，先将队列从高到矮排列（如果高度也就是h相同的情况，按照k升序）：</p>
<p>[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]。</p>
<p>然后一个个处理:</p>
<p>插入第一个：[7,0]</p>
<p>插入第二个：[7,0],[7,1]</p>
<p>插入第三个：[7,0],[6,1],[7,1],</p>
<p>插入第四个：[5,0],[7,0],[6,1],[7,1],</p>
<p>插入第五个：[5,0],[7,0],[5,2],[6,1],[7,1]</p>
<p>插入第六个：[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]。</p>
<p>基于此思路， 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="keyword">if</span>(people == <span class="keyword">null</span> || people.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//按照h降序，如果h相同，按照k升序</span></span><br><span class="line">        Arrays.sort(people,(o1,o2)-&gt;(o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o1[<span class="number">1</span>] - o2[<span class="number">1</span>] : o2[<span class="number">0</span>] - o1[<span class="number">0</span>])); <span class="comment">//妙用lambda表达式。o1,o2都是int类型的数组</span></span><br><span class="line">        List &lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            res.add(people[i][<span class="number">1</span>],people[i]);	<span class="comment">//利用了上面分析的性质②</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份代码是参考了题解，有很高的技巧性：</p>
<ul>
<li>对二维数组排序，[h,k]，按h降序，如果h相同的情况下，按k升序。这里巧妙地利用了lambda表达式指定了比较器。</li>
<li>最后把链表转成数组，res.toArray，尤其注意其参数，如果不写参数，会报错：Object[] cannot be converted to int[],[]。</li>
</ul>
<p>时间、空间复杂度分析：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../images/image-20200614234205912.png" alt="image-20200614234205912" title="">
                </div>
                <div class="image-caption">image-20200614234205912</div>
            </figure>

<h1 id="20200613-晴天"><a href="#20200613-晴天" class="headerlink" title="20200613 晴天"></a>20200613 晴天</h1><p>坚持每日刷3题已经：<strong>31</strong>天。</p>
<p>今天刷的题的tag都是DP。</p>
<h2 id="题1-【待改进】完全平方数"><a href="#题1-【待改进】完全平方数" class="headerlink" title="题1 【待改进】完全平方数"></a>题1 【待改进】<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></h2><blockquote>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例 1:</strong></p>
<p>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.</p>
<p><strong>示例 2:</strong></p>
<p>输入: n = 13<br>输出: 2<br>解释: 13 = 4 + 9.</p>
</blockquote>
<p>略暴力的解决。记f(i)为求组成和为i所需要的完全平方数的最少个数的值，比如说求f(15)，其求解过程是这样的：</p>
<p>f(15) = min{f(14) + f(1), f(13) + f(2)，f(12)+f(2)……..f(8)+f(7)}</p>
<p>这道题和找零钱那题比较像，不能直接想当然地认为贪心地找最大的钱，对应到这题，不是找离自己最近的完全平方数，比如说n=12时，发现比12小的最大的完全平方数是9（f(9)=1），如果这时候选择了9，还需要选择3个1，共四个完全平方数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待提升</span></span><br><span class="line"><span class="comment">//时间复杂度O(n^2)，空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = (<span class="keyword">int</span>)Math.sqrt(n); 	<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(s*s == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i]表示组成和为i的完全平方数的最少个数</span></span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];    </span><br><span class="line">        <span class="comment">//组成和为1的完全平方数的最少个数是1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sqrt = (<span class="keyword">int</span>)Math.sqrt(i);</span><br><span class="line">            <span class="keyword">if</span>(sqrt*sqrt == i)&#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmpMin = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i-j) <span class="keyword">continue</span>;</span><br><span class="line">                tmpMin = Math.min(tmpMin,dp[j]+dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = tmpMin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-打家劫舍"><a href="#题2-打家劫舍" class="headerlink" title="题2 打家劫舍"></a>题2 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h2><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>tag:动态规划。</p>
<p>主要思路。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200613200236645.png" alt="image-20200613200236645" title="">
                </div>
                <div class="image-caption">image-20200613200236645</div>
            </figure>

<p><strong>偷不偷现在这个，这是个问题。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] yes =<span class="keyword">new</span> <span class="keyword">int</span> [nums.length]; <span class="comment">//偷当前房屋的最大值</span></span><br><span class="line">        <span class="keyword">int</span> [] no = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length]; <span class="comment">//不偷当前房屋的最大值</span></span><br><span class="line">        yes[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//偷当前房屋,肯定不能偷上一个房屋</span></span><br><span class="line">            yes[i] = no[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">            <span class="comment">//不偷当前房屋，既可以偷上一个房屋，又可以不偷上一个房屋</span></span><br><span class="line">            no[i] = Math.max(yes[i-<span class="number">1</span>],no[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(yes[nums.length-<span class="number">1</span>],no[nums.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度都是O(n)，提交后发现时间复杂度超过100%，空间复杂度超过7%，仔细观察会发现，<strong>这题和求斐波那契数列的第n个数一样，无需用数组来保存中间状态，只要用临时变量就可以</strong>，这样做空间复杂度就是O(1)，其优化原理就是 <a href="https://blog.csdn.net/baijiuhao/article/details/87779326" target="_blank" rel="noopener"><strong>滚动数组</strong></a>。</p>
<p>改进后，空间复杂度是O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>  yes = <span class="number">0</span>; <span class="comment">//偷当前房屋</span></span><br><span class="line">        <span class="keyword">int</span>  no = <span class="number">0</span>; <span class="comment">//不偷当前房屋</span></span><br><span class="line">        <span class="keyword">int</span> oldYes,oldNo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//偷当前房屋,肯定不能偷上一个房屋</span></span><br><span class="line">            oldYes = yes;</span><br><span class="line">            oldNo = no;</span><br><span class="line">            yes = oldNo + nums[i];</span><br><span class="line">            no = Math.max(oldYes,oldNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(yes,no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-【值得体会】-买卖股票的最佳时机"><a href="#题3-【值得体会】-买卖股票的最佳时机" class="headerlink" title="题3 【值得体会】 买卖股票的最佳时机"></a>题3 【值得体会】 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></h2><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
</blockquote>
<p>暴力法：时间复杂度O(n^2)，空间复杂度O(1)</p>
<p>基本思路：先确定价格数组的 i 指针表示购入时间，j指针表示可能的售出时间（j&gt;i)，j每次都选择i 后面所有最大的值。</p>
<p>我这里是把今天作为购入时间点来考虑。 </p>
<table>
<thead>
<tr>
<th align="left">每日价格</th>
<th>7</th>
<th>1</th>
<th>5</th>
<th>3</th>
<th>6</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td align="left">今天起最大的价格</td>
<td>7</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td align="left">差价</td>
<td>0</td>
<td><strong>5</strong></td>
<td>1</td>
<td>3</td>
<td>-2</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++)&#123; <span class="comment">//当前时间购入，prices[i]就是购入价</span></span><br><span class="line">            <span class="keyword">int</span> max = prices[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;prices.length;j++)&#123;</span><br><span class="line">                max = Math.max(max,prices[j]); <span class="comment">//找后面日子的最高价</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,max-prices[i]);  <span class="comment">//max是后面的最高价，price[i]是购入价</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">每日价格 prices[i]</th>
<th>7</th>
<th>1</th>
<th>5</th>
<th>3</th>
<th>6</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td align="left">今天起最大的价格dp[i]</td>
<td>7</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td align="left">差价 dp[i] - prices[i]</td>
<td>0</td>
<td><strong>5</strong></td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>发现差价5是最大的，也就是说最大利润是5。</p>
<p>昨天学了<strong>单调栈</strong>，思考的时候意识到好像可以用单调栈来求dp[]数组。</p>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length] ;</span><br><span class="line">        Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();  <span class="comment">//单调递增栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =prices.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || stack.peek() &lt; prices[i])&#123;</span><br><span class="line">                stack.push(prices[i]);</span><br><span class="line">                dp[i] = prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            dp[i] = stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">             ans = Math.max(ans,dp[i]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不过很快，我发现了用单调栈这是多此一举。</strong></p>
<p>为什么呢？因为完全可以用一个变量来代替递增栈。改进如下：</p>
<p>时间复杂度O(n)，空间复杂度O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length] ;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =prices.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; max)&#123;  </span><br><span class="line">                dp[i] = max;	</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//说明了这天后的所有价格都不比今天高</span></span><br><span class="line">                max = prices[i];</span><br><span class="line">                dp[i] = prices[i];	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">             ans = Math.max(ans,dp[i]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我自己想到的最优解了，不过提交后，时间超60%，空间超5%，我意识到还有优化的空间。</p>
<p><strong>看了题解，最优解法是O(n)的时间复杂度和O(1）的空间复杂度</strong>。题解和我的思考角度略微有些不一样，不过还是收到启发，做了一些优化：</p>
<p>首先，可以直接在当前循环计算利益的最大值，没必要用两个循环，这一步对时间复杂度有优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length] ;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span> ,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =prices.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; max)&#123;</span><br><span class="line">                dp[i] = max;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = prices[i];</span><br><span class="line">                dp[i] = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,dp[i]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次，我又意识到了，dp数组是完全没必要的，中间状态没必要用数组存。</p>
<p>于是有了最后的优化：O(n),O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sell=<span class="number">0</span>; <span class="comment">//sell表示最理想的售价</span></span><br><span class="line">        <span class="comment">//prices[i]作为购入价</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =prices.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sell = prices[i];		 <span class="comment">//最佳售价初始化为购入价</span></span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; max)&#123;</span><br><span class="line">                sell = max;			 <span class="comment">//最佳售价是今天之后的最高价格</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = prices[i];    <span class="comment">//更新前面日子的最佳售价。</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,sell-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>By the way，</p>
<p>ps: 以上的考虑都是把今天作为购入时间来考虑，我们想要售出时间点的价格越高越好，也就是说今天之后的最高价格是最优售出价格！</p>
<p>如果把今天作为售出时间来考虑，我们希望购入时间点的价格越低越好，这里的dp[i]是可以理解成为是最优的购入价。</p>
<table>
<thead>
<tr>
<th align="left">每日价格 prices[i]</th>
<th>7</th>
<th>1</th>
<th>5</th>
<th>3</th>
<th>6</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td align="left">今天以及之前最低的价格dp[i]</td>
<td>7</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td align="left">差价price[i] - dp[i]</td>
<td>0</td>
<td><strong>5</strong></td>
<td>4</td>
<td>2</td>
<td>0</td>
<td>3</td>
</tr>
</tbody></table>
<p>代码大同小异，只是两种思考方式不一样而已，题解给的就是这种思考方式。</p>
<h1 id="20200612-晴"><a href="#20200612-晴" class="headerlink" title="20200612 晴"></a>20200612 晴</h1><p>坚持每日刷3题已经：<strong>30</strong>天。</p>
<h2 id="题1-【待优化】-每日温度"><a href="#题1-【待优化】-每日温度" class="headerlink" title="题1 【待优化】 每日温度"></a>题1 【待优化】 <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></h2><blockquote>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
</blockquote>
<p>暴力解法O(n^2)，能AC，代码略。</p>
<p>看题解，说这道题能用<strong>单调栈</strong>解决，上次接触单调栈概念是在雨水堆积那题，当时没看懂，所以计划今天先学单调栈，然后解出这几道相关题。</p>
<p><a href="https://www.cnblogs.com/grandyang/p/8887985.html" target="_blank" rel="noopener">介绍单调栈的博客</a>，此博客很形象地介绍了生成单调栈的过程：把比自己元素值大（小）的元素赶出栈，然后自己进入栈。</p>
<p>博客还介绍了一个使用单调栈的经典场景：</p>
<blockquote>
<p><strong>单调递增栈可以找到从当前元素开始向左第一个比当前数字小的元素</strong>。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为 1，4，5。</p>
<p><strong>单调递减栈可以找到从当前元素开始向左第一个比当前数字大的元素</strong>。这里就不举例说明了，同样的道理，大家可以自行验证一下。</p>
</blockquote>
<p>受到这段话的启发，对比这题，其实应用场景是一致的：只不过这题是需要找到<strong>从当前元素开始向右找到第一个比当前数字大的元素</strong>(的下标与当前元素的相减得到的值)。所以从右向左遍历，构建<strong>单调递减栈</strong>解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        Stack&lt;Integer&gt; indexStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//从右到左处理，递增栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=T.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!indexStack.isEmpty() &amp;&amp; T[indexStack.peek()] &lt;= T[i] )&#123; <span class="comment">//把比当前元素小的元素都赶出栈</span></span><br><span class="line">                indexStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时栈顶元素就是比当前元素大的那个元素</span></span><br><span class="line">            <span class="keyword">if</span>(indexStack.isEmpty())&#123;</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = indexStack.peek()-i;</span><br><span class="line">            &#125;</span><br><span class="line">            indexStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度都是O(n)。</p>
<p>执行用时 :25 ms, 在所有 Java 提交中击败了50.54%的用户</p>
<p>内存消耗 :47.5 MB, 在所有 Java 提交中击败了6.45%的用户</p>
<p>but从结果看，提交了效率好像还是不太行，官方题解如下，待消化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temperature = T[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">                ans[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="题2-【待优化】-接雨水"><a href="#题2-【待优化】-接雨水" class="headerlink" title="题2 【待优化】 接雨水"></a>题2 【待优化】<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener"> 接雨水</a></h2><blockquote>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</blockquote>
<p>暴力解法O(n^2)。</p>
<p>暴力法的基本思路：当前柱子的储水量取决于左右两边最高的柱子高度，左右两边分别最高的柱子中较矮的那个柱子减去当前柱子的高度就是这个柱子的储水量，注意，这个值可能是负数（左右两边）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax=<span class="number">0</span>,rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;height.length; i++)&#123;</span><br><span class="line">            leftMax = <span class="number">0</span>;</span><br><span class="line">            rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m&lt;i;m++)&#123;</span><br><span class="line">                leftMax = Math.max(leftMax,height[m]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n = i+<span class="number">1</span>;n&lt;height.length;n++)&#123;</span><br><span class="line">                rightMax = Math.max(rightMax,height[n]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = Math.min(leftMax,rightMax)-height[i];</span><br><span class="line">            res += tmp&gt;<span class="number">0</span>?tmp:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="题3-盛最多水的容器"><a href="#题3-盛最多水的容器" class="headerlink" title="题3 盛最多水的容器"></a>题3 <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></h2><blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
</blockquote>
<p>tag:双指针。</p>
<p>暴力法：O(n^2)。</p>
<p>双指针：O(n)。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../images/image-20200612221247121.png" alt="image-20200612221247121" title="">
                </div>
                <div class="image-caption">image-20200612221247121</div>
            </figure>

<p>移动双指针的规则：i 和 j 围起来的面积区域是(j-i)*min(A[i],A[j])，发现此时A[i]&lt;A[j],所以i指针往前移一步，也就是说谁矮谁移动。</p>
<p><strong>为什么从两边的双指针走到中间可以实现</strong>值得思考。</p>
<p>这样做的确会遗漏一些组合，由于i移动到了i’，比如说我在上图里画出来的<strong>i 和 j’</strong>围起来的区域的面积就不会被计算到 ！乍一看，j’的高度比j高，但是j到i的宽度更大，所以由ij和ij‘两个组合围成的面积大小似乎不能确定（一个高度大宽度小，另一个高度小宽度大）。但是仔细想，ij’的面积必然比ij小，因为j’虽然比j高，但是i和j’受限于低的那个柱子，也就是i。图上我红色加粗画出的矩形就是ij组合和ij’组合围成的面积差。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            area = Math.max(area,Math.min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="20200611-雨"><a href="#20200611-雨" class="headerlink" title="20200611 雨"></a>20200611 雨</h1><p>坚持每日刷3题已经：<strong>29</strong>天。</p>
<p>这几天都晚睡晚起，有点发懵，今天开始早点睡，恢复学习状态，并开始投递实习和提前批的简历。</p>
<h2 id="题1-把二叉搜索树转换为累加树"><a href="#题1-把二叉搜索树转换为累加树" class="headerlink" title="题1 把二叉搜索树转换为累加树"></a>题1 <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h2><blockquote>
<p> 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
</blockquote>
<p>加上所有比它大的结点的结点值，也就是所有中序遍历在该节点后面的结点值。</p>
<p>所以一个思路是先获取中序遍历的序列，然后将其序列反转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root,list);		<span class="comment">//获取中序遍历序列</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;			</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = list.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span> ; i--)&#123;	<span class="comment">//从最大元素开始倒序遍历，加上sum</span></span><br><span class="line">            <span class="keyword">int</span> tmp = list.get(i).val;</span><br><span class="line">            list.get(i).val += sum;</span><br><span class="line">            sum += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root,ArrayList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left,list);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inorder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的解法：一步到位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorderReverse(root);       </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历（左根右）的“倒序”遍历：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderReverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorderReverse(root.right);     <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">int</span> tmp = root.val; </span><br><span class="line">        root.val += sum;                <span class="comment">//根</span></span><br><span class="line">        sum += tmp;</span><br><span class="line">        inorderReverse(root.left);      <span class="comment">//左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-【待改进】-路径总和-III"><a href="#题2-【待改进】-路径总和-III" class="headerlink" title="题2 【待改进】 路径总和 III"></a>题2 【待改进】 <a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></h2><blockquote>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
</blockquote>
<p>我的做法比较暴力，就是根据定义来做。</p>
<p>以下代码框架和<strong>树的子结构</strong>那题一致。</p>
<p>时间复杂度应该是O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        pathSumFromRoot(root,sum);</span><br><span class="line">        <span class="comment">//这两行代码是遍历每个结点分别计数</span></span><br><span class="line">        pathSum(root.left,sum);     </span><br><span class="line">        pathSum(root.right,sum);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathSumFromRoot</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root.val == sum) cnt++;    <span class="comment">//注意，如果直接return，这样做会遗漏 1-&gt; -1 -&gt;2 -&gt;-2 = 0的路径,因为在1-&gt; -1 = 0 就退出了</span></span><br><span class="line">        pathSumFromRoot(root.left,sum-root.val);</span><br><span class="line">        pathSumFromRoot(root.right,sum-root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-【待熟练】-相交链表"><a href="#题3-【待熟练】-相交链表" class="headerlink" title="题3 【待熟练】 相交链表"></a>题3 【待熟练】 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h2><blockquote>
<p>编写一个程序，找到两个单链表相交的起始节点。如果不相交，返回空。</p>
</blockquote>
<p>简单题，一次过。</p>
<p>执行用时 :1 ms, 在所有 Java 提交中击败了99.97%的用户</p>
<p>内存消耗 :42.9 MB, 在所有 Java 提交中击败了61.90%的用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：我们通常做这种题的思路是设定两个指针分别指向两个链表头部，一起向前走直到其中一个到达末端，另一个与末端距离则是两链表的 长度差。再通过长链表指针先走的方式消除长度差，最终两链表即可同时走到相交点。</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>,lengthB = <span class="number">0</span>;</span><br><span class="line">        ListNode pA = headA,pB= headB;</span><br><span class="line">        <span class="comment">//O(m)</span></span><br><span class="line">        <span class="keyword">while</span>(pA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//O(n)</span></span><br><span class="line">        <span class="keyword">while</span>(pB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pA = headA;</span><br><span class="line">        pB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">            <span class="comment">//pA先走 lengthA-lengthB步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; lengthA-lengthB;i++)&#123;</span><br><span class="line">                pA = pA.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//pB先走 lengthB-lengthA步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; lengthB-lengthA;i++)&#123;</span><br><span class="line">                pB = pB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pA==pB) <span class="keyword">break</span>;	<span class="comment">//注意比较的是pA和pB的引用，而不是比较pA和pB对应的值</span></span><br><span class="line">            pA=pA.next;</span><br><span class="line">            pB=pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完就感觉我的代码好像啰嗦了一点，想看看有没有什么更好的办法，结果果然，有一个很骚气的解法：</p>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/jiao-ni-yong-lang-man-de-fang-shi-zhao-dao-liang-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/jiao-ni-yong-lang-man-de-fang-shi-zhao-dao-liang-2/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode pa = headA,pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)&#123; <span class="comment">//如果有相交结点，会找到相交结点，如果没有相交结点，pa、pb也必然会在最后同时走到null</span></span><br><span class="line">            pa = pa==<span class="keyword">null</span>?headB:pa.next;</span><br><span class="line">            pb = pb==<span class="keyword">null</span>?headA:pb.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这要是面试，写出下面这个解法不光逼格高，而且会极其节省时间。</p>
<h1 id="20200610-雨"><a href="#20200610-雨" class="headerlink" title="20200610 雨"></a>20200610 雨</h1><p>坚持每日刷3题已经：<strong>28</strong>天。</p>
<h2 id="题1-【待熟练】二叉树展开为链表"><a href="#题1-【待熟练】二叉树展开为链表" class="headerlink" title="题1 【待熟练】二叉树展开为链表"></a>题1 【待熟练】<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></h2><blockquote>
<p>给定一个二叉树，原地将它展开为一个单链表。</p>
<p>例如，给定二叉树</p>
<p>​    1</p>
<p>   / <br>  2   5<br> / \   <br>3   4   6<br>将其展开为：</p>
<p>1<br> <br>  2<br>   <br>    3<br>     <br>      4<br>       <br>        5<br>         <br>          6</p>
</blockquote>
<p>根据观察给出的示例，是将前序遍历的结果串成一条单向链表，且是用结点的右指针指向链表的下一结点。</p>
<p>所以思路可以是：用迭代法求出二叉树的前序遍历序列，同时访问时将一个个结点串起来，这样做，时间、空间复杂度都是O(n)，一开始我觉得这种空间复杂度是O（n）的算法不满足”原地展开“的要求，但是后来又看到有人说不新建结点、在原结点基础上修改指针就是原地算法。同时，又从别处了解到：</p>
<blockquote>
<p>原地算法（in-place algorithm）：只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地”进行的，是节省存储的算法。<br>非原地算法（not-in-place）：需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元。算法临时占用空间是考虑算法空间复杂度时主要考虑的部分。相比于随着问题输入规模扩大而扩大的非原地算法，原地算法是更加简洁高效的算法（仅考虑空间复杂度时）。</p>
</blockquote>
<p>由于此算法需要O(n)级别的栈空间，所以好像也不符合原地算法的定义？</p>
<p>同样的，leetcode很多答案给出的递归解法，这也会开辟虚拟机的栈空间，<strong>这里很迷惑。</strong></p>
<p>思路：<strong>前序遍历递归。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         TreeNode oldRight = root.right;    <span class="comment">//记录原来的右孩子</span></span><br><span class="line">         root.right = root.left;</span><br><span class="line">         root.left = <span class="keyword">null</span>;</span><br><span class="line">         TreeNode rightMost = root;			<span class="comment">//注意这里要把原来的右孩子转移到左子树的最右元素的右边，否则右子树就丢了</span></span><br><span class="line">         <span class="keyword">while</span>(rightMost.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            rightMost = rightMost.right;</span><br><span class="line">         &#125;</span><br><span class="line">         rightMost.right = oldRight;</span><br><span class="line">         <span class="comment">// 左子树为空了，不用再操作flatten(root.left);</span></span><br><span class="line">         flatten(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的递归可以改写成迭代写法，这样我觉得才是符合原地算法的要求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode oldRight = root.right;    <span class="comment">//记录原来的右孩子</span></span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode rightMost = root;			<span class="comment">//注意这里要把原来的右孩子转移到左子树的最右元素的右边，否则右子树就丢了</span></span><br><span class="line">            <span class="keyword">while</span>(rightMost.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          		 rightMost = rightMost.right;</span><br><span class="line">            &#125;</span><br><span class="line">            rightMost.right = oldRight;</span><br><span class="line"></span><br><span class="line">            root = root.right; 	<span class="comment">//相当于上面的递归写法。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-【待解决】-寻找重复数"><a href="#题2-【待解决】-寻找重复数" class="headerlink" title="题2 【待解决】 寻找重复数"></a>题2 【待解决】 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></h2><blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:</p>
<p>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:</p>
<p>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p>
<p>1、不能更改原数组（假设数组是只读的）。 》不能hashset排序<br>2、只能使用额外的 O(1) 的空间。                  》不能hashset<br>3、时间复杂度小于 O(n2) 。                            》不能暴力，暴力解法O（n^2)<br>4、<strong>数组中只有一个重复的数字，但它可能不止重复出现一次。</strong></p>
</blockquote>
<p>注意第4点说明，不然可以直接根据等差数列公式求和，再减去当前数列的和。</p>
<p>二分查找算法+抽屉原理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap &lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//key是数字,value该数字出现频率，O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转key-value，O(m), m为n个元素中不重复元素个数，m必然不大于n</span></span><br><span class="line">        <span class="comment">//key是频率,value是该频率对应的数字</span></span><br><span class="line">        HashMap &lt;Integer,Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            map2.put(map.get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//O(mlogk)，m必然不大于n</span></span><br><span class="line">        Queue &lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue &lt;&gt;(k); <span class="comment">//最小堆，求top k</span></span><br><span class="line">        <span class="keyword">for</span>(Integer key : map2.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size()&lt;k)&#123;</span><br><span class="line">                queue.offer(key);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后堆里留下来的就是top k 的频率，而我们要求的是该频率对应的数字。</span></span><br><span class="line">        ArrayList &lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            res.add(map2.get(queue.poll()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-前-K-个高频元素"><a href="#题3-前-K-个高频元素" class="headerlink" title="题3 前 K 个高频元素"></a>题3 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></h2><blockquote>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li><strong>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</strong></li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
</blockquote>
<p>一开始的做法：有误，比如[1,2],2，map是{(1,1),(2,1)}，map2:{(2,1)} （频率相同的元素被覆盖了！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap &lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//key是数字,value该数字出现频率，O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;   </span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转key-value，O(m), m为n个元素中不重复元素个数，m必然不大于n</span></span><br><span class="line">        <span class="comment">//key是频率,value是该频率对应的数字  </span></span><br><span class="line">        ！！！！！！！这里有错</span><br><span class="line">        HashMap &lt;Integer,Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            map2.put(map.get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//O(mlogk)，m必然不大于n</span></span><br><span class="line">        Queue &lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue &lt;&gt;(k); <span class="comment">//最小堆，求top k</span></span><br><span class="line">        <span class="keyword">for</span>(Integer key : map2.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &lt; k)&#123;</span><br><span class="line">                queue.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">            ！！！！这里也有错 要和堆顶元素比较</span><br><span class="line">            <span class="keyword">else</span>&#123;		</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后堆里留下来的就是top k 的频率，而我们要求的是该频率对应的数字。</span></span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            res[i] = map2.get(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确代码如下（巧妙利用了比较器）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap &lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//key是数字,value该数字出现频率，O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;   </span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//O(mlogk)，m必然不大于n</span></span><br><span class="line">        Queue &lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue &lt;&gt;(k,(i1,i2)-&gt;map.get(i1)-map.get(i2)); <span class="comment">//最小堆，求top k</span></span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &lt; k)&#123;</span><br><span class="line">                queue.offer(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(key) &gt; map.get(queue.peek()) )&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后堆里留下来的就是top k 的频率，而我们要求的是该频率对应的数字。</span></span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            res[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他思路：排序，同样用比较器。</p>
<h2 id="题4-找到所有数组中消失的数字"><a href="#题4-找到所有数组中消失的数字" class="headerlink" title="题4 找到所有数组中消失的数字"></a>题4 <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a></h2><blockquote>
<p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
</blockquote>
<p>使用额外空间（标记数组）的做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            visited[nums[i]-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-de-shu-zi-2/" target="_blank" rel="noopener">官方题解</a>，解锁一个很妙的方法——原地哈希，不适用额外空间，修改原数组就能解决。</p>
<p>不过要注意这种做法只有在某种限制下才能做，  比如这题1 ≤ a[i] ≤ n。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            hash = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[hash]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[hash] = -nums[hash];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="20200609-晴"><a href="#20200609-晴" class="headerlink" title="20200609 晴"></a>20200609 晴</h1><p>坚持每日刷3题已经：<strong>27</strong>天。</p>
<h2 id="题1-【待熟练】-下一个较大排列"><a href="#题1-【待熟练】-下一个较大排列" class="headerlink" title="题1 【待熟练】 下一个较大排列"></a>题1 【待熟练】 <a href="https://www.nowcoder.com/practice/f0069cfcd42649e3b6b0c759fae8cde6?tpId=46&&tqId=29148&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">下一个较大排列</a></h2><blockquote>
<p>实现函数next permutation（下一个排列）：将排列中的数字重新排列成字典序中的下一个更大的排列。将排列中的数字重新排列成字典序中的下一个更大的排列。</p>
<p>如果不存在这样的排列，则将其排列为字典序最小的排列（升序排列）</p>
<p>需要使用原地算法来解决这个问题，不能申请额外的内存空间</p>
<p>下面有机组样例，左边是输入的数据，右边是输出的答案</p>
<p>1,2,3→1,3,2<br>3,2,1→1,2,3<br>1,1,5→1,5,1</p>
</blockquote>
<p>做的时候多考虑几位数的测试用例，如5 7 6 4</p>
<p>参考题解：<a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/</a></p>
<p>1，2，3，8，<strong>5</strong>，<strong>7</strong>，6，4</p>
<p>目标：设置一指针从后往前，当存在下标i满足a[i] &gt; a[i-1] 的时候停下（本例中a[i]=7的时候停下）。由于i指针的运动规律，易知当i停下的时候，在区间[i,a.length)的元素是降序排列的，我们要找到这部分的第一个比a[i-1]大的元素（这里是6），然后交换这个元素和a[i-1]的位置，得到：</p>
<p>1，2，3，8，6，4，6，7</p>
<p>1，2，3，8，<strong>6</strong>，7，<strong>5</strong>，4</p>
<p>然后，将区间[i,a.length)这一部分元素按照从小到大排列（原来是从大到小排列），在本例中，也就是7,5,4排列成4,5,7。</p>
<p>最后得到结果：</p>
<p>1，2，3，8，<strong>6，4，5，7</strong></p>
<p>我是先反转，然后再交换位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( i = num.length-<span class="number">1</span>; i&gt;=<span class="number">1</span> ; i--)&#123;</span><br><span class="line">             <span class="keyword">if</span>(num[i] &gt; num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出循环有两种可能：最后i的下标指向0（如果始终不满足a[i]&gt;a[i-1]）或者是第一个指向a[i]&gt;a[i-1]的元素</span></span><br><span class="line">        <span class="comment">//下一个for循环完成反转[i,num.length)的元素</span></span><br><span class="line">        <span class="keyword">int</span> end = num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;end; j++)&#123; <span class="comment">//注意j&lt;end这个条件</span></span><br><span class="line">            swap(num,j,end);</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;num.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j]&gt;num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                swap(num,i-<span class="number">1</span>,j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-根据中序和后序序列求二叉树"><a href="#题2-根据中序和后序序列求二叉树" class="headerlink" title="题2 根据中序和后序序列求二叉树"></a>题2 <a href="">根据中序和后序序列求二叉树</a></h2><p>递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span> <span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder,postorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求中序序列inorder[i1..j1]和后序序列postorder[i2...j2]的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> [] postorder,<span class="keyword">int</span> i1,<span class="keyword">int</span> j1,<span class="keyword">int</span> i2 ,<span class="keyword">int</span> j2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i1&gt;j1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//postorder[j2]就是根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[j2]);</span><br><span class="line">        <span class="keyword">int</span> i,ri = i2-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = i1; i&lt; j1; i++,ri++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == postorder[j2])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树的中序序列是inorder[i1..i-1],后序是postorder[i2..ri]</span></span><br><span class="line">        <span class="comment">//右子树的中序序列是inorder[i+1..j1],后序是postorder[ri+1..j2-1]</span></span><br><span class="line">        root.left = buildTree(inorder,postorder,i1,i-<span class="number">1</span>,i2,ri);</span><br><span class="line">        root.right = buildTree(inorder,postorder,i+<span class="number">1</span>,j1,ri+<span class="number">1</span>,j2-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-【待熟练】3-sum"><a href="#题3-【待熟练】3-sum" class="headerlink" title="题3 【待熟练】3-sum"></a>题3 【待熟练】<a href="https://www.nowcoder.com/practice/345e2ed5f81d4017bbb8cc6055b0b711?tpId=46&&tqId=29163&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">3-sum</a></h2><blockquote>
<p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。</p>
<p>注意：</p>
<ol>
<li>三元组（a、b、c、d）中的元素必须按非降序排列。（即a≤b≤c）</li>
<li>解集中不能包含重复的三元组。</li>
</ol>
<p>例如，给定的数组 S = {-1 0 1 2 -1 -4},↵↵    解集为：↵    (-1, 0, 1)↵    (-1, -1, 2)</p>
</blockquote>
<p>先排序，然后选取每个数字作为base，-base就是剩下两个数的和的目标，这两个数字用双指针定位！</p>
<p>时间复杂度是：排序：O(n*log(n)) + O(n^2)，所以时间复杂度可看作是O(n^2)。</p>
<p>注意处理重复的结果！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; num[i]==num[i-<span class="number">1</span>]) <span class="keyword">continue</span>;	<span class="comment">//如果重复，直接跳过</span></span><br><span class="line">            <span class="keyword">int</span> target = -num[i];    </span><br><span class="line">            <span class="keyword">int</span> m = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> n = num.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[m]+num[n] == target)&#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; oneResult = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    oneResult.add(num[i]);</span><br><span class="line">                    oneResult.add(num[m]);</span><br><span class="line">                    oneResult.add(num[n]);</span><br><span class="line">                    res.add(oneResult);</span><br><span class="line">                    m++;</span><br><span class="line">                    <span class="keyword">while</span>(m &lt; n &amp;&amp; num[m] == num[m-<span class="number">1</span>])&#123;</span><br><span class="line">                        m++; <span class="comment">//如果重复，直接跳过</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    n--;</span><br><span class="line">                    <span class="keyword">while</span>(m &lt; n &amp;&amp;num[n] == num[n+<span class="number">1</span>])&#123;</span><br><span class="line">                        n--; <span class="comment">//如果重复，直接跳过</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num[m]+num[n] &gt; target)&#123;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    m++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="20200608-晴"><a href="#20200608-晴" class="headerlink" title="20200608 晴"></a>20200608 晴</h1><p>坚持每日刷3题已经：<strong>26</strong>天。</p>
<h2 id="题1-回文数"><a href="#题1-回文数" class="headerlink" title="题1 回文数"></a>题1 <a href="https://www.nowcoder.com/practice/35b8166c135448c5a5ba2cff8d430c32?tpId=46&&tqId=29169&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">回文数</a></h2><blockquote>
<p>回文数判断，负数不是回文数，要考虑反转后溢出的情况，所以我用了long。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> xcopy = x;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp = x%<span class="number">10</span> + tmp*<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xcopy==tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学习别人的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/35b8166c135448c5a5ba2cff8d430c32?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是负数，或者10的整数倍，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> reverse = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; reverse) &#123;</span><br><span class="line">            reverse = reverse * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (reverse == x || reverse / <span class="number">10</span> == x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-【待熟练】-不同的BST种数"><a href="#题2-【待熟练】-不同的BST种数" class="headerlink" title="题2 【待熟练】 不同的BST种数"></a>题2 【待熟练】<a href="https://www.nowcoder.com/practice/b2b6734cbc0b43088f6084785046b861?tpId=46&&tqId=29083&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener"> 不同的BST种数</a></h2><blockquote>
<p>给定一个值n，能构建出多少不同的值包含1…n的二叉搜索树（BST）？</p>
<p>例如</p>
<p>给定 n = 3, 有五种不同的二叉搜索树（BST）</p>
</blockquote>
<p>参考思路：</p>
<blockquote>
<p>作者：加油吧~<br>链接：<a href="https://www.nowcoder.com/questionTerminal/b2b6734cbc0b43088f6084785046b861?f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/b2b6734cbc0b43088f6084785046b861?f=discussion</a><br>来源：牛客网</p>
<p>二叉搜索树有个性质，就是左边的数都比根小，右边的数都比根大。另外，题目说明二叉树的节点是从1到n，所以我们能确定如果根为k，则根左边的数是1到k-1，根右边的数是k+1到n。还有一点技巧是，对于通过一个根来说，唯一二叉树的数量是其左子树的数量乘以右子树的数量，这是简单的乘法原理。并且，左右子树的形态数量是跟具体的数无关的，只跟这个树里有多少节点有关。而根可以选择从1到n的任意的数，唯一二叉树的总数，就是根为1到n的树相加。所以该问题化简为以k为根，其唯一左子树和右子树各有多少，这就是个动态规划的问题了。我们建立一个数组dp[i]，代表节点数为i的唯一子树有多少个。显然dp[0]=dp[1]=1。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp [] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];    <span class="comment">//dp[i]的含义是i个结点有几种排法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;    <span class="comment">//结点的总个数</span></span><br><span class="line">            <span class="comment">//乘法原理</span></span><br><span class="line">            <span class="comment">//左子树的结点个数在0到i-1,右子树的结点个数则是i-1-leftNum（因为它们的左右子树的结点总个数是i-1)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> leftNum = <span class="number">0</span>; leftNum &lt; i;leftNum++)&#123;</span><br><span class="line">                dp[i] += (dp[leftNum] * dp[i-<span class="number">1</span>-leftNum]);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="题3-字符串二进制数的加法"><a href="#题3-字符串二进制数的加法" class="headerlink" title="题3 字符串二进制数的加法"></a>题3 <a href="https://www.nowcoder.com/practice/c8c9f42c19194aa88781efefef4df44b?tpId=46&&tqId=29113&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">字符串二进制数的加法</a></h2><blockquote>
<p>给出两个用字符串表示的二进制数，返回他们的和（也用字符串表示）</p>
<p>例如：</p>
<p>a =”11”<br>b =”1”<br>返回”100”.</p>
</blockquote>
<p>很简单的题，因为条件判断写错了浪费了很多时间调试，实在不应该。</p>
<p><strong>本题涉及到的重要api：sb.insert(0,‘a’) 用于StringBuilder类型的变量在字符串首部添加元素。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span> <span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastA,lastB,carry=<span class="number">0</span>,digit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>  curA = a.length()-<span class="number">1</span>,curB = b.length()-<span class="number">1</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span>(carry==<span class="number">1</span> || curA &gt;=<span class="number">0</span> || curB&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            lastA = curA&gt;=<span class="number">0</span>?a.charAt(curA)-<span class="string">'0'</span>:<span class="number">0</span>; 	 <span class="comment">//-'0'</span></span><br><span class="line">            lastB = curB&gt;=<span class="number">0</span>?b.charAt(curB)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            digit = carry+lastA+lastB;</span><br><span class="line">            <span class="keyword">if</span>(digit&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                digit %= <span class="number">2</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.insert(<span class="number">0</span>,digit);			<span class="comment">//这个api要记住！！！！！</span></span><br><span class="line">            curA--;</span><br><span class="line">            curB--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="20200607-晴"><a href="#20200607-晴" class="headerlink" title="20200607 晴"></a>20200607 晴</h1><p>坚持每日刷3题已经：<strong>25</strong>天。</p>
<h2 id="题1-三角形最小路径和"><a href="#题1-三角形最小路径和" class="headerlink" title="题1 三角形最小路径和"></a>题1 <a href="https://www.nowcoder.com/practice/2b7995aa4f7949d99674d975489cb7da?tpId=46&&tqId=29060&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">三角形最小路径和</a></h2><blockquote>
<p>给出一个三角形，计算从三角形顶部到底部的最小路径和，每一步都可以移动到下面一行相邻的数字，</p>
<p>例如，给出的三角形如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[↵     [2],↵    [3,4],↵   [6,5,7],↵  [4,1,8,3]↵]</span><br></pre></td></tr></table></figure>

<p>最小的从顶部到底部的路径和是2 + 3 + 5 + 1 = 11。</p>
<p>注意：如果你能只用O（N）的额外的空间来完成这项工作的话，就可以得到附加分，其中N是三角形中的行总数。</p>
</blockquote>
<p>注意：题目里说的“可以移动到下面一行相邻的数字”指的是下一行的对应位置元素和下一行其右边的元素。（<a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">leetcode</a>中对此进行了说明——<strong>相邻的结点</strong> 在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。）。</p>
<p>没有用到额外空间，但是修改了输入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle==<span class="keyword">null</span> || triangle.get(<span class="number">0</span>)==<span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size()-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">                <span class="comment">//int left = j&gt;0?triangle.get(i+1).get(j-1):Integer.MAX_VALUE; 这个不算相邻！</span></span><br><span class="line">                <span class="keyword">int</span> down = triangle.get(i+<span class="number">1</span>).get(j);</span><br><span class="line">                <span class="keyword">int</span> right = j&lt;triangle.get(i).size()?triangle.get(i+<span class="number">1</span>).get(j+<span class="number">1</span>):Integer.MAX_VALUE;</span><br><span class="line">                triangle.get(i).set(j,triangle.get(i).get(j)+Math.min(down,right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-丑数"><a href="#题2-丑数" class="headerlink" title="题2 丑数"></a>题2 <a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">丑数</a></h2><blockquote>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<p>这是剑指Offer上的一道题，之前一直没思路，昨天看了大佬的题解数学定义太多也看得迷迷糊糊，今天get到了，手动计算了一遍，写代码一遍过。牛客网上tag是穷举，不过做了发现更像是动态规划。</p>
<p>理解此题的核心在于理解：从第二个丑数开始，任何一个丑数都可以由前面的某个丑数x2,或者x3,或者x5得到。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200607153758932.png" alt="手动计算过程" title="">
                </div>
                <div class="image-caption">手动计算过程</div>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [index];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//p1、p2、p3分别指向*2 , *3 ,*5的备选项 </span></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>,p3 = <span class="number">0</span>,p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2Value,p3Value,p5Value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;index; i++)&#123;</span><br><span class="line">            p2Value = dp[p2] * <span class="number">2</span>;</span><br><span class="line">            p3Value = dp[p3] * <span class="number">3</span>;</span><br><span class="line">            p5Value = dp[p5] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(p2Value,p3Value),p5Value); </span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p2]*<span class="number">2</span>)&#123; <span class="comment">//最小</span></span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p3]*<span class="number">3</span>)&#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p5]*<span class="number">5</span>)&#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化上述代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [index];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//p1、p2、p3分别指向*2 , *3 ,*5的备选项 </span></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>,p3 = <span class="number">0</span>,p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;index; i++)&#123;</span><br><span class="line">            dp[i] = Math.min(Math.min(dp[p2]*<span class="number">2</span>,dp[p3]*<span class="number">3</span>),dp[p5]*<span class="number">5</span>); </span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p2]*<span class="number">2</span>) p2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p3]*<span class="number">3</span>) p3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == dp[p5]*<span class="number">5</span>) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-【待熟练】数据流中的中位数"><a href="#题3-【待熟练】数据流中的中位数" class="headerlink" title="题3 【待熟练】数据流中的中位数"></a>题3 【待熟练】<a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&&tqId=11216&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">数据流中的中位数</a></h2><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<p>tag:堆</p>
<p>这是一个涉及堆的问题，虽然说堆的实现不难，不过面试的时候估计是没那么多时间去自己实现一个堆，还是用现成的轮子——PriorityQueue吧。不过对其api不是很熟悉，这里复习一下：</p>
<ul>
<li><p>JDK提供的PriorityQueue底层实现是最小堆。</p>
</li>
<li><p>如果要通过PriorityQueue完成最大堆的功能，需要指定比较器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    PriorityQueue &lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2-o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">可以用lambda表达式简化：</span><br><span class="line">    PriorityQueue &lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (o1, o2) -&gt; o2-o1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>queue.add(Object o)和queue.remove()可分别用于在堆中插入元素、移除堆顶元素。</p>
</li>
<li><p>queue.size()返回堆的大小。</p>
</li>
</ul>
<p>熟悉完了PriorityQueue，就可以做这个题目了。</p>
<p>这题是基于<strong>用一个最大堆和一个最小堆，分别平均地保存数据流中的较小的数字和较大的数字</strong>的思想，比如说数据流是1,2,3,4,5,6，</p>
<p>我们希望，其内部存储形如（只要满足堆的性质就好，其中1和2以及5和6的位置可以调换）： </p>
<p>​        3                                4</p>
<p>​    /      \                          /        \</p>
<p> 2          1                     5           6</p>
<p>这样一来， 其中位数就可以通过最大堆和最小堆的堆顶元素得到。</p>
<p>难点就是在于，怎么在插入元素的同时维持两个堆的平衡、且不破坏堆的性质。</p>
<p>为了保持平衡，也就是哪个堆元素少，新添加的元素就要插入到哪个堆，而如果两个堆的大小相同，可以规定默认插入到最小堆。</p>
<p>比如说这时候再来一个元素7，插入到最小堆，再来一个元素，变成4567，中位数是4，</p>
<p>再来一个元素8，因为这个时候，最大堆的元素个数比较少，为了保证两堆的平衡，我们是希望最大堆能多一个元素，但如果直接把8插入到最大堆，堆就变成了8312，最小堆仍是4567，计算中位数就变成了(4+8)/2 ，显然不对，为什么会不对呢？这是因为我们把8这个大元素插入到了最大堆，而最大堆应该保存的是比较小的元素，所以说，我们想要增加最大堆的元素个数，不能将现在的元素直接插入到最大堆，而是应该先插入到最小堆，在最小堆中大元素下沉，变成45678，这个时候再把4取走插入到最大堆，也就是说最小堆变成了5678，最大堆变成了4321，这样一来，才能保证了最大堆的大小确实+1，而且维持了<strong>用一个最大堆和一个最小堆，分别平均地保存数据流中的较小的数字和较大的数字</strong>的目标。</p>
<p>同理，最大堆是321，最小堆是456，当又来了一个元素0，我们也不能直接插入到最小堆，而是要先插入到最大堆，让0下沉，再把最大堆的堆顶元素3取过来到最小堆。</p>
<p>说的很繁琐，简单总结一下：通过维持两个堆的大小相等（或最小堆的大小大1）来保证以O(1)时间找到中位数，而如果要插入新的元素，如果此时两堆大小相等，我们希望最小堆中再多放一个元素（大小能增加1），但是我们不能直接把新元素插入，而是要先插入最大堆，再从最大堆取出堆顶元素加入到最小堆，这样一来，最大堆的元素个数没变，最小堆的元素个数增加1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="comment">//思路:如果两个堆的大小一样，随便加入到哪个堆，如果两个堆的大小不一样，加入到元素少的那个堆</span></span><br><span class="line"><span class="comment">//我的处理是如果两个堆大小一样，就加入到最小堆</span></span><br><span class="line"><span class="comment">//关键在于：想加到最大/小堆不能直接加，而要虚晃一下，加入另一个堆，再把另一个堆的堆顶加入到你真正想加入的那个堆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue &lt;Integer&gt; minQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();    <span class="comment">//最小堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue &lt;Integer&gt; maxQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); <span class="comment">//最大堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minQueue.size()&lt;=maxQueue.size())&#123;</span><br><span class="line">            <span class="comment">//我们希望minQueue里增加一个元素，但是不能直接加入</span></span><br><span class="line">            maxQueue.add(num);</span><br><span class="line">            minQueue.add(maxQueue.remove());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//我们希望maxQueue里增加一个元素，但是不能直接加入</span></span><br><span class="line">            minQueue.add(num);</span><br><span class="line">            maxQueue.add(minQueue.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minQueue.size()==maxQueue.size())</span><br><span class="line">            <span class="keyword">return</span> (minQueue.peek()+maxQueue.peek())/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> minQueue.peek()*<span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="20200606-晴"><a href="#20200606-晴" class="headerlink" title="20200606 晴"></a>20200606 晴</h1><p>坚持每日刷3题已经：<strong>24</strong>天。</p>
<p>今天出去小浪了一波吃了个烤鱼，回来睡到晚十点，本来想做几道DP，太累了看了几题实在没思路，题解也看不进去，索性从leetcode top100挑几道简单题完成任务。</p>
<h2 id="题1-汉明距离"><a href="#题1-汉明距离" class="headerlink" title="题1 汉明距离"></a>题1 <a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">汉明距离</a></h2><blockquote>
<p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离" target="_blank" rel="noopener">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
</blockquote>
<p>while循环最多进入32次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>||y!=<span class="number">0</span>)&#123;</span><br><span class="line">            cnt+=(x&amp;<span class="number">1</span>)^(y&amp;<span class="number">1</span>);</span><br><span class="line">            x = x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有种改进方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">      distance += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// remove the rightmost bit of '1'</span></span><br><span class="line">      xor = xor &amp; (xor - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="题2-合并二叉树"><a href="#题2-合并二叉树" class="headerlink" title="题2 合并二叉树"></a>题2 <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h2><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
</blockquote>
<p>我自己做的递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span> &amp;&amp; t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="keyword">null</span>)&#123;   <span class="comment">//t1空t2不空</span></span><br><span class="line">            res = <span class="keyword">new</span> TreeNode(t2.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res = <span class="keyword">new</span> TreeNode(t1.val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.left = mergeTrees(t1!=<span class="keyword">null</span>?t1.left:<span class="keyword">null</span>,t2!=<span class="keyword">null</span>?t2.left:<span class="keyword">null</span>);</span><br><span class="line">            res.right = mergeTrees(t1!=<span class="keyword">null</span>?t1.right:<span class="keyword">null</span>,t2!=<span class="keyword">null</span>?t2.right:<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做之前也想到了，可以以一棵树为基准，不用new结点。 但是想到这样的话就会修改原来两棵树的结构，就没这样做了。</p>
<p>题解给的递归方法很简洁，就是基于此思路的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h2 id="题3-比特位计数"><a href="#题3-比特位计数" class="headerlink" title="题3  比特位计数"></a>题3 <a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener"> 比特位计数</a></h2><blockquote>
<p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p>示例 1:</p>
<p>输入: 2<br>输出: [0,1,1]<br>示例 2:</p>
<p>输入: 5<br>输出: [0,1,1,2,1,2]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tag:位运算，这题有点动态规划的思想，参考官方题解的"方法三：动态规划 + 最低有效位 " </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> res [] = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=num; i++)&#123;</span><br><span class="line">            res[i] = res[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="20200605-多云"><a href="#20200605-多云" class="headerlink" title="20200605 多云"></a>20200605 多云</h1><p>坚持每日刷3题已经：<strong>23</strong>天。</p>
<h2 id="题1-爬楼梯"><a href="#题1-爬楼梯" class="headerlink" title="题1 爬楼梯"></a>题1 <a href="https://www.nowcoder.com/practice/d679cfa563974385a3bef8cd854c73db?tpId=46&&tqId=29108&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">爬楼梯</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你在爬楼梯，需要n步才能爬到楼梯顶部</span><br><span class="line">每次你只能向上爬<span class="number">1</span>步或者<span class="number">2</span>步。有多少种方法可以爬到楼梯顶部？</span><br></pre></td></tr></table></figure>

<p>dp数组动态规划。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 1-1</span></span><br><span class="line">    <span class="comment">// 2-2</span></span><br><span class="line">    <span class="comment">// 3-dp[i-1]+dp[i-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步优化:不需要数组，只用几个临时变量迭代（逻辑上有点像双指针,画图理解）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">1</span> ,tmp;</span><br><span class="line">        <span class="keyword">while</span>((n--)&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            tmp = res;</span><br><span class="line">            res += jump;</span><br><span class="line">            jump = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-格雷码"><a href="#题2-格雷码" class="headerlink" title="题2 格雷码"></a>题2 <a href="https://www.nowcoder.com/practice/55dddb4cdf074fefba653ff523e42346?tpId=46&&tqId=29089&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">格雷码</a></h2><blockquote>
<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p>
<p>格雷编码序列必须以 0 开头。</p>
</blockquote>
<p>格雷码n位,也就是说有2^n(1&lt;&lt;n)个数字。</p>
<p>下面代码可以用公式算出n个数字中的第i个格雷码序列的元素，(i标识这组格雷码编码系统中的第i个元素）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200605204055096.png" alt="格雷码的手动计算过程和公式计算验证" title="">
                </div>
                <div class="image-caption">格雷码的手动计算过程和公式计算验证</div>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">grayCode</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>&lt;&lt;n; <span class="comment">//这个系统中的数字个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sum;i++)&#123;</span><br><span class="line">            list.add((i&gt;&gt;<span class="number">1</span>)^i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/" target="_blank" rel="noopener">其他解法</a></p>
<h2 id="题3-反转整数"><a href="#题3-反转整数" class="headerlink" title="题3 反转整数"></a>题3 <a href="https://www.nowcoder.com/practice/1a3de8b83d12437aa05694b90e02f47a?tpId=46&&tqId=29171&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">反转整数</a></h2><blockquote>
<p>将给出的整数x翻转。<br>例1:x=123，返回321<br>例2:x=-123，返回-321</p>
<p>你有思考过下面的这些问题么？</p>
<p>如果整数的最后一位是0，那么输出应该是什么？比如10,100<br>你注意到翻转后的整数可能溢出吗？假设输入是32位整数，则将翻转10000000003就会溢出，你该怎么处理这样的样例？抛出异常？这样做很好，但是如果不允许抛出异常呢？这样的话你必须重新设计函数（比如添加一个额外的参数）。</p>
</blockquote>
<p>这题牛客的测试用例不完整！ 提交时上<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">Leetcode</a>。</p>
<p>一开始我写的代码如下：考虑到了溢出情况的处理，如果结果溢出了，就返回0。在leetcode提交还是不行，这是因为当x=Integer.MIN_VALUE时，-x的值是Interger.MAX_VALUE+1，对于int类型来说，这就溢出了！（同样的，计算pow(x,n)那题也会有这样的情况，注意避免！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">                res *= <span class="number">10</span>;</span><br><span class="line">                res += (x%<span class="number">10</span>);</span><br><span class="line">                x/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//如果小于0</span></span><br><span class="line">        <span class="keyword">return</span> -reverse(-x);			<span class="comment">//有问题！！当x=Integer.MIN_VALUE调用reverse就溢出了int。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res *= <span class="number">10</span>;</span><br><span class="line">            res += (x%<span class="number">10</span>);</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Leetcode看到一个很妙的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((ans * <span class="number">10</span>) / <span class="number">10</span> != ans) &#123;		<span class="comment">//如果*10再/10后不等于自己，就说明*10是溢出了</span></span><br><span class="line">			ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">		x = x / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ansx10未溢出时, ansx10个位为0, x%10的取值范围是0~9, 故ans*10 + x%10一定没有进位, 故不会溢出，所以就只要考虑ansx10这部分是否溢出就行了。</p>
<h1 id="20200604-多云"><a href="#20200604-多云" class="headerlink" title="20200604 多云"></a>20200604 多云</h1><p>坚持每日刷3题已经：<strong>22</strong>天。</p>
<p>今天刷了三题动态规划。如果说21天养成一个习惯，刷题这个习惯已经养成了哈哈哈。</p>
<h2 id="题1-unique-paths"><a href="#题1-unique-paths" class="headerlink" title="题1 unique-paths"></a>题1 <a href="https://www.nowcoder.com/practice/166eaff8439d4cd898e3ba933fbc6358?tpId=46&&tqId=29117&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">unique-paths</a></h2><blockquote>
<p>一个机器人在m×n大小的地图的左上角（起点，下图中的标记“start”的位置）。</p>
<p>机器人每次向下或向右移动。机器人要到达地图的右下角。（终点，下图中的标记“Finish”的位置）。</p>
<p>可以有多少种不同的路径从起点走到终点？</p>
</blockquote>
<p>递归解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">1</span>,<span class="number">1</span>,m,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r==m || c==n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(r+<span class="number">1</span>,c,m,n)+dp(r,c+<span class="number">1</span>,m,n);    <span class="comment">//分别表示向下走、向右走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span> <span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line">        <span class="comment">//最后一列初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][n-<span class="number">1</span>] = <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一行初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[m-<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-unique-paths-ii"><a href="#题2-unique-paths-ii" class="headerlink" title="题2 unique-paths-ii"></a>题2 <a href="https://www.nowcoder.com/practice/3cdf08dd4e974260921b712f0a5c8752?tpId=46&&tqId=29116&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">unique-paths-ii</a></h2><p>递归解法未AC</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">！！有误</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obstacleGrid int整型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span> <span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid==<span class="keyword">null</span> || obstacleGrid[<span class="number">0</span>]==<span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>,<span class="number">0</span>,obstacleGrid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> [][]obstacleGrid)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r==obstacleGrid.length-<span class="number">1</span> || c==obstacleGrid[<span class="number">0</span>].length-<span class="number">1</span>)&#123;  <span class="comment">//边界返回1</span></span><br><span class="line">            <span class="keyword">return</span> obstacleGrid[r][c]^<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[r][c]==<span class="number">1</span>)&#123;    <span class="comment">//路障返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(r+<span class="number">1</span>,c,obstacleGrid)+dp(r,c+<span class="number">1</span>,obstacleGrid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划:成功AC</p>
<p>注意dp数组的最后一列和最后一行的初始化！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span> <span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid==<span class="keyword">null</span> || obstacleGrid[<span class="number">0</span>]==<span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span> obstacleFlag = <span class="keyword">false</span>;  <span class="comment">//标记是否出现了障碍，没必要！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//初始化最后一列</span></span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][n-<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                obstacleFlag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][n-<span class="number">1</span>] = obstacleFlag?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        obstacleFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//初始化最后一行</span></span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[m-<span class="number">1</span>][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                obstacleFlag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[m-<span class="number">1</span>][i] = obstacleFlag?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i][j] = obstacleGrid[i][j]==<span class="number">1</span>?<span class="number">0</span>:dp[i+<span class="number">1</span>][j]+dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码标记了最后一行和最后一列是否出现了障碍，其实没必要，直接break就好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obstacleGrid int整型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span> <span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid==<span class="keyword">null</span> || obstacleGrid[<span class="number">0</span>]==<span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//初始化最后一列</span></span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][n-<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//初始化最后一行</span></span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[m-<span class="number">1</span>][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[m-<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i][j] = obstacleGrid[i][j]==<span class="number">1</span>?<span class="number">0</span>:dp[i+<span class="number">1</span>][j]+dp[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-minimum-path-sum"><a href="#题3-minimum-path-sum" class="headerlink" title="题3 minimum-path-sum"></a>题3 <a href="https://www.nowcoder.com/practice/23462ed010024fcabb7dbd3df57c715e?tpId=46&&tqId=29115&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">minimum-path-sum</a></h2><blockquote>
<p>给定一个由非负整数填充的m x n的二维数组，现在要从二维数组的左上角走到右下角，请找出路径上的所有数字之和最小的路径。<br>注意：你每次只能向下或向右移动。</p>
</blockquote>
<p>方便起见，我直接把grid作为dp数组了，修改了grid这个二维数组的值，实际开发中不要这样做，(调用了一个函数直接把输入改了..)。</p>
<p>时间复杂度是O(m*n),空间复杂度都是O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span> <span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid ==<span class="keyword">null</span> || grid[<span class="number">0</span>]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//初始化最后一行</span></span><br><span class="line">            grid[m-<span class="number">1</span>][i] += grid[m-<span class="number">1</span>][i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//初始化最后一列</span></span><br><span class="line">            grid[i][n-<span class="number">1</span>] += grid[i+<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                grid[i][j] += Math.min(grid[i+<span class="number">1</span>][j],grid[i][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="20200603-雨"><a href="#20200603-雨" class="headerlink" title="20200603 雨"></a>20200603 雨</h1><p>坚持每日刷3题已经：<strong>21</strong>天。</p>
<p>今日tag：分治。</p>
<h2 id="题1-sqrtx"><a href="#题1-sqrtx" class="headerlink" title="题1 sqrtx"></a>题1 <a href="https://www.nowcoder.com/practice/09fbfb16140b40499951f55113f2166c?tpId=46&&tqId=29109&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">sqrtx</a></h2><blockquote>
<p>实现函数 int sqrt(int x). </p>
<p>计算并返回x的平方根</p>
</blockquote>
<p>思路：二分搜索。 复杂度O(logn)，注意不能用mid*mid 和x比较，要用和mid和x/mid比较，否则会溢出！</p>
<p>如果mid == x/mid，直接返回</p>
<p>如果mid &gt; x/mid ，(mid*mid&gt;x)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = x;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">            mid = (end-begin)/<span class="number">2</span>+begin;</span><br><span class="line">            <span class="keyword">if</span>(mid==x/mid)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; x/mid)&#123;</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((mid+<span class="number">1</span>)&gt;x/(mid+<span class="number">1</span>)) <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid -<span class="number">1</span>; </span><br><span class="line">                <span class="keyword">if</span>((mid-<span class="number">1</span>)&lt;x/(mid-<span class="number">1</span>)) <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的判断条件不太优雅（且判断条件太多效率也有影响），回想一下二分查找，如果找到了就返回元素下标，如果没找到就返回其应该插入的位置的下标（begin），而这里可以理解成返回根号x插入下标的前一个坐标(比如说x=2，根号x的二分查找范围是[1,2]，可以理解成把根号2也就是1.4插入位置下标1的前一位)，所以可以直接返回begin-1，上面的代码能简化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = x;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">            mid = (end-begin)/<span class="number">2</span>+begin;</span><br><span class="line">            <span class="keyword">if</span>(mid==x/mid)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; x/mid)&#123;</span><br><span class="line">                begin = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid -<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span>  begin-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-【待优化】-跳跃游戏"><a href="#题2-【待优化】-跳跃游戏" class="headerlink" title="题2 【待优化】 跳跃游戏"></a>题2 【待优化】 <a href="https://www.nowcoder.com/practice/a2d856f493424a748bb7c9c1126e8d8d?tpId=46&&tqId=29124&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">跳跃游戏</a></h2><blockquote>
<p>给出一个非负整数数组，你最初在数组第一个元素的位置</p>
<p>数组中的元素代表你在这个位置可以跳跃的最大长度</p>
<p>判断你是否能到达数组最后一个元素的位置</p>
<p>例如</p>
<p>A =[2,3,1,1,4], 返回 true.</p>
<p>A =[3,2,1,0,4], 返回 false.</p>
</blockquote>
<p>写的时候抱着试一试的心态，写完还一次过了（牛客）。</p>
<p>关键是要能理解：最远能到达某个位置，就一定能到达它前面的任何位置，所以可以用贪心，每次都选择最优的跳。</p>
<ul>
<li>如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。</li>
<li>可以对每一个能作为 起跳点 的格子都尝试跳一次，把 <strong>能跳到最远的距离</strong> 不断更新。</li>
<li>如果可以一直跳到最后，就成功了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span> <span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; A.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur+A[cur] &gt;= A.length-<span class="number">1</span>)  <span class="comment">//防止调用bestJumpStep()越界，要先判断一次</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> step = bestJumpStep(cur,A);</span><br><span class="line">            <span class="keyword">if</span>(step==<span class="number">0</span>)	<span class="comment">//如果“跳不动了”</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            cur+=step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算这一次要跳几步是最优解,cur:当前下标</span></span><br><span class="line">    <span class="comment">//比如说 2,3，1,返回1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bestJumpStep</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> [] A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>,maxDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=A[cur];i++)&#123; <span class="comment">//最少跳1步，最多跳A[cur]步</span></span><br><span class="line">            <span class="keyword">if</span>(i+A[cur+i]&gt;maxDistance)&#123;</span><br><span class="line">                step = i;</span><br><span class="line">                maxDistance = i+A[cur+i]; <span class="comment">//更新最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode-solution/</a></p>
<p>看看人家的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            k = Math.max(k, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-可能重复的全排列"><a href="#题3-可能重复的全排列" class="headerlink" title="题3 可能重复的全排列"></a>题3 <a href="https://www.nowcoder.com/practice/a43a2b986ef34843ac4fdd9159b69863?tpId=46&&tqId=29132&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">可能重复的全排列</a></h2><blockquote>
<p>给出一组可能包含重复项的数字，返回该组数字的所有排列</p>
<p>例如；</p>
<p>[1,1,2]的排列如下：<br>[1,1,2],[1,2,1], [2,1,1].</p>
</blockquote>
<p>这题的难点在于避免重复：先对数组num进行排序，保证重复数字相邻，这样在后续操作中，利用条件，若后一数与前一数相等，则不处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        Arrays.sort(num);					<span class="comment">//先排序</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;(num.length);</span><br><span class="line">        <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[num.length];</span><br><span class="line">        dfs(num,res,path,<span class="number">0</span>,visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> [] num,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; path,<span class="keyword">int</span> cur,<span class="keyword">boolean</span> visited[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==num.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个元素只能用一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; num[i]==num[i-<span class="number">1</span>] &amp;&amp; visited[i-<span class="number">1</span>])&#123; <span class="comment">//这两行用来避免重复！ 三个判断条件缺一不可 </span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                path.add(num[i]);</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(num,res,path,cur+<span class="number">1</span>,visited);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; num[i]==num[i-<span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>])&#123; <span class="comment">//这两行用来避免重复！ 三个判断条件缺一不可 </span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">这里的第三个条件不好理解：可以参考下图，只有当 i-<span class="number">1</span> 这个元素是被选择了的时候，才需要剪枝，如果不加第三个条件，会出现下图的错误情况。</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../images/image-20200603123358618.png" alt="image-20200603123358618" title="">
                </div>
                <div class="image-caption">image-20200603123358618</div>
            </figure>



<h1 id="20200602-晴"><a href="#20200602-晴" class="headerlink" title="20200602 晴"></a>20200602 晴</h1><p>坚持每日刷3题已经：<strong>20</strong>天。</p>
<p>今天把回溯做完了，开始学习贪心算法，今天看了小码哥讲的贪心，01背包问题。</p>
<h2 id="题1-跳跃最少步数"><a href="#题1-跳跃最少步数" class="headerlink" title="题1 跳跃最少步数"></a>题1 <a href="https://www.nowcoder.com/practice/7250845fb3b946a5a778565adba9d993?tpId=46&&tqId=29134&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">跳跃最少步数</a></h2><blockquote>
<p>给出一个非负整数数组，你最初在数组第一个元素的位置</p>
<p>数组中的元素代表你在这个位置可以跳跃的最大长度</p>
<p>你的目标是用最少的跳跃次数来到达数组的最后一个元素的位置</p>
<p>例如</p>
<p>给出数组 A =[2,3,1,1,4]</p>
<p>最少需要两次才能跳跃到数组最后一个元素的位置。（从数组下标为0的位置跳长度1到达下标1的位置，然后跳长度3到数组最后一个元素的位置）</p>
</blockquote>
<p>思路：贪心。每次跳到 本次跳跃距离+潜力最大的的位置（多看一步）。</p>
<p>下次做题的测试用例：[2,3,1,1,4]；[2,1]；[3,2,1]</p>
<p>做题情况：</p>
<p>首次提交30%，看了未通过的测试用例后，发现自己少了一个判断条件导致了数组越界的情况，改了后AC60%。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200602223938161.png" alt="图解" title="">
                </div>
                <div class="image-caption">图解</div>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//贪心：每一步都跳到“潜力”最大的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span> <span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从A[0] 开始 跳到A[length-1]</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;    <span class="comment">//当前位置</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">//记录跳跃次数</span></span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>, max=<span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; A.length-<span class="number">1</span>)&#123;</span><br><span class="line">            distance = A[cur];</span><br><span class="line">            max = <span class="number">0</span>;</span><br><span class="line">            step = A[cur];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= A[cur] &amp;&amp; cur+i &lt; A.length; i++)&#123;</span><br><span class="line">                distance = i+A[cur+i];    <span class="comment">//此次跳的步长+到达位置的跳跃最大长度</span></span><br><span class="line">                <span class="keyword">if</span>(distance&gt;max)&#123;</span><br><span class="line">                    max = distance;</span><br><span class="line">                    step = i;        <span class="comment">//记录跳几步是最优解</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳step步</span></span><br><span class="line">            cur = cur+step;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//贪心：每一步都跳到“潜力”最大的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span> <span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从A[0] 开始 跳到A[length-1]</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;    <span class="comment">//当前位置</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">//记录跳跃次数</span></span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>, max=<span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; A.length-<span class="number">1</span>)&#123;</span><br><span class="line">            distance = A[cur];</span><br><span class="line">            max = <span class="number">0</span>;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= A[cur]; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur+i &gt;= A.length-<span class="number">1</span>)&#123;    <span class="comment">//如果cur+i越界，说明再跳一次就到了，这个判断很关键，否则cur+i可能越界</span></span><br><span class="line">                    <span class="keyword">return</span> cnt+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                distance = i+A[cur+i];    <span class="comment">//此次跳的步长+到达位置的跳跃最大长度</span></span><br><span class="line">                <span class="keyword">if</span>(distance&gt;max)&#123;</span><br><span class="line">                    max = distance;</span><br><span class="line">                    step = i;        <span class="comment">//记录跳几步是最优解</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳step步</span></span><br><span class="line">            cur = cur+step;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题2-最大子数组（最大连续子序列）"><a href="#题2-最大子数组（最大连续子序列）" class="headerlink" title="题2 最大子数组（最大连续子序列）"></a>题2 <a href="https://www.nowcoder.com/practice/32139c198be041feb3bb2ea8bc4dbb01?tpId=46&&tqId=29126&rp=1&ru=/activity/oj&qru=/ta/leetcode/question-ranking" target="_blank" rel="noopener">最大子数组（最大连续子序列）</a></h2><blockquote>
<p>请计算给出的数组（至少含有一个数字）中具有最大和的子数组（子数组要求在原数组中连续）</p>
<p>例如：给出的数组为[−2,1,−3,4,−1,2,1,−5,4],</p>
<p>子数组[−2,1,−3,4,−1,2,1,−5,4],具有最大的和:6.</p>
<p><strong>拓展：</strong></p>
<p>如果你已经提出了O(n)的解决方法，请尝试使用分治算法来解决这道题。这道题分治的解法更巧妙一些。</p>
</blockquote>
<p>一气呵成，一次AC，感动中国。</p>
<p>这道题目可以用DP做，但是题目点名用分治法了，就试试看 T(n) = 2T(n/2) + O(N)，时间复杂度是O(nlogn)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span> <span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> maxSubArray(A,<span class="number">0</span>,A.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span> [] A,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==end)    <span class="keyword">return</span> A[begin];</span><br><span class="line">        <span class="keyword">int</span> mid = (end-begin)/<span class="number">2</span>+begin;</span><br><span class="line">        <span class="keyword">int</span> leftMax = maxSubArray(A,begin,mid);</span><br><span class="line">        <span class="keyword">int</span> lmax=<span class="number">0</span>,rmax=<span class="number">0</span>,lsum=<span class="number">0</span>,rsum=<span class="number">0</span>,middleMax = A[mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid-<span class="number">1</span>;i&gt;=begin;i--)&#123;</span><br><span class="line">            lsum+=A[i];</span><br><span class="line">            <span class="keyword">if</span>(lsum&gt;lmax)    lmax = lsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">            rsum+=A[i];</span><br><span class="line">            <span class="keyword">if</span>(rsum&gt;rmax)    rmax = rsum;</span><br><span class="line">        &#125;</span><br><span class="line">        middleMax = middleMax+lmax+rmax;</span><br><span class="line">        <span class="keyword">int</span> rightMax = maxSubArray(A,mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftMax,rightMax),middleMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3-合法的BST"><a href="#题3-合法的BST" class="headerlink" title="题3 合法的BST"></a>题3 <a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/" target="_blank" rel="noopener">合法的BST</a></h2><blockquote>
<p>输入:<br>    5<br>   / <br>  1   4<br>     / <br>    3   6<br>输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。</p>
</blockquote>
<p>注意：不允许元素重复，比如说[1，1]返回false。</p>
<p>这是之前做的，没做出的题。</p>
<p>使用<strong>带上下界限的递归</strong>很容易解决!</p>
<p>注意：Integer.MIN_VALUE-1 = Integer.MAX_VALUE！！！ 所以要转成long类型后再减1。</p>
<p>这样做超越双100%。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root,(<span class="keyword">long</span>)Integer.MIN_VALUE-<span class="number">1</span>,(<span class="keyword">long</span>)Integer.MAX_VALUE+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//root.val必须大于最小限制minLimit且小于最大限制maxLimit</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root,<span class="keyword">long</span> minLimit,<span class="keyword">long</span> maxLimit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= maxLimit || root.val &lt;= minLimit )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left,minLimit,root.val) &amp;&amp; isValidBST(root.right,root.val,maxLimit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>[1,2,5],11 输出：3</p>
<p>[18,49,8,48] 50, 输出 :5  （4X8+1X18）</p>
</blockquote>
<h1 id="20200601-晴"><a href="#20200601-晴" class="headerlink" title="20200601 晴"></a>20200601 晴</h1><p>坚持每日刷3题已经：<strong>19</strong>天。</p>
<p>六月的第一天，今天仍然是复习回溯算法。</p>
<h2 id="题1-二叉树中和为某一值的路径"><a href="#题1-二叉树中和为某一值的路径" class="headerlink" title="题1 二叉树中和为某一值的路径"></a>题1 <a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">二叉树中和为某一值的路径</a></h2><blockquote>
<p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200601234129746.png" alt="图解回溯思路" title="">
                </div>
                <div class="image-caption">图解回溯思路</div>
            </figure>

<p>一开始的做法如下，提交发现通过率0%</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">错误代码！！</span><br><span class="line">错误提示：path是引用、重复结果！</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        findPath(root,target,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; path,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;    <span class="comment">//递归到叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;    <span class="comment">//如果=0</span></span><br><span class="line">                res.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        findPath(root.left,target-root.val,path,res)</span><br><span class="line">        findPath(root.right,target-root.val,path,res);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：测试用例 单节点树 1，1</p>
<p>手动调试发现会有重复结果！ 返回值是[[1],[1]]，因为左右子树重复计算了，加了判断条件，结果还是0%正确，看未通过的测试用例，发现我的返回结果是[],这个时候还没没意识到什么，后面才意识到是<strong>path是引用的问题</strong>，最后会回退到path里啥都没有的状态 ，而path是引用，每次递归实际上只是修改堆内存的同一个对象!</p>
<p>正确代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        findPath(root,target,path,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; path,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;    <span class="comment">//递归到叶子结点</span></span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;    <span class="comment">//如果=0</span></span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        findPath(root.left,target-root.val,path,res); </span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;  <span class="comment">//这里很关键、一定要写，不然会有重复结果！</span></span><br><span class="line">                findPath(root.right,target-root.val,path,res);</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下次做题提示：</strong>引用、避免左右子树都为null的重复结果。</p>
<h2 id="题2-机器人的运动范围"><a href="#题2-机器人的运动范围" class="headerlink" title="题2 机器人的运动范围"></a>题2 <a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">机器人的运动范围</a></h2><blockquote>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<p>思路：做题前思考，一开始我想，不是直接两层for循环就可以判断每个格子能否容纳，后来一想才反应过来，可能中间有一行断了，机器人到不了，这样的话，更到不了后面的行了。</p>
<pre><code>if(visited[r][c+1]) backtrace(r,c+1,threshold,rows,cols,visited);    //走右格子
if(visited[r][c-1]) backtrace(r,c-1,threshold,rows,cols,visited);    //走左格子
if(visited[r-1][c]) backtrace(r-1,c,threshold,rows,cols,visited);    //走上格子
if(visited[r+1][c]) backtrace(r+1,c,threshold,rows,cols,visited);    //走下格子</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> visited[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        backtrace(<span class="number">0</span>,<span class="number">0</span>,threshold,rows,cols,visited);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">boolean</span> visited[][])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=rows || c&lt;<span class="number">0</span> || c&gt;=cols)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[r][c] = <span class="keyword">true</span>;		<span class="comment">//访问标记置为true</span></span><br><span class="line">        <span class="keyword">if</span>(canJoin(r,c,threshold))&#123;</span><br><span class="line">            <span class="keyword">this</span>.count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    <span class="comment">//否则这条路就断了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!hasVisited(r,c+<span class="number">1</span>,visited)) backtrace(r,c+<span class="number">1</span>,threshold,rows,cols,visited);    <span class="comment">//走右格子</span></span><br><span class="line">        <span class="keyword">if</span>(!hasVisited(r,c-<span class="number">1</span>,visited)) backtrace(r,c-<span class="number">1</span>,threshold,rows,cols,visited);    <span class="comment">//走左格子</span></span><br><span class="line">        <span class="keyword">if</span>(!hasVisited(r-<span class="number">1</span>,c,visited)) backtrace(r-<span class="number">1</span>,c,threshold,rows,cols,visited);    <span class="comment">//走上格子</span></span><br><span class="line">        <span class="keyword">if</span>(!hasVisited(r+<span class="number">1</span>,c,visited)) backtrace(r+<span class="number">1</span>,c,threshold,rows,cols,visited);    <span class="comment">//走下格子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否访问过了某个格子,注意越界的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasVisited</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c,<span class="keyword">boolean</span> visited[][])</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r&gt;=<span class="number">0</span> &amp;&amp; r&lt;visited.length &amp;&amp; c&gt;=<span class="number">0</span> &amp;&amp; c&lt;visited[<span class="number">0</span>].length &amp;&amp; visited[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断机器人能否进入(row,col)这个格子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJoin</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> threshold)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum = sum + r%<span class="number">10</span>;</span><br><span class="line">            r = r/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum = sum + c%<span class="number">10</span>;</span><br><span class="line">            c = c/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;=threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上面的代码中  if(!hasVisited(r+1,c,visited)) 的改进： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> visited[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        backtrace(<span class="number">0</span>,<span class="number">0</span>,threshold,rows,cols,visited);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">boolean</span> visited[][])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=rows || c&lt;<span class="number">0</span> || c&gt;=cols || visited[r][c])&#123;    <span class="comment">//注意最后一个条件！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(canJoin(r,c,threshold))&#123;</span><br><span class="line">            <span class="keyword">this</span>.count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    <span class="comment">//否则这条路就断了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrace(r,c+<span class="number">1</span>,threshold,rows,cols,visited);    <span class="comment">//走右格子</span></span><br><span class="line">        backtrace(r,c-<span class="number">1</span>,threshold,rows,cols,visited);    <span class="comment">//走左格子</span></span><br><span class="line">        backtrace(r-<span class="number">1</span>,c,threshold,rows,cols,visited);    <span class="comment">//走上格子</span></span><br><span class="line">        backtrace(r+<span class="number">1</span>,c,threshold,rows,cols,visited);    <span class="comment">//走下格子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断机器人能否进入(row,col)这个格子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJoin</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> threshold)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum = sum + r%<span class="number">10</span>;</span><br><span class="line">            r = r/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum = sum + c%<span class="number">10</span>;</span><br><span class="line">            c = c/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;=threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写完代码的体会：利用递归，回溯。</p>
<p>上述代码还可以进一步改进：不用成员变量count，直接让backtrace返回值是int。</p>
<p>为什么不推荐成员变量作为返回结果：</p>
<ul>
<li><p>一个对象重复调用方法会覆盖</p>
</li>
<li><p>内存不会释放，容易造成内存溢出。</p>
</li>
</ul>
<h2 id="题3-待解决-矩阵中的路径"><a href="#题3-待解决-矩阵中的路径" class="headerlink" title="题3  待解决 矩阵中的路径"></a>题3  待解决 <a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">矩阵中的路径</a></h2><p>在牛客网做的这题，卡了很久，先睡觉了</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-06-14T15:42:37.046Z" itemprop="dateUpdated">2020-06-14 23:42:37</time>
</span><br>


        
        欢迎留言评论！
        
    </div>
    
    <footer>
        <a href="http://HFQ123.github.io">
            <img src="/images/hfq-favicon.jpg" alt="然后就">
            然后就
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" rel="tag">算法刷题</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/&title=《6月每日更新-算法题》 — 然后就的博客&pic=http://HFQ123.github.ioimages/hfq-favicon.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/&title=《6月每日更新-算法题》 — 然后就的博客&source=分享我的学习内容：Java,SpringBoot,设计模式,算法...." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《6月每日更新-算法题》 — 然后就的博客&url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/&via=http://HFQ123.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/06/11/cxsj%E9%A1%B9%E7%9B%AE-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">cxsj项目-服务端主动推送数据到客户端</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">数据结构与算法——排序学习笔记</h4>
      </a>
    </div>
  
</nav>



    














<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: '5266827d0c65b2c78ad9',
          clientSecret: 'c22957154ff2940eb1ebf851cc743c62df14878b',
          repo: 'blog_comment',
          owner: 'HFQ123',
          admin: ['HFQ123'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>然后就 &copy; 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/&title=《6月每日更新-算法题》 — 然后就的博客&pic=http://HFQ123.github.ioimages/hfq-favicon.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/&title=《6月每日更新-算法题》 — 然后就的博客&source=分享我的学习内容：Java,SpringBoot,设计模式,算法...." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《6月每日更新-算法题》 — 然后就的博客&url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/&via=http://HFQ123.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://hfq123.github.io/2020/06/01/6%E6%9C%88%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0-%E7%AE%97%E6%B3%95%E9%A2%98/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
