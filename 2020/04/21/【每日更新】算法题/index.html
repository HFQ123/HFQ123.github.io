<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>【每日更新】算法题 | 然后就的博客 | 飘风不终朝,骤雨不终日。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="算法刷题,剑指Offer">
    <meta name="description" content="20200510 晴题1【待熟练】树的子结构123456789101112131415public class Solution &amp;#123;        public boolean HasSubtree(TreeNode root1,TreeNode root2) &amp;#123;        if(root2&#x3D;&#x3D;null || root1 &#x3D;&#x3D;null)&amp;#123; &#x2F;&#x2F;题目要求的“空树不是">
<meta property="og:type" content="article">
<meta property="og:title" content="【每日更新】算法题">
<meta property="og:url" content="http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/index.html">
<meta property="og:site_name" content="然后就的博客">
<meta property="og:description" content="20200510 晴题1【待熟练】树的子结构123456789101112131415public class Solution &amp;#123;        public boolean HasSubtree(TreeNode root1,TreeNode root2) &amp;#123;        if(root2&#x3D;&#x3D;null || root1 &#x3D;&#x3D;null)&amp;#123; &#x2F;&#x2F;题目要求的“空树不是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hfq123.github.io/2020/04/21/images/image-20200428213947621.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200427235728192.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200427235839863.png">
<meta property="og:image" content="http://hfq123.github.io/images/image-20200421205013742.png">
<meta property="article:published_time" content="2020-04-21T12:17:21.000Z">
<meta property="article:modified_time" content="2020-05-09T17:15:53.910Z">
<meta property="article:author" content="然后就">
<meta property="article:tag" content="算法刷题">
<meta property="article:tag" content="剑指Offer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hfq123.github.io/2020/04/21/images/image-20200428213947621.png">
    
        <link rel="alternate" type="application/atom+xml" title="然后就的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/images/hfq-favcation.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/images/hfq-favicon.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">然后就</h5>
          <a href="mailto:1184586992@qq.com" title="1184586992@qq.com" class="mail">1184586992@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/HFQ123" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/aboutMe" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">【每日更新】算法题</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">【每日更新】算法题</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-21T12:17:21.000Z" itemprop="datePublished" class="page-time">
  2020-04-21
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200510-晴"><span class="post-toc-number">1.</span> <span class="post-toc-text">20200510 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1【待熟练】树的子结构"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">题1【待熟练】树的子结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2二进制中1的个数"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">题2二进制中1的个数</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200508-晴"><span class="post-toc-number">2.</span> <span class="post-toc-text">20200508 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-数值的整数次方"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">题1  数值的整数次方</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">思路</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200507-晴"><span class="post-toc-number">3.</span> <span class="post-toc-text">20200507 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1两个链表的第一个公共节点"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">题1两个链表的第一个公共节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-1"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">思路</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200428-晴"><span class="post-toc-number">4.</span> <span class="post-toc-text">20200428 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1字符串的排列"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">题1字符串的排列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#提示"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">提示</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-2"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码"><span class="post-toc-number">4.1.3.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#知识点"><span class="post-toc-number">4.1.4.</span> <span class="post-toc-text">知识点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-变态跳台阶"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">题2 变态跳台阶</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#提示-1"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">提示</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-3"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码-1"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#反思"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">反思</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-左旋转字符串"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">题3 左旋转字符串</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#思路-4"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题4-构建乘积数组"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">题4 构建乘积数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-5"><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">思路</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题5-和为S的连续正数序列"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">题5  和为S的连续正数序列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题6-【待改进-贪心】-剪绳子"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">题6 【待改进-贪心】 剪绳子</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200427-晴"><span class="post-toc-number">5.</span> <span class="post-toc-text">20200427 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-按之字形顺序打印二叉树"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">题1 按之字形顺序打印二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-6"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#细节"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">细节</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#顺时针打印矩阵"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">顺时针打印矩阵</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2-平衡二叉树"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">题2 平衡二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-7"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码-2"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析"><span class="post-toc-number">5.3.3.</span> <span class="post-toc-text">分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#改进"><span class="post-toc-number">5.3.4.</span> <span class="post-toc-text">改进</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3矩形覆盖"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">题3矩形覆盖</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-8"><span class="post-toc-number">5.4.1.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码-3"><span class="post-toc-number">5.4.2.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#改进-1"><span class="post-toc-number">5.4.3.</span> <span class="post-toc-text">改进</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#【待解决】题4二进制中1的个数"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">## 【待解决】题4二进制中1的个数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-9"><span class="post-toc-number">5.5.1.</span> <span class="post-toc-text">思路</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#【待解决】题4-数组中只出现一次的数字"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">## 【待解决】题4 数组中只出现一次的数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-10"><span class="post-toc-number">5.6.1.</span> <span class="post-toc-text">思路</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200426-晴"><span class="post-toc-number">6.</span> <span class="post-toc-text">20200426 晴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-把二叉树打印成多行"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">题1 把二叉树打印成多行</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#思路-11"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#提示-2"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">提示</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#细节："><span class="post-toc-number">6.3.1.</span> <span class="post-toc-text">细节：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-数组中重复的数字"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">题3 数组中重复的数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-12"><span class="post-toc-number">6.4.1.</span> <span class="post-toc-text">思路</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#【待解决】题4-数组中的逆序对"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">【待解决】题4 数组中的逆序对</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-13"><span class="post-toc-number">6.5.1.</span> <span class="post-toc-text">思路</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200422"><span class="post-toc-number">7.</span> <span class="post-toc-text">20200422</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1-二叉搜索树的第k个结点"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">题1 二叉搜索树的第k个结点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#做题前思路"><span class="post-toc-number">7.1.1.</span> <span class="post-toc-text">做题前思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#按照此思路的代码："><span class="post-toc-number">7.1.2.</span> <span class="post-toc-text">按照此思路的代码：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#【待解决】题2-字符流中第一个不重复的字符"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">【待解决】题2 字符流中第一个不重复的字符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#做题前思路-1"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">做题前思路</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#知识点-1"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">知识点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题3-统计一个数字在排序数组中出现的次数"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">题3 统计一个数字在排序数组中出现的次数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#做题前思路-2"><span class="post-toc-number">7.5.1.</span> <span class="post-toc-text">做题前思路</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20200421"><span class="post-toc-number">8.</span> <span class="post-toc-text">20200421</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题1：栈的压入、弹出序列"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">题1：栈的压入、弹出序列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码："><span class="post-toc-number">8.1.1.</span> <span class="post-toc-text">代码：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解析："><span class="post-toc-number">8.1.2.</span> <span class="post-toc-text">解析：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题2：二叉树的下一个结点"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">题2：二叉树的下一个结点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码-4"><span class="post-toc-number">8.2.1.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解析：-1"><span class="post-toc-number">8.2.2.</span> <span class="post-toc-text">解析：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#【待解决】题3-顺时针打印矩阵"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">【待解决】题3:顺时针打印矩阵</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题4-包含min函数的栈"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">题4:包含min函数的栈</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路-14"><span class="post-toc-number">8.4.1.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#知识点复习"><span class="post-toc-number">8.4.2.</span> <span class="post-toc-text">知识点复习</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码-5"><span class="post-toc-number">8.4.3.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题解"><span class="post-toc-number">8.4.4.</span> <span class="post-toc-text">题解</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题5-把数组排成最小的数"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">题5 把数组排成最小的数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#提示-3"><span class="post-toc-number">8.5.1.</span> <span class="post-toc-text">提示</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#知识点复习-1"><span class="post-toc-number">8.5.2.</span> <span class="post-toc-text">知识点复习</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码-6"><span class="post-toc-number">8.5.3.</span> <span class="post-toc-text">代码</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-【每日更新】算法题"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">【每日更新】算法题</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-21 20:17:21" datetime="2020-04-21T12:17:21.000Z"  itemprop="datePublished">2020-04-21</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="20200510-晴"><a href="#20200510-晴" class="headerlink" title="20200510 晴"></a>20200510 晴</h1><h2 id="题1【待熟练】树的子结构"><a href="#题1【待熟练】树的子结构" class="headerlink" title="题1【待熟练】树的子结构"></a>题1【待熟练】<a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88" target="_blank" rel="noopener">树的子结构</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span> || root1 ==<span class="keyword">null</span>)&#123; <span class="comment">//题目要求的“空树不是任意一个树的子结构”的逻辑在这里完成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubTree(root1,root2) || HasSubtree(root1.left,root2)|| HasSubtree(root1.right,root2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode r1,TreeNode r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1==<span class="keyword">null</span> || r1.val!=r2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubTree(r1.left,r2.left) &amp;&amp; isSubTree(r1.right,r2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此解法参考<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener">题解</a>。</p>
<p>下次复习不妨再来做一下吧！<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p>
<h2 id="题2二进制中1的个数"><a href="#题2二进制中1的个数" class="headerlink" title="题2二进制中1的个数"></a>题2<a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8" target="_blank" rel="noopener">二进制中1的个数</a></h2><p>典型的位运算的题目，记得很久以前做这题，思路是把十进制辗转相除得到二进制的同时计算1的个数，现在想想真是too young。</p>
<p>解决这题的核心就在于：</p>
<blockquote>
</blockquote>
<h1 id="20200508-晴"><a href="#20200508-晴" class="headerlink" title="20200508 晴"></a>20200508 晴</h1><h2 id="题1-数值的整数次方"><a href="#题1-数值的整数次方" class="headerlink" title="题1  数值的整数次方"></a>题1 <a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00" target="_blank" rel="noopener"> 数值的整数次方</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>上学期算法课中学过，使用分治法将时间复杂度降低到O(logn)，且采用此方法，空间复杂度也会是O(logn)。</p>
<p>这次用的是快速幂算法，时间复杂度是O(logn)，空间复杂度是O(1)。</p>
<p>接下来介绍一下快速幂的思想：</p>
<p>比如说我们要计算 3的14次方，即base=3,exponent=14,可以这样算：</p>
<p>14的二进制表示是1110，</p>
<p>1110的倒数第一位是0，且此位的权重是2^0=1，则代表了0X3^1</p>
<p>1110的倒数第二位是1，且此位的权重是2^1=2，则代表了1X3^2</p>
<p>1110的倒数第三位是1，且此位的权重是2^2=4，则代表了1X3^4</p>
<p>1110的倒数第四位是1，且此位的权重是2^3=8，则代表了1X3^8</p>
<p> 3^14 = (3^2)X(3^4)X(3^8)，我们可以用迭代的方式结合位运算进行快速幂计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> postive(base,exponent);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/postive(base,-exponent);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">postive</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span> ; <span class="comment">//末位是0还是1</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> temp = base;</span><br><span class="line">        <span class="keyword">while</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">            last = <span class="number">1</span> &amp; exponent; <span class="comment">//结果是exponent这个数二进制表示的最低位（1或者0）</span></span><br><span class="line">            <span class="keyword">if</span>(last == <span class="number">1</span>)&#123;</span><br><span class="line">                res = res * temp;        </span><br><span class="line">            &#125;</span><br><span class="line">            exponent = exponent&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            temp *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="20200507-晴"><a href="#20200507-晴" class="headerlink" title="20200507 晴"></a>20200507 晴</h1><p>最近停刷了几天题，今天是返校后第一天刷题，愧对“飘风不终朝，骤雨不终日”啊。以后每天都刷，务必在秋招前把牛客网上剑指offer和leetcode精选题刷完。。</p>
<h2 id="题1两个链表的第一个公共节点"><a href="#题1两个链表的第一个公共节点" class="headerlink" title="题1两个链表的第一个公共节点"></a>题1<a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46" target="_blank" rel="noopener">两个链表的第一个公共节点</a></h2><p>&lt;%blockquote%&gt;输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;%endblock%&gt;</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>没啥好思路，暴力解决，复杂度O(m*n)，m和n分别为两条链表的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p2 = pHead2;</span><br><span class="line">            <span class="keyword">while</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p1==p2)</span><br><span class="line">                    <span class="keyword">return</span> p1;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>巧妙地利用<a href="https://blog.csdn.net/weixin_40853073/article/details/81706773" target="_blank" rel="noopener">快慢指针</a>。</p>
<p>改进后的思路：先计算两条链表的长度，然后长链表的指针先走diff步(diff为链表的长度差)，然后两个指针一起走，直到发现相等停止。</p>
<h1 id="20200428-晴"><a href="#20200428-晴" class="headerlink" title="20200428 晴"></a>20200428 晴</h1><h2 id="题1字符串的排列"><a href="#题1字符串的排列" class="headerlink" title="题1字符串的排列"></a>题1<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7" target="_blank" rel="noopener">字符串的排列</a></h2><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>记f(str)方法返回一个ArrayList， 即返回字符串str的所有排列。</p>
<p>求f(str)时，确定第一个字符str[i]（for循环），递归调用f(str-str[i])（表示从str字符串中剔除str[i]字符后获得的子串）以获取后面的字符的排列，for循环内部再写一个foreach遍历子串的所有排列情况，拼接后加入ArrayList，返回。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
</blockquote> 

<p>可以用递归解决。先通过演算示例<strong>“求字符串s=“abc”的所有排列”</strong>，来理解本题中如何使用递归：</p>
<p>分析：“abc”的排列包括了：    ( 结果abc , acb ,bac ,  bca,  cab , cba )</p>
<ul>
<li>a + “bc”的排列                                                                结果：abc , acb                                        <ul>
<li>“bc”的排列包括了 b+”c”的排列                                           结果：bc</li>
<li>“bc”的排列包括了 c+”b”的排列                                           结果：cb</li>
</ul>
</li>
<li>b + “ac”的排列                                                                结果：bac , bca<ul>
<li>“ac”的排列包括了 a+”c”的排列                                           结果：ac</li>
<li>“ac”的排列包括了 c+”a”的排列                                           结果：ca </li>
</ul>
</li>
<li>c + “ab”的排列                                                                 结果： cab , cba<ul>
<li>“ab”的排列包括了 a+”b”的排列                                          结果： ab</li>
<li>“ab”的排列包括了 b+”a”的排列                                          结果： ba</li>
</ul>
</li>
</ul>
<p>通过上述的分析，可以看到我们<strong>把原问题分解成了若干个</strong>(实际上是s.length()个，如果不考虑重复字符的话，下文会考虑到有重复的情况)<strong>子问题</strong>，通过求解子问题并合并子问题的解，就得到原问题的解，其实采用了<strong>分治法</strong>的思想。</p>
<p>字符串s可以由s[i]和s-s[i]拼接而成，（0&lt;=i&lt;s.length()，其中s[i]表示字符串s中的某个字符，s-s[i]表示字符串s截取掉字符s[i]后生成的字符串）。</p>
<p>如上例“求abc的所有排列”这个原问题的其中一个子问题是<strong>求a + “bc”的排列</strong>，可以理解为：abc排列结果的第一位确定下来是a，<strong>后面2位的排列待定，其实它是长度比原字符串小1的子串</strong>（也就是bc，因为a已经排列在第一位了，所以把已经确定位置的字符a从原字符串abc中剔除，得到bc）<strong>的排列结果</strong>，同理地，求字符串bc这个问题又可以分解成 b+”c”的排列和 c+”b”的排列两个子问题。</p>
<p>我们知道，在分治法的思想中，当子问题规模较大时继续采用递归求解子问题，当子问题规模变小时直接求解，以免持续递归无法终止。在本例中，递归的终止条件就是当求解的子问题的字符串长度为1时，只有其自身一种排列结果，直接返回，无需继续递归。</p>
<p>写代码之前，还需要关注到题目中的两个细节：</p>
<ul>
<li>排列结果按字典序打印</li>
</ul>
<p>比如说如果要求字符串”cba”的排列结果，我们可以先对字符串内部的字符排序，变成“abc”，再求结果。</p>
<ul>
<li>可能有重复字符</li>
</ul>
<p>比如说要求字符串”aab”的排列结果，按照上述案例的思路分析，如果分解成三个问题：a +”ab”的排列，a+”ab”的排列，b+“aa”的排列，可以发现第一种情况和第二种情况重复了，所以为避免重复，实际上在这只需要分解成两个子问题：a +”ab”的排列，b+“aa”的排列。在编程的时候，用一个HashSet保存第一个字符，来保证不重复。</p>
<p>说了这么多，接下来看看代码怎么写吧。</p>
<p>f(str)=str[0]f(str-)+str[1]f(str-)</p>
<p>str-</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span>  ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">char</span> [] chars = str.toCharArray();</span><br><span class="line">       Arrays.sort(chars);</span><br><span class="line">       <span class="keyword">return</span> f(String.valueOf(chars));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**此函数用于求字符串str的所有排列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList &lt;String&gt; f(String str)&#123;</span><br><span class="line">        ArrayList &lt;String&gt; list = <span class="keyword">new</span> ArrayList &lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            list.add(str);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet &lt;Character&gt; set = <span class="keyword">new</span> HashSet(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = set.add(str.charAt(i));<span class="comment">//表示当前字符是否第一次出现</span></span><br><span class="line">            <span class="keyword">if</span>(success)&#123;  </span><br><span class="line">                <span class="comment">//排列的第一位已确定为str.charAt(i)，递归获得后几位，剔除已确定的第一位的子串的所有排列</span></span><br><span class="line">                ArrayList &lt;String&gt; subList = f(str.substring(<span class="number">0</span>,i)+str.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(String sub : subList)&#123;</span><br><span class="line">                    list.add(str.charAt(i)+sub);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><p>String和char[]的转化</p>
<ul>
<li>char [] chars = str.toCharArray()  </li>
<li>String.valueOf(chars)</li>
</ul>
</li>
<li><p>boolean success = set.add(str.charAt(i));</p>
<ul>
<li>set是HashSet类型，插入成功（插入前不存在这个元素），set.add()的返回值才为true</li>
</ul>
</li>
<li><p>substring的用法</p>
<ul>
<li><p>str.substring(0,i) 包含str[0]~~str[i-1]，不包含str[i]</p>
</li>
<li><p>str.substring(i+1)，包含str[i+1]~~str的末尾</p>
</li>
</ul>
</li>
</ul>
<h2 id="题2-变态跳台阶"><a href="#题2-变态跳台阶" class="headerlink" title="题2 变态跳台阶"></a>题2 <a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">变态跳台阶</a></h2><p>   &lt;%blockquote%&gt;</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p> &lt;%endblockquote%&gt;</p>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>dp====&gt;数学归纳</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>回顾一下 “跳台阶”这题。</p>
<p> &lt;%blockquote%&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 &lt;%endblockquote%&gt;</p>
<p>一开始不好理解，先按照题意举几个例子：</p>
<p>当n=1， 1种跳法（直接跳1）</p>
<p>当n=2,    2种跳法，（先跳1，再跳1）+(直接跳2级)</p>
<p>当n=3，</p>
<ul>
<li>第一步先跳1级，剩下2级，有2种跳法（查看上面当n=2的情况=2）</li>
<li>第一步先跳2级，剩下1级，有1种跳法（查上面当n=1的情况=1）</li>
<li>所以说，当n=3，总共有2+1=3种</li>
</ul>
<p>总结出一个通用的式子：记n阶台阶的跳法有f(n)种，都可以有两种做法：</p>
<ul>
<li><p>先跳1级，剩下了n-1级,  【f(n-1)种跳法】</p>
<ul>
<li>而剩下的n-1级的跳法又有以下两种情况<ul>
<li>先跳1级，再跳n-2级</li>
<li>先跳2级，再跳n-3级</li>
</ul>
</li>
</ul>
</li>
<li><p>先跳2级，剩下了n-2级， 【f(n-2)种跳法】</p>
<p>​    ……………………</p>
</li>
</ul>
<p>所以f(n)=f(n-1)+f(n-2)，其实这个模型符合斐波那契数列。</p>
<hr>
<p>回到这题。</p>
<p>先写几个找找规律</p>
<ul>
<li><p>当 n = 0, 0种</p>
</li>
<li><p>当 n = 1 ,跳1级 1种</p>
</li>
<li><p>当 n = 2   2种</p>
<ul>
<li>先跳1，剩1级，1种</li>
<li>先跳2，剩0级，1种 </li>
</ul>
</li>
<li><p>当 n =3  结果：4种</p>
<ul>
<li>先跳1级，剩2级，  f(2) = 2种</li>
<li>先跳2级,  剩1级，  f(1) = 1种</li>
<li>先跳3级, 剩0级， 1种</li>
</ul>
</li>
<li><p>当 n =4  结果：8种</p>
<ul>
<li>先跳1级，剩3级，f(3) =4种</li>
<li>先跳2级，剩2级，f(2) = 2种</li>
<li>先跳3级，剩1级， f(1) =  1种</li>
<li>先跳4级，剩0级， 1种</li>
</ul>
</li>
<li><p>可以看出，如下规律 f(n) = f(n-1)+f(n-2) +…f(1)+1，为了让式子看起来和谐一点，我们可以让f(0)=1,则式子可以表示成f(n) = f(n-1)+f(n-2) +…f(1)+f(0)。 不难发现 ，f(n-1) = f(n-2)+f(n-3)+….f(0)，所以f(n) = 2 *f(n-1) </p>
</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span>[target]; <span class="comment">// dp[i]表示剩下i级时的跳法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//默认为1，可以表示剩0级的时候有1种跳法</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;target;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">2</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*dp[target-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数学归纳后的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>有了“跳台阶”这题的基础，其实很容易想到上述的归纳。</p>
<p>最开始做这题可能会想到递归–&gt;然后发现递归会多次重复计算，可以动态规划—&gt;贪心–&gt;而又发现这题又可以用公式归纳出来，直接求解。</p>
<h2 id="题3-左旋转字符串"><a href="#题3-左旋转字符串" class="headerlink" title="题3 左旋转字符串"></a>题3 <a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec" target="_blank" rel="noopener">左旋转字符串</a></h2><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>根据定义求解，一步一个脚印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> first = str.charAt(<span class="number">0</span>);</span><br><span class="line">            String sub = str.substring(<span class="number">1</span>);  <span class="comment">//截取字符串</span></span><br><span class="line">            str = sub+first;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后：一步到位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        n = n % str.length();  <span class="comment">//把这句注释竟然也可以。</span></span><br><span class="line">        <span class="keyword">return</span> str.substring(n) + str.substring(<span class="number">0</span>,n); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题4-构建乘积数组"><a href="#题4-构建乘积数组" class="headerlink" title="题4 构建乘积数组"></a>题4 <a href="">构建乘积数组</a></h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>一开始没什么思路。先写一个暴力解决，观察哪里有改进的空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="comment">//暴力解法O(n^2)</span></span><br><span class="line">        <span class="keyword">int</span> [] B = <span class="keyword">new</span> <span class="keyword">int</span> [A.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; A.length;j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=i)</span><br><span class="line">                    mul*=A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            B[i] = mul;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法完全是使用定义做的，比如说当A[n]=5，则B[3] = A[0]XA[1]XA[2]XA[4]，B[4]=A[0]XA[1]XA[2]XA[3]，可以看到计算B[3]和B[4]时有重叠计算的部分（A[0]XA[1]XA[2]）。要想优化，我们就看看是否可以只计算一次重叠的部分。</p>
<p>确实有这样的优化方法，可以将时间复杂度从O(n^2)优化成O(n)。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="../images/image-20200428213947621.png" alt="image-20200428213947621" title="">
                </div>
                <div class="image-caption">image-20200428213947621</div>
            </figure>

<p>上图参考了《剑指Offer》，基于此思路的改进代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> left [] = <span class="keyword">new</span> <span class="keyword">int</span> [A.length];    <span class="comment">//左下角计算的中间结果(含对角线)</span></span><br><span class="line">        <span class="keyword">int</span> right[] = <span class="keyword">new</span> <span class="keyword">int</span> [A.length];    <span class="comment">//右下角计算的中间结果(含对角线)</span></span><br><span class="line">        <span class="keyword">int</span> B[] = <span class="keyword">new</span> <span class="keyword">int</span> [A.length];        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                left[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = left[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==A.length-<span class="number">1</span>)&#123;</span><br><span class="line">                right[i] = <span class="number">1</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>] * A[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            B[i] = left [i] *right [i]; <span class="comment">//在这个循环就可以直接出B[i]，不用再重新写一个for循环。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步改进</p>
<p>进一步观察，会发现其实没必要设置left、right这两个辅助数组，可以直接在B[]数组上操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> B[] = <span class="keyword">new</span> <span class="keyword">int</span> [A.length];        <span class="comment">//返回结果</span></span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++)&#123;  <span class="comment">//计算 B[i]左边的乘积（含对角线）</span></span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>; <span class="comment">//temp记录B[i]右边的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length-<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--)&#123;    </span><br><span class="line">            temp = temp * A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题5-和为S的连续正数序列"><a href="#题5-和为S的连续正数序列" class="headerlink" title="题5  和为S的连续正数序列"></a>题5  <a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe" target="_blank" rel="noopener">和为S的连续正数序列</a></h2><p>一开始没啥思路，暴力解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt; &gt; arrayList = <span class="keyword">new</span>  ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">       <span class="comment">//i=sum是想当然的，可以优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sum; i&gt;=<span class="number">2</span>; i--)&#123; <span class="comment">//设i个连续数字，x,x+1,x+2.....x+(i-1)的和为sum，</span></span><br><span class="line">           <span class="keyword">int</span> temp = sum;</span><br><span class="line">            <span class="comment">//可以利用等差数列公式，不用这么麻烦</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;i ;j++)&#123;  <span class="comment">//减去每个数字的常数项，以求出x的取值 </span></span><br><span class="line">               temp -= j;		<span class="comment">// temp-0-1-2-...(i-1)，可以直接算出temp - (i/2)*(i-1),不过写的时候要写temp - i*(i-1)/2,否则i为奇数时就不对了。</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> x = temp/i;</span><br><span class="line">           <span class="keyword">if</span>(temp % i == <span class="number">0</span> &amp;&amp; x&gt;<span class="number">0</span>)&#123;   <span class="comment">//temp / i的结果必须是整数，且题目要求是正数</span></span><br><span class="line">               ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;i ;j++)&#123; <span class="comment">//逐个将x,x+1....x+(i-1)加入list</span></span><br><span class="line">                   list.add(x+j);</span><br><span class="line">               &#125;</span><br><span class="line">               arrayList.add(list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用数学知识（等差数列求和公式变形），对上面的代码改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt; &gt; arrayList = <span class="keyword">new</span>  ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = (<span class="keyword">int</span>) Math.sqrt(<span class="number">2</span> * sum) ; i&gt;=<span class="number">2</span>; i--)&#123; <span class="comment">//i表示连续数字的个数</span></span><br><span class="line">           <span class="keyword">int</span> temp = sum - i*(i-<span class="number">1</span>)/<span class="number">2</span>;  <span class="comment">//减去常数项</span></span><br><span class="line">           <span class="keyword">if</span>(temp % i == <span class="number">0</span> &amp;&amp; temp/i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">int</span> x = temp/i;</span><br><span class="line">               ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;i ;j++)&#123;</span><br><span class="line">                   list.add(x+j);</span><br><span class="line">               &#125;</span><br><span class="line">               arrayList.add(list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做，复杂度变成了O(根号s)</p>
<p>还有一个思路是 双指针，控制滑动窗口，可以试试看。</p>
<h2 id="题6-【待改进-贪心】-剪绳子"><a href="#题6-【待改进-贪心】-剪绳子" class="headerlink" title="题6 【待改进-贪心】 剪绳子"></a>题6 【待改进-贪心】 <a href="">剪绳子</a></h2><p>最近递归的题目做的多，思路挺顺的了，这题没想多久，自然而然就想到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  m =<span class="number">2</span> ;m&lt;=target; m++)&#123; <span class="comment">//剪几刀</span></span><br><span class="line">            <span class="keyword">if</span>(cut(target,m) &gt;max)</span><br><span class="line">                max = cut(target,m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算n段绳子剪去m段的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="comment">//剪下长度为n的绳子，剪m段,每段最少为1</span></span><br><span class="line">       <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;    <span class="comment">//m=0表示不需要剪了，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;      <span class="comment">//这里要是return 0，做乘法后结果就都是0了，不对</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ;i&lt;= n-(m-<span class="number">1</span>);i++)&#123; <span class="comment">//第一刀剪掉i，i最少为1，最多为n-(m-1)以确保后面剩余的m-1刀每次都能剪1</span></span><br><span class="line">            <span class="keyword">if</span>(i * cut(n-i,m-<span class="number">1</span>) &gt;max)</span><br><span class="line">                max = i * cut(n-i,m-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max; <span class="comment">//返回 i* 的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>截至今日结束，进度： 40/67</strong></p>
<h1 id="20200427-晴"><a href="#20200427-晴" class="headerlink" title="20200427 晴"></a>20200427 晴</h1><h2 id="题1-按之字形顺序打印二叉树"><a href="#题1-按之字形顺序打印二叉树" class="headerlink" title="题1 按之字形顺序打印二叉树"></a>题1 <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0" target="_blank" rel="noopener">按之字形顺序打印二叉树</a></h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>这题和昨天做的”<a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288" target="_blank" rel="noopener">把二叉树打印成多行</a>“很像。都是用层序遍历的思路，区别就在于当访问行数是偶数，要将该行元素的ArrayList反转。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul>
<li>Collections.reverse(arrayList); import java.util.Collections;</li>
<li>arrayList.add() ,queue.offer()。一开始没注意写了arrayList.offer()报错了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>   <span class="keyword">new</span> ArrayList&lt;&gt;();          </span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue &lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(pRoot);</span><br><span class="line">        ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> nextLevelNum = <span class="number">1</span>; <span class="comment">//记录还要访问几个元素可以到下一层，即每层元素的个数，初始化是1</span></span><br><span class="line">        <span class="keyword">boolean</span> needReverse = <span class="keyword">false</span>; <span class="comment">//记录当前行是否需要反转</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//队首节点出队列</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">//将节点值加入row</span></span><br><span class="line">            row.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            nextLevelNum--;</span><br><span class="line">            <span class="keyword">if</span>(nextLevelNum == <span class="number">0</span>)&#123;<span class="comment">//说明该层访问完了</span></span><br><span class="line">                <span class="keyword">if</span>(needReverse)&#123;</span><br><span class="line">                    Collections.reverse(row);</span><br><span class="line">                &#125;</span><br><span class="line">                rows.add(row);</span><br><span class="line">                row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//重新设定nextLevelNum和needReverse</span></span><br><span class="line">                nextLevelNum = queue.size();</span><br><span class="line">                needReverse = !needReverse;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><a href="https://blog.nowcoder.net/n/40241c8ec50f4b3daaf2d07f18712222?f=comment" target="_blank" rel="noopener">参考</a></p>
<h2 id="题2-平衡二叉树"><a href="#题2-平衡二叉树" class="headerlink" title="题2 平衡二叉树"></a>题2 <a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222" target="_blank" rel="noopener">平衡二叉树</a></h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>我的思路就是根据平衡二叉树的定义解决：一棵树是平衡二叉树，则其左右子树高度差不大于1且左右子树都是平衡二叉树。这种做法是最直观的，但是效率一般（不过也能AC）。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null)</span><br><span class="line">            return true;</span><br><span class="line">        int balanceFactor &#x3D; treeHeight(root.left) - treeHeight(root.right);</span><br><span class="line">        return Math.abs(balanceFactor) &lt;&#x3D; 1 &amp;&amp; IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public int treeHeight(TreeNode node)&#123;</span><br><span class="line">        if(node &#x3D;&#x3D; null)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftHeight &#x3D; treeHeight(node.left);</span><br><span class="line">        int rightHeight &#x3D;  treeHeight(node.right);</span><br><span class="line">        return Math.max(leftHeight,rightHeight)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在计算每个节点的深度的时候，进行了多次的重复计算，这样计算的开销还是比较大的。（类比递归求斐波那契数列的重复计算）</p>
<p>又注意到实际上在计算树高时（上面的treeHeight方法）就要计算左右子树高度，这时候就可以判断是否平衡。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>参考了<a href="https://blog.csdn.net/dawn_after_dark/article/details/81702988" target="_blank" rel="noopener">博客</a>。</p>
<p>核心：<strong>把求树的深度与判断树的平衡融合在一起。</strong></p>
<p>改进思路就是在计算root高度的同时，就判断是否出现过不平衡的节点，使用一个成员变量isBalance存放结果（作为全局变量），一旦出现了不平衡节点，isBalance被置为false,则可以停止后续的递归计算。这样做效率比原思路好，只要调用一次treeHeight(root)即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isBalance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当root=null，返回isBalance=true。</span></span><br><span class="line">        isBalance = <span class="keyword">true</span>;  <span class="comment">//默认为true</span></span><br><span class="line">        treeHeight(root);</span><br><span class="line">        <span class="keyword">return</span> isBalance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeHeight</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span> || isBalance == <span class="keyword">false</span>) <span class="comment">//如果isBalance已被置为false，可以直接返回，不用再判断了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = treeHeight(node.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight =  treeHeight(node.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftHeight-rightHeight) &gt; <span class="number">1</span>)&#123;  <span class="comment">//判断root是否不平衡</span></span><br><span class="line">            isBalance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题3矩形覆盖"><a href="#题3矩形覆盖" class="headerlink" title="题3矩形覆盖"></a>题3<a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13" target="_blank" rel="noopener">矩形覆盖</a></h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>其实该模型符合斐波那契数列。</p>
<p>f(n) = f(n-1)+f(n-2)，</p>
<p>n=0的时候</p>
<ul>
<li>0种</li>
</ul>
<p>n = 1 的时候</p>
<ul>
<li>只能横着覆盖，一种</li>
</ul>
<p>n = 2 的时候</p>
<ul>
<li>可以横着和竖着覆盖，两种</li>
</ul>
<p>n = 3 的时候</p>
<ul>
<li>第三级竖着覆盖，用了一级，剩下 n = 2，有两种覆盖方法</li>
<li>第三级横着覆盖，用了两级，剩下 n = 1，有一种覆盖方法</li>
<li>总共有 3 种</li>
</ul>
<p>n = 4 的时候</p>
<ul>
<li>第 4 级竖着覆盖，用了一级，剩下 n = 3，有三种覆盖方法</li>
<li>第 4 级横着覆盖，用了两级，剩下 n = 2，有两种覆盖方法</li>
<li>总共有 5 种方法</li>
</ul>
<p>n = n 的时候</p>
<ul>
<li>第 n 级竖着覆盖，用了一级，剩下 n = n - 1，所以关注第 n - 1 种有几种覆盖方法</li>
<li>第 n 级横着覆盖，用了两级，剩下 n = n - 2，所以关注第 n - 2 种有几种覆盖方法</li>
<li>总和为两种情况的总和</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/images/image-20200427235728192.png" alt="第n级竖着放"></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200427235839863.png" alt="第n级横着放" title="">
                </div>
                <div class="image-caption">第n级横着放</div>
            </figure>

<h3 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h3><p>递归做会有多次的重复计算，可以考虑空间换时间，动态规划求斐波那契数列。</p>
<p>此处略。</p>
<h2 id="【待解决】题4二进制中1的个数"><a href="#【待解决】题4二进制中1的个数" class="headerlink" title="## 【待解决】题4二进制中1的个数"></a>## 【待解决】题4<a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8" target="_blank" rel="noopener">二进制中1的个数</a></h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>题目要求是求整数的补码中的1的个数。</p>
<p>我们知道，对于正数，其补码就是原码。如十进制数9的补码=10的原码=0，1001（首位0是符号位）。</p>
<p>而十进制数-9的原码=1，1001（首位1是符号位），其补码是：1，0111</p>
<p>我一开始想的是先算出补码的二进制表示，再计算1的个数，这种效率太低了，要用位运算，这块知识有些忘了，还要再复习一下。</p>
<h2 id="【待解决】题4-数组中只出现一次的数字"><a href="#【待解决】题4-数组中只出现一次的数字" class="headerlink" title="## 【待解决】题4 数组中只出现一次的数字"></a>## 【待解决】题4 <a href="">数组中只出现一次的数字</a></h2><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>位运算。</p>
<p>位运算异或（XOR）的特点：</p>
<ul>
<li><p>0 ^ 0 = 0        1 ^ 1 = 0        1 ^ 0 = 1            0 ^ 1 = 1 </p>
</li>
<li><p>a  ^  a = 0 ,因为a的二进制^a的二进制每一位异或结果都是0。</p>
</li>
<li><p>a  ^ 0 = a , 因为a的二进制的每一位与0的异或结果都是本身 </p>
</li>
<li><p>结合上述两点，a ^ b ^ a = b</p>
</li>
</ul>
<hr>
<h1 id="20200426-晴"><a href="#20200426-晴" class="headerlink" title="20200426 晴"></a>20200426 晴</h1><h2 id="题1-把二叉树打印成多行"><a href="#题1-把二叉树打印成多行" class="headerlink" title="题1 把二叉树打印成多行"></a>题1 <a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288" target="_blank" rel="noopener">把二叉树打印成多行</a></h2><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>显然，此题是层序遍历的应用。二叉树的层序遍历很简单，使用队列就能完成，本题要在层序遍历的基础上使用一个变量，来记录下一层的元素个数，每当遍历完了一层，就更新这个值，且换行。</p>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><ul>
<li>题目给的方法返回值是 ArrayList&lt;ArrayList<Integer> &gt; ，一开始没反应过来，后来仔细一想，是每行的元素单独保存在一个ArrayList里，再返回所有行的元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList &lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> nextLevelNum = <span class="number">1</span>; <span class="comment">//记录还要访问几个元素才到下一层,初始值为1,因为第一层肯定只有根节点一个元素</span></span><br><span class="line">        Queue &lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(pRoot);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        ArrayList &lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();<span class="comment">//当前队头节点出队列</span></span><br><span class="line">            row.add(node.val);    <span class="comment">//将节点的元素值加入到row列表</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123; <span class="comment">//并将其非空子节点加入队列</span></span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            nextLevelNum--;  <span class="comment">//每访问完了一个节点，nextLevelNum就减1</span></span><br><span class="line">            <span class="keyword">if</span>(nextLevelNum == <span class="number">0</span>)&#123; <span class="comment">//说明这一层已经访问完了，要重新设置它的取值,它的取值其实就是当前队列的元素个数</span></span><br><span class="line">                nextLevelNum = queue.size();</span><br><span class="line">                rows.add(row);</span><br><span class="line">                row = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><ul>
<li><p>队列操作的API、导入所在包，nextLevelNum这个变量是本题精髓！</p>
</li>
<li><pre><code class="java">    <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)
        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList &lt;&gt;();  一开始写的<span class="keyword">return</span> <span class="keyword">null</span>，无法通过！
&lt;!--￼<span class="number">19</span>--&gt;


</code></pre>
</li>
</ul>
<h2 id="题3-数组中重复的数字"><a href="#题3-数组中重复的数字" class="headerlink" title="题3 数组中重复的数字"></a>题3 <a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8" target="_blank" rel="noopener">数组中重复的数字</a></h2><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>HashSet 时间复杂度O(n)  空间复杂度O(n)</p>
<p>参考别人的：重排数组 ：时间复杂度O(n)，空间复杂度O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>数组中重复的数字 </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet &lt;Integer&gt; set = <span class="keyword">new</span> HashSet &lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numbers.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(numbers[i]))&#123;</span><br><span class="line">                set.add(numbers[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="【待解决】题4-数组中的逆序对"><a href="#【待解决】题4-数组中的逆序对" class="headerlink" title="【待解决】题4 数组中的逆序对"></a>【待解决】题4 <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5" target="_blank" rel="noopener">数组中的逆序对</a></h2><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><ul>
<li>暴力求解：从第一个元素开始，判断后面比它小的元素的个数  O(n^2)，不出所料，运行超时，通过50%的用例。</li>
<li>【待学习】提示：归并的改进</li>
</ul>
<hr>
<h1 id="20200422"><a href="#20200422" class="headerlink" title="20200422"></a>20200422</h1><h2 id="题1-二叉搜索树的第k个结点"><a href="#题1-二叉搜索树的第k个结点" class="headerlink" title="题1 二叉搜索树的第k个结点"></a>题1 <a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a" target="_blank" rel="noopener">二叉搜索树的第k个结点</a></h2><h3 id="做题前思路"><a href="#做题前思路" class="headerlink" title="做题前思路"></a>做题前思路</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。根据BST中序遍历结果是升序的这一性质，可以中序遍历，直到遍历到第k个结点。</p>
<h3 id="按照此思路的代码："><a href="#按照此思路的代码：" class="headerlink" title="按照此思路的代码："></a>按照此思路的代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序递归，成功AC</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;    <span class="comment">//num表示当前中序遍历已经访问了几个元素</span></span><br><span class="line">    TreeNode node; <span class="comment">//node存放结果</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       inorder(pRoot,k);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left,k);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span>(num==k)&#123;</span><br><span class="line">            <span class="keyword">this</span>.node=node;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">//结束后续的访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：就算找到了Kth结点也会遍历完整个BST。时间复杂度是O(N)</p>
<p>改进：可以考虑非递归实现中序遍历，这样就能在找到Kth结点后结束遍历。</p>
<h2 id="【待解决】题2-字符流中第一个不重复的字符"><a href="#【待解决】题2-字符流中第一个不重复的字符" class="headerlink" title="【待解决】题2 字符流中第一个不重复的字符"></a>【待解决】题2 <a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720" target="_blank" rel="noopener">字符流中第一个不重复的字符</a></h2><h2 id="做题前思路-1"><a href="#做题前思路-1" class="headerlink" title="做题前思路"></a>做题前思路</h2><p>hashmap</p>
<h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>LinkedHashMap和HashMap的差别<ul>
<li>LinkedHashMap</li>
<li><a href="https://www.cnblogs.com/lykbk/p/dfdfdffd34534343434.html" target="_blank" rel="noopener">Hashmap遍历方法</a></li>
</ul>
</li>
</ul>
<h2 id="题3-统计一个数字在排序数组中出现的次数"><a href="#题3-统计一个数字在排序数组中出现的次数" class="headerlink" title="题3 统计一个数字在排序数组中出现的次数"></a>题3 <a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2" target="_blank" rel="noopener">统计一个数字在排序数组中出现的次数</a></h2><h3 id="做题前思路-2"><a href="#做题前思路-2" class="headerlink" title="做题前思路"></a>做题前思路</h3><ul>
<li><p>法1：二分查找定位该数字，再找左边和右边相等的元素个数。</p>
</li>
<li><p><a href="https://www.cnblogs.com/lishanlei/p/10707678.html" target="_blank" rel="noopener">多种方法改进参考文章</a></p>
<ul>
<li>最后采用的方法：因为数组中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by hfq on 2020/4/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@used</span> to:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>数字在排序数组中出现的次数 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BinarySearch(array,(<span class="keyword">float</span>)(k+<span class="number">0.5</span>)) - BinarySearch(array,(<span class="keyword">float</span>)(k-<span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回目标t插入array的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">float</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;   <span class="comment">//&lt;= 等号不可遗漏！！</span></span><br><span class="line">            mid = j+(i-j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; t)&#123;  <span class="comment">//在左边查找</span></span><br><span class="line">                j = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; t)&#123; <span class="comment">//在右边查找</span></span><br><span class="line">                i = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//实际上不可能发生，可以和上面的else if合并</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;   <span class="comment">//array[mid]在array[i]和array[j]中添加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int [] a = &#123;3,3,3,3&#125;;</span></span><br><span class="line">        <span class="keyword">int</span> [] a = &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(BinarySearch(a, (<span class="keyword">float</span>) <span class="number">2.5</span>));</span><br><span class="line">        System.out.println(BinarySearch(a, (<span class="keyword">float</span>) <span class="number">3.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析：这种做法在各种情况下效率都比较高。 </p>
<p>当数组是：[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]，如果采用法1，效率退化成O(n),而这种方法时间复杂度还是O(lgn)级别的</p>
<hr>
<h1 id="20200421"><a href="#20200421" class="headerlink" title="20200421"></a>20200421</h1><h2 id="题1：栈的压入、弹出序列"><a href="#题1：栈的压入、弹出序列" class="headerlink" title="题1：栈的压入、弹出序列"></a>题1：<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106" target="_blank" rel="noopener">栈的压入、弹出序列</a></h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA==<span class="keyword">null</span>||pushA.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> stack [] = <span class="keyword">new</span> <span class="keyword">int</span>[pushA.length];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pushIndex=<span class="number">0</span>;</span><br><span class="line">        stack[size++] = pushA[pushIndex++];</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pushIndex&lt;pushA.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stack[size-<span class="number">1</span>]!=popA[current])</span><br><span class="line">            &#123;</span><br><span class="line">                stack[size++] = pushA[pushIndex++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                size--;</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (size!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack[size-<span class="number">1</span>]!=popA[current]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                size--;</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>以输入{1,2,3,4,5}，{4,5,3,2,1}为例。</p>
<p>借助一个辅助栈，遍历压栈序列，先将第一个元素放在栈中，这里是1，然后判断栈顶元素是不是出栈序列的第一个元素，这里1≠4，所以继续压栈，直到相等之后开始出栈，出栈一个元素，对于出栈序列向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p> 我的代码没有用JDK提供的Stack，而是用一个数组+size模拟栈。</p>
<h2 id="题2：二叉树的下一个结点"><a href="#题2：二叉树的下一个结点" class="headerlink" title="题2：二叉树的下一个结点"></a>题2：<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e" target="_blank" rel="noopener">二叉树的下一个结点</a></h2><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeLinkNode successor = <span class="keyword">null</span>; <span class="comment">//表示后续结点，保存返回结果</span></span><br><span class="line">        <span class="comment">//当这个结点有右子树，那么其后续结点必然在其右子树中的最小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            successor = pNode.right;  </span><br><span class="line">            <span class="keyword">while</span>(successor.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                successor = successor.left;  <span class="comment">//一直向左走找最小的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode.next != <span class="keyword">null</span>)&#123;  <span class="comment">//没有右子树但是有根节点</span></span><br><span class="line">            successor = pNode;  </span><br><span class="line">            <span class="keyword">while</span>(successor.next != <span class="keyword">null</span> &amp;&amp; successor == successor.next.right)&#123;</span><br><span class="line">                successor = successor.next; <span class="comment">//当此结点始终是其父节点的右子树的时候，逐级找父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            successor = successor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h3><p>求二叉树某一结点的后续结点。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/image-20200421205013742.png" alt="image-20200421205013742" title="">
                </div>
                <div class="image-caption">image-20200421205013742</div>
            </figure>

<p>根据这个pNode结点的状态，分为三种情况求解:</p>
<ul>
<li>pNode存在右子树，那么其后续结点必然在其右子树中。<ul>
<li>这是由中序遍历的定义决定的：若某节点存在右子树，那么访问完这个结点后访问的下一个结点必然是右子树中的某个结点。</li>
<li>返回结果是 pNode.right.left.left.left…. </li>
</ul>
</li>
<li>pNode不存在右子树，但存在父节点，那么其后续结点是其祖父结点，或者是null</li>
<li>既不存在右子树，也不存在父节点，返回null</li>
</ul>
<p>提示：</p>
<ul>
<li><p>可以借助二叉树的一种特殊情况——二叉搜索树思考这题，上述代码的注释就是这样做的，表面看我们考虑的是特殊情况，但是实际上这样做对二叉树具有普遍性。</p>
</li>
<li><p>另外提一下，这道题目有点坑的地方是：包含指向父结点的指针的变量名是next，不是parent，注意一下。</p>
</li>
</ul>
<h2 id="【待解决】题3-顺时针打印矩阵"><a href="#【待解决】题3-顺时针打印矩阵" class="headerlink" title="【待解决】题3:顺时针打印矩阵"></a>【待解决】题3:<a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a" target="_blank" rel="noopener">顺时针打印矩阵</a></h2><p>被这道题虐了很久。。</p>
<p>一直会忽略某些情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hfq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addElementToList(matrix,<span class="number">0</span>,matrix.length-<span class="number">1</span>,<span class="number">0</span>,matrix[<span class="number">0</span>].length-<span class="number">1</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addElementToList</span><span class="params">(<span class="keyword">int</span> [][] matrix,<span class="keyword">int</span> rowsMin,<span class="keyword">int</span> rowsMax,<span class="keyword">int</span> colsMin,<span class="keyword">int</span> colsMax,ArrayList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(colsMax&lt;<span class="number">0</span> &amp;&amp; rowsMax&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = colsMin; i&lt;=colsMax ; i++)&#123; <span class="comment">//从左往右</span></span><br><span class="line">            list.add(matrix[rowsMin][i]);</span><br><span class="line">           <span class="comment">// System.out.println(matrix[rowsMin][i]);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rowsMax&gt;rowsMin)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = rowsMin+<span class="number">1</span>; i&lt;=rowsMax ; i++)&#123; <span class="comment">//从上往下</span></span><br><span class="line"><span class="comment">//            System.out.println("i="+i+",colsMax"+colsMax);</span></span><br><span class="line">                list.add(matrix[i][colsMax]);</span><br><span class="line">                <span class="comment">//System.out.println(matrix[i][colsMax]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(colsMax-<span class="number">1</span>&gt;colsMin)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = colsMax-<span class="number">1</span>; i&gt;=colsMin ; i--)&#123;  <span class="comment">//从右往左</span></span><br><span class="line">                list.add(matrix[rowsMax][i]);</span><br><span class="line">               <span class="comment">// System.out.println(matrix[rowsMax][i]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(colsMax-colsMin&gt;=<span class="number">1</span> &amp;&amp; colsMax &gt; colsMin )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = rowsMax-<span class="number">1</span>; i&gt;=rowsMin+<span class="number">1</span> ; i--)&#123; <span class="comment">//从下往上</span></span><br><span class="line">                list.add(matrix[i][colsMin]);</span><br><span class="line">              <span class="comment">//  System.out.println(matrix[i][colsMin]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addElementToList(matrix,rowsMin+<span class="number">1</span>,rowsMax-<span class="number">1</span>,colsMin+<span class="number">1</span>,colsMax-<span class="number">1</span>,list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int a [][] =&#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;,&#123;4&#125;,&#123;5&#125;&#125;;</span></span><br><span class="line"><span class="comment">//        int a [][] =&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;;</span></span><br><span class="line">        <span class="keyword">int</span> a [][] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = printMatrix(a);</span><br><span class="line">        <span class="keyword">for</span>(Integer integer:integers)&#123;</span><br><span class="line">            System.out.printf(integer+<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题4-包含min函数的栈"><a href="#题4-包含min函数的栈" class="headerlink" title="题4:包含min函数的栈"></a>题4:<a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49" target="_blank" rel="noopener">包含min函数的栈</a></h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
<h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>一开始我的想法很简单，用一个使用一个变量记录当前的最小元素，如果新压入栈的元素更小，就更新它。</p>
<p>但是仔细一想，这种做法有一个问题，假如记录的最小元素出栈了，就没办法以O(1）的时间复杂度获取新的最小元素了，所以在保存最小元素的同时，有必要保存最小元素出栈后次要小的元素，同理，也要保存第三小的元素….</p>
<p>所以，要用一个辅助栈来保存当前的最小元素以及之前的的最小元素，栈顶就是当前栈的最小元素，栈顶元素的下一个元素就是这个元素出栈后的新的最小元素。</p>
<ul>
<li>每次压栈时，如果压入的元素小于当前最小元素，则也将其压入辅助栈，否则，则将上一个最小元素压入辅助栈。</li>
<li>每次出栈时，弹出元素的同时也弹出辅助栈的元素。</li>
</ul>
<h3 id="知识点复习"><a href="#知识点复习" class="headerlink" title="知识点复习"></a>知识点复习</h3><p>Stack的API</p>
<ul>
<li>peek()</li>
<li>size()</li>
<li>pop()</li>
<li>push()</li>
</ul>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();  <span class="comment">//数据栈 </span></span><br><span class="line">    <span class="keyword">public</span> Stack &lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();; <span class="comment">//辅助栈</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stack.size()==<span class="number">1</span>)&#123;  <span class="comment">//现在是1，说明压栈前是0。</span></span><br><span class="line">            minStack.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(node&lt;minStack.peek() ? node : minStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>关键字 ：最小值辅助栈</p>
<h2 id="题5-把数组排成最小的数"><a href="#题5-把数组排成最小的数" class="headerlink" title="题5 把数组排成最小的数"></a>题5 <a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993" target="_blank" rel="noopener">把数组排成最小的数</a></h2><p>没啥思路，借鉴了网上的<a href="https://blog.csdn.net/xiaoxingxing1744/article/details/84191277" target="_blank" rel="noopener">解法</a>，觉得很妙。</p>
<p>关键字：自定义比较大小的方法。</p>
<h3 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h3><p>转成字符串，自定义比较器后排序</p>
<h3 id="知识点复习-1"><a href="#知识点复习-1" class="headerlink" title="知识点复习"></a>知识点复习</h3><ul>
<li><p>int类型转成String类型</p>
<ul>
<li>String.valueOf(i)</li>
<li>Integer.toString(i)</li>
<li>i+””</li>
</ul>
</li>
<li><p>比较字符串大小</p>
</li>
<li><p>拼接字符串 （StringBuilder）</p>
<ul>
<li>sb.append()</li>
<li>sb.toString()</li>
</ul>
</li>
<li><p>代码细节</p>
<ul>
<li><p>Arrays.sort()</p>
<ul>
<li>import java.util.Arrays;</li>
</ul>
</li>
<li><p>Comparator</p>
</li>
<li><p>import java.util.Comparator;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span> </span>&#123;   <span class="comment">//3  12  312 123</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by hfq on 2020/4/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@used</span> to:</span></span><br><span class="line"><span class="comment"> * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，</span></span><br><span class="line"><span class="comment"> * 打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>把数组排成最小的数 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String numString [] = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++)&#123;</span><br><span class="line">            numString[i]=String.valueOf(numbers[i]); <span class="comment">//将整数转成字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(numString, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span> </span>&#123;   <span class="comment">//3  12  312 123</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (String str : numString)&#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]numbers=&#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">321</span>&#125;;</span><br><span class="line">        System.out.println(PrintMinNumber(numbers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>进度：25题/67题。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-05-09T17:15:53.910Z" itemprop="dateUpdated">2020-05-10 01:15:53</time>
</span><br>


        
        欢迎留言评论！
        
    </div>
    
    <footer>
        <a href="http://HFQ123.github.io">
            <img src="/images/hfq-favicon.jpg" alt="然后就">
            然后就
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag">剑指Offer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" rel="tag">算法刷题</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/&title=《【每日更新】算法题》 — 然后就的博客&pic=http://HFQ123.github.ioimages/hfq-favicon.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/&title=《【每日更新】算法题》 — 然后就的博客&source=分享我的学习内容：Java,SpringBoot,设计模式,算法...." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【每日更新】算法题》 — 然后就的博客&url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/&via=http://HFQ123.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/04/26/%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">密码测试文章</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/04/21/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0charpter8/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">《Head-First-设计模式》读书笔记charpter8</h4>
      </a>
    </div>
  
</nav>



    














<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: '5266827d0c65b2c78ad9',
          clientSecret: 'c22957154ff2940eb1ebf851cc743c62df14878b',
          repo: 'blog_comment',
          owner: 'HFQ123',
          admin: ['HFQ123'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>然后就 &copy; 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/&title=《【每日更新】算法题》 — 然后就的博客&pic=http://HFQ123.github.ioimages/hfq-favicon.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/&title=《【每日更新】算法题》 — 然后就的博客&source=分享我的学习内容：Java,SpringBoot,设计模式,算法...." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【每日更新】算法题》 — 然后就的博客&url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/&via=http://HFQ123.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://hfq123.github.io/2020/04/21/%E3%80%90%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0%E3%80%91%E7%AE%97%E6%B3%95%E9%A2%98/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
