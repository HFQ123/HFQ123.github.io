进程是动态的，程序是静态的。



并发：同一时间段内应对多件任务的能力，同一个时间段内，多个线程轮流占用CPU执行，是由任务调度器实现的 ，

并行：CPU有多个核心数才有可能，多个线程同时执行

4个线程，2个核心：既有并行，又有并发。



吃一口肉，跑一步，再吃一口肉，再跑一不

我的理解：并发中存在轮流交替（中途有线程切换），如果完全等线程1做完，再做线程2，这就不是并发了



java想让方法调用变成异步的，只能多线程实现。



![image-20200501215122428](../images/image-20200501215122428.png)

栈帧中保存了返回地址，以便回到调用位置，继续向下运行

就绪和运行状态：Runninng

图解，线程栈内存空间、线程上下文切换

![image-20200501223440569](../images/image-20200501223440569.png)



yield和sleep的区别：

sleep使得线程进入阻塞状态，而yield使线程进入就绪状态



[函数式接口](https://www.jianshu.com/p/52cdc402fb5d)

组合优于继承 Thread类中组合了Runnable target



```
/** 会重置打断标记
 * Tests whether the current thread has been interrupted.  The
 * <i>interrupted status</i> of the thread is cleared by this method.  In
 * other words, if this method were to be called twice in succession, the
 * second call would return false (unless the current thread were
 * interrupted again, after the first call had cleared its interrupted
 * status and before the second call had examined it).
 *
 * <p>A thread interruption ignored because a thread was not alive
 * at the time of the interrupt will be reflected by this method
 * returning false.
 *
 * @return  <code>true</code> if the current thread has been interrupted;
 *          <code>false</code> otherwise.
 * @see #isInterrupted()
 * @revised 6.0
 */
public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
```